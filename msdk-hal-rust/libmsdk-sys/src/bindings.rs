/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const __NEWLIB_H__: u32 = 1;
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6] = b"4.3.0\0";
pub const __NEWLIB__: u32 = 4;
pub const __NEWLIB_MINOR__: u32 = 3;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _HAVE_INITFINI_ARRAY: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _MB_CAPABLE: u32 = 1;
pub const _MB_LEN_MAX: u32 = 8;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _RETARGETABLE_LOCKING: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_REGISTER_FINI: u32 = 1;
pub const _WANT_USE_GDTOA: u32 = 1;
pub const _WIDE_ORIENT: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const __RAND_MAX: u32 = 2147483647;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SORD: u32 = 8192;
pub const __SL64: u32 = 32768;
pub const __SNLK: u32 = 1;
pub const __SWID: u32 = 8192;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const EOF: i32 = -1;
pub const BUFSIZ: u32 = 1024;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const L_tmpnam: u32 = 1024;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const TMP_MAX: u32 = 26;
pub const L_ctermid: u32 = 16;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3] = b"hh\0";
pub const __INT16: &[u8; 2] = b"h\0";
pub const __INT64: &[u8; 3] = b"ll\0";
pub const __FAST8: &[u8; 3] = b"hh\0";
pub const __FAST16: &[u8; 2] = b"h\0";
pub const __FAST64: &[u8; 3] = b"ll\0";
pub const __LEAST8: &[u8; 3] = b"hh\0";
pub const __LEAST16: &[u8; 2] = b"h\0";
pub const __LEAST64: &[u8; 3] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const MXC_F_SPI_FIFO32_DATA_POS: u32 = 0;
pub const MXC_F_SPI_FIFO16_DATA_POS: u32 = 0;
pub const MXC_F_SPI_FIFO8_DATA_POS: u32 = 0;
pub const MXC_F_SPI_CTRL0_EN_POS: u32 = 0;
pub const MXC_F_SPI_CTRL0_MST_MODE_POS: u32 = 1;
pub const MXC_F_SPI_CTRL0_SS_IO_POS: u32 = 4;
pub const MXC_F_SPI_CTRL0_START_POS: u32 = 5;
pub const MXC_F_SPI_CTRL0_SS_CTRL_POS: u32 = 8;
pub const MXC_F_SPI_CTRL0_SS_ACTIVE_POS: u32 = 16;
pub const MXC_F_SPI_CTRL1_TX_NUM_CHAR_POS: u32 = 0;
pub const MXC_F_SPI_CTRL1_RX_NUM_CHAR_POS: u32 = 16;
pub const MXC_F_SPI_CTRL2_CLKPHA_POS: u32 = 0;
pub const MXC_F_SPI_CTRL2_CLKPOL_POS: u32 = 1;
pub const MXC_F_SPI_CTRL2_NUMBITS_POS: u32 = 8;
pub const MXC_F_SPI_CTRL2_DATA_WIDTH_POS: u32 = 12;
pub const MXC_F_SPI_CTRL2_THREE_WIRE_POS: u32 = 15;
pub const MXC_F_SPI_CTRL2_SS_POL_POS: u32 = 16;
pub const MXC_F_SPI_SSTIME_PRE_POS: u32 = 0;
pub const MXC_F_SPI_SSTIME_POST_POS: u32 = 8;
pub const MXC_F_SPI_SSTIME_INACT_POS: u32 = 16;
pub const MXC_F_SPI_CLKCTRL_LO_POS: u32 = 0;
pub const MXC_F_SPI_CLKCTRL_HI_POS: u32 = 8;
pub const MXC_F_SPI_CLKCTRL_CLKDIV_POS: u32 = 16;
pub const MXC_F_SPI_DMA_TX_THD_VAL_POS: u32 = 0;
pub const MXC_F_SPI_DMA_TX_FIFO_EN_POS: u32 = 6;
pub const MXC_F_SPI_DMA_TX_FLUSH_POS: u32 = 7;
pub const MXC_F_SPI_DMA_TX_LVL_POS: u32 = 8;
pub const MXC_F_SPI_DMA_DMA_TX_EN_POS: u32 = 15;
pub const MXC_F_SPI_DMA_RX_THD_VAL_POS: u32 = 16;
pub const MXC_F_SPI_DMA_RX_FIFO_EN_POS: u32 = 22;
pub const MXC_F_SPI_DMA_RX_FLUSH_POS: u32 = 23;
pub const MXC_F_SPI_DMA_RX_LVL_POS: u32 = 24;
pub const MXC_F_SPI_DMA_DMA_RX_EN_POS: u32 = 31;
pub const MXC_F_SPI_INTFL_TX_THD_POS: u32 = 0;
pub const MXC_F_SPI_INTFL_TX_EM_POS: u32 = 1;
pub const MXC_F_SPI_INTFL_RX_THD_POS: u32 = 2;
pub const MXC_F_SPI_INTFL_RX_FULL_POS: u32 = 3;
pub const MXC_F_SPI_INTFL_SSA_POS: u32 = 4;
pub const MXC_F_SPI_INTFL_SSD_POS: u32 = 5;
pub const MXC_F_SPI_INTFL_FAULT_POS: u32 = 8;
pub const MXC_F_SPI_INTFL_ABORT_POS: u32 = 9;
pub const MXC_F_SPI_INTFL_MST_DONE_POS: u32 = 11;
pub const MXC_F_SPI_INTFL_TX_OV_POS: u32 = 12;
pub const MXC_F_SPI_INTFL_TX_UN_POS: u32 = 13;
pub const MXC_F_SPI_INTFL_RX_OV_POS: u32 = 14;
pub const MXC_F_SPI_INTFL_RX_UN_POS: u32 = 15;
pub const MXC_F_SPI_INTEN_TX_THD_POS: u32 = 0;
pub const MXC_F_SPI_INTEN_TX_EM_POS: u32 = 1;
pub const MXC_F_SPI_INTEN_RX_THD_POS: u32 = 2;
pub const MXC_F_SPI_INTEN_RX_FULL_POS: u32 = 3;
pub const MXC_F_SPI_INTEN_SSA_POS: u32 = 4;
pub const MXC_F_SPI_INTEN_SSD_POS: u32 = 5;
pub const MXC_F_SPI_INTEN_FAULT_POS: u32 = 8;
pub const MXC_F_SPI_INTEN_ABORT_POS: u32 = 9;
pub const MXC_F_SPI_INTEN_MST_DONE_POS: u32 = 11;
pub const MXC_F_SPI_INTEN_TX_OV_POS: u32 = 12;
pub const MXC_F_SPI_INTEN_TX_UN_POS: u32 = 13;
pub const MXC_F_SPI_INTEN_RX_OV_POS: u32 = 14;
pub const MXC_F_SPI_INTEN_RX_UN_POS: u32 = 15;
pub const MXC_F_SPI_WKFL_TX_THD_POS: u32 = 0;
pub const MXC_F_SPI_WKFL_TX_EM_POS: u32 = 1;
pub const MXC_F_SPI_WKFL_RX_THD_POS: u32 = 2;
pub const MXC_F_SPI_WKFL_RX_FULL_POS: u32 = 3;
pub const MXC_F_SPI_WKEN_TX_THD_POS: u32 = 0;
pub const MXC_F_SPI_WKEN_TX_EM_POS: u32 = 1;
pub const MXC_F_SPI_WKEN_RX_THD_POS: u32 = 2;
pub const MXC_F_SPI_WKEN_RX_FULL_POS: u32 = 3;
pub const MXC_F_SPI_STAT_BUSY_POS: u32 = 0;
pub const MXC_F_GPIO_EN0_GPIO_EN_POS: u32 = 0;
pub const MXC_F_GPIO_EN0_SET_ALL_POS: u32 = 0;
pub const MXC_F_GPIO_EN0_CLR_ALL_POS: u32 = 0;
pub const MXC_F_GPIO_OUTEN_EN_POS: u32 = 0;
pub const MXC_F_GPIO_OUTEN_SET_ALL_POS: u32 = 0;
pub const MXC_F_GPIO_OUTEN_CLR_ALL_POS: u32 = 0;
pub const MXC_F_GPIO_OUT_GPIO_OUT_POS: u32 = 0;
pub const MXC_F_GPIO_OUT_SET_GPIO_OUT_SET_POS: u32 = 0;
pub const MXC_F_GPIO_OUT_CLR_GPIO_OUT_CLR_POS: u32 = 0;
pub const MXC_F_GPIO_IN_GPIO_IN_POS: u32 = 0;
pub const MXC_F_GPIO_INTMODE_GPIO_INTMODE_POS: u32 = 0;
pub const MXC_F_GPIO_INTPOL_GPIO_INTPOL_POS: u32 = 0;
pub const MXC_F_GPIO_INTEN_GPIO_INTEN_POS: u32 = 0;
pub const MXC_F_GPIO_INTEN_SET_GPIO_INTEN_SET_POS: u32 = 0;
pub const MXC_F_GPIO_INTEN_CLR_GPIO_INTEN_CLR_POS: u32 = 0;
pub const MXC_F_GPIO_INTFL_GPIO_INTFL_POS: u32 = 0;
pub const MXC_F_GPIO_INTFL_CLR_ALL_POS: u32 = 0;
pub const MXC_F_GPIO_WKEN_GPIO_WKEN_POS: u32 = 0;
pub const MXC_F_GPIO_WKEN_SET_ALL_POS: u32 = 0;
pub const MXC_F_GPIO_WKEN_CLR_ALL_POS: u32 = 0;
pub const MXC_F_GPIO_DUALEDGE_GPIO_DUALEDGE_POS: u32 = 0;
pub const MXC_F_GPIO_PADCTRL0_GPIO_PADCTRL0_POS: u32 = 0;
pub const MXC_F_GPIO_PADCTRL1_GPIO_PADCTRL1_POS: u32 = 0;
pub const MXC_F_GPIO_EN1_GPIO_EN1_POS: u32 = 0;
pub const MXC_F_GPIO_EN1_SET_ALL_POS: u32 = 0;
pub const MXC_F_GPIO_EN1_CLR_ALL_POS: u32 = 0;
pub const MXC_F_GPIO_EN2_GPIO_EN2_POS: u32 = 0;
pub const MXC_F_GPIO_EN2_SET_ALL_POS: u32 = 0;
pub const MXC_F_GPIO_EN2_CLR_ALL_POS: u32 = 0;
pub const MXC_F_GPIO_HYSEN_GPIO_HYSEN_POS: u32 = 0;
pub const MXC_F_GPIO_SRSEL_GPIO_SRSEL_POS: u32 = 0;
pub const MXC_F_GPIO_DS0_GPIO_DS0_POS: u32 = 0;
pub const MXC_F_GPIO_DS1_GPIO_DS1_POS: u32 = 0;
pub const MXC_F_GPIO_PS_ALL_POS: u32 = 0;
pub const MXC_F_GPIO_VSSEL_ALL_POS: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const TARGET_NUM: u32 = 78000;
pub const MXC_NUMCORES: u32 = 2;
pub const FALSE: u32 = 0;
pub const TRUE: u32 = 1;
pub const __CM4_REV: u32 = 256;
pub const __MPU_PRESENT: u32 = 1;
pub const __NVIC_PRIO_BITS: u32 = 3;
pub const __Vendor_SysTickConfig: u32 = 0;
pub const __FPU_PRESENT: u32 = 1;
pub const __CM_CMSIS_VERSION_MAIN: u32 = 5;
pub const __CM_CMSIS_VERSION_SUB: u32 = 6;
pub const __CM_CMSIS_VERSION: u32 = 327686;
pub const __CM4_CMSIS_VERSION_MAIN: u32 = 5;
pub const __CM4_CMSIS_VERSION_SUB: u32 = 6;
pub const __CM4_CMSIS_VERSION: u32 = 327686;
pub const __CORTEX_M: u32 = 4;
pub const __FPU_USED: u32 = 0;
pub const APSR_N_Pos: u32 = 31;
pub const APSR_N_Msk: u32 = 2147483648;
pub const APSR_Z_Pos: u32 = 30;
pub const APSR_Z_Msk: u32 = 1073741824;
pub const APSR_C_Pos: u32 = 29;
pub const APSR_C_Msk: u32 = 536870912;
pub const APSR_V_Pos: u32 = 28;
pub const APSR_V_Msk: u32 = 268435456;
pub const APSR_Q_Pos: u32 = 27;
pub const APSR_Q_Msk: u32 = 134217728;
pub const APSR_GE_Pos: u32 = 16;
pub const APSR_GE_Msk: u32 = 983040;
pub const IPSR_ISR_Pos: u32 = 0;
pub const IPSR_ISR_Msk: u32 = 511;
pub const xPSR_N_Pos: u32 = 31;
pub const xPSR_N_Msk: u32 = 2147483648;
pub const xPSR_Z_Pos: u32 = 30;
pub const xPSR_Z_Msk: u32 = 1073741824;
pub const xPSR_C_Pos: u32 = 29;
pub const xPSR_C_Msk: u32 = 536870912;
pub const xPSR_V_Pos: u32 = 28;
pub const xPSR_V_Msk: u32 = 268435456;
pub const xPSR_Q_Pos: u32 = 27;
pub const xPSR_Q_Msk: u32 = 134217728;
pub const xPSR_ICI_IT_2_Pos: u32 = 25;
pub const xPSR_ICI_IT_2_Msk: u32 = 100663296;
pub const xPSR_T_Pos: u32 = 24;
pub const xPSR_T_Msk: u32 = 16777216;
pub const xPSR_GE_Pos: u32 = 16;
pub const xPSR_GE_Msk: u32 = 983040;
pub const xPSR_ICI_IT_1_Pos: u32 = 10;
pub const xPSR_ICI_IT_1_Msk: u32 = 64512;
pub const xPSR_ISR_Pos: u32 = 0;
pub const xPSR_ISR_Msk: u32 = 511;
pub const CONTROL_FPCA_Pos: u32 = 2;
pub const CONTROL_FPCA_Msk: u32 = 4;
pub const CONTROL_SPSEL_Pos: u32 = 1;
pub const CONTROL_SPSEL_Msk: u32 = 2;
pub const CONTROL_nPRIV_Pos: u32 = 0;
pub const CONTROL_nPRIV_Msk: u32 = 1;
pub const NVIC_STIR_INTID_Pos: u32 = 0;
pub const NVIC_STIR_INTID_Msk: u32 = 511;
pub const SCB_CPUID_IMPLEMENTER_Pos: u32 = 24;
pub const SCB_CPUID_IMPLEMENTER_Msk: u32 = 4278190080;
pub const SCB_CPUID_VARIANT_Pos: u32 = 20;
pub const SCB_CPUID_VARIANT_Msk: u32 = 15728640;
pub const SCB_CPUID_ARCHITECTURE_Pos: u32 = 16;
pub const SCB_CPUID_ARCHITECTURE_Msk: u32 = 983040;
pub const SCB_CPUID_PARTNO_Pos: u32 = 4;
pub const SCB_CPUID_PARTNO_Msk: u32 = 65520;
pub const SCB_CPUID_REVISION_Pos: u32 = 0;
pub const SCB_CPUID_REVISION_Msk: u32 = 15;
pub const SCB_ICSR_NMIPENDSET_Pos: u32 = 31;
pub const SCB_ICSR_NMIPENDSET_Msk: u32 = 2147483648;
pub const SCB_ICSR_PENDSVSET_Pos: u32 = 28;
pub const SCB_ICSR_PENDSVSET_Msk: u32 = 268435456;
pub const SCB_ICSR_PENDSVCLR_Pos: u32 = 27;
pub const SCB_ICSR_PENDSVCLR_Msk: u32 = 134217728;
pub const SCB_ICSR_PENDSTSET_Pos: u32 = 26;
pub const SCB_ICSR_PENDSTSET_Msk: u32 = 67108864;
pub const SCB_ICSR_PENDSTCLR_Pos: u32 = 25;
pub const SCB_ICSR_PENDSTCLR_Msk: u32 = 33554432;
pub const SCB_ICSR_ISRPREEMPT_Pos: u32 = 23;
pub const SCB_ICSR_ISRPREEMPT_Msk: u32 = 8388608;
pub const SCB_ICSR_ISRPENDING_Pos: u32 = 22;
pub const SCB_ICSR_ISRPENDING_Msk: u32 = 4194304;
pub const SCB_ICSR_VECTPENDING_Pos: u32 = 12;
pub const SCB_ICSR_VECTPENDING_Msk: u32 = 2093056;
pub const SCB_ICSR_RETTOBASE_Pos: u32 = 11;
pub const SCB_ICSR_RETTOBASE_Msk: u32 = 2048;
pub const SCB_ICSR_VECTACTIVE_Pos: u32 = 0;
pub const SCB_ICSR_VECTACTIVE_Msk: u32 = 511;
pub const SCB_VTOR_TBLOFF_Pos: u32 = 7;
pub const SCB_VTOR_TBLOFF_Msk: u32 = 4294967168;
pub const SCB_AIRCR_VECTKEY_Pos: u32 = 16;
pub const SCB_AIRCR_VECTKEY_Msk: u32 = 4294901760;
pub const SCB_AIRCR_VECTKEYSTAT_Pos: u32 = 16;
pub const SCB_AIRCR_VECTKEYSTAT_Msk: u32 = 4294901760;
pub const SCB_AIRCR_ENDIANESS_Pos: u32 = 15;
pub const SCB_AIRCR_ENDIANESS_Msk: u32 = 32768;
pub const SCB_AIRCR_PRIGROUP_Pos: u32 = 8;
pub const SCB_AIRCR_PRIGROUP_Msk: u32 = 1792;
pub const SCB_AIRCR_SYSRESETREQ_Pos: u32 = 2;
pub const SCB_AIRCR_SYSRESETREQ_Msk: u32 = 4;
pub const SCB_AIRCR_VECTCLRACTIVE_Pos: u32 = 1;
pub const SCB_AIRCR_VECTCLRACTIVE_Msk: u32 = 2;
pub const SCB_AIRCR_VECTRESET_Pos: u32 = 0;
pub const SCB_AIRCR_VECTRESET_Msk: u32 = 1;
pub const SCB_SCR_SEVONPEND_Pos: u32 = 4;
pub const SCB_SCR_SEVONPEND_Msk: u32 = 16;
pub const SCB_SCR_SLEEPDEEP_Pos: u32 = 2;
pub const SCB_SCR_SLEEPDEEP_Msk: u32 = 4;
pub const SCB_SCR_SLEEPONEXIT_Pos: u32 = 1;
pub const SCB_SCR_SLEEPONEXIT_Msk: u32 = 2;
pub const SCB_CCR_STKALIGN_Pos: u32 = 9;
pub const SCB_CCR_STKALIGN_Msk: u32 = 512;
pub const SCB_CCR_BFHFNMIGN_Pos: u32 = 8;
pub const SCB_CCR_BFHFNMIGN_Msk: u32 = 256;
pub const SCB_CCR_DIV_0_TRP_Pos: u32 = 4;
pub const SCB_CCR_DIV_0_TRP_Msk: u32 = 16;
pub const SCB_CCR_UNALIGN_TRP_Pos: u32 = 3;
pub const SCB_CCR_UNALIGN_TRP_Msk: u32 = 8;
pub const SCB_CCR_USERSETMPEND_Pos: u32 = 1;
pub const SCB_CCR_USERSETMPEND_Msk: u32 = 2;
pub const SCB_CCR_NONBASETHRDENA_Pos: u32 = 0;
pub const SCB_CCR_NONBASETHRDENA_Msk: u32 = 1;
pub const SCB_SHCSR_USGFAULTENA_Pos: u32 = 18;
pub const SCB_SHCSR_USGFAULTENA_Msk: u32 = 262144;
pub const SCB_SHCSR_BUSFAULTENA_Pos: u32 = 17;
pub const SCB_SHCSR_BUSFAULTENA_Msk: u32 = 131072;
pub const SCB_SHCSR_MEMFAULTENA_Pos: u32 = 16;
pub const SCB_SHCSR_MEMFAULTENA_Msk: u32 = 65536;
pub const SCB_SHCSR_SVCALLPENDED_Pos: u32 = 15;
pub const SCB_SHCSR_SVCALLPENDED_Msk: u32 = 32768;
pub const SCB_SHCSR_BUSFAULTPENDED_Pos: u32 = 14;
pub const SCB_SHCSR_BUSFAULTPENDED_Msk: u32 = 16384;
pub const SCB_SHCSR_MEMFAULTPENDED_Pos: u32 = 13;
pub const SCB_SHCSR_MEMFAULTPENDED_Msk: u32 = 8192;
pub const SCB_SHCSR_USGFAULTPENDED_Pos: u32 = 12;
pub const SCB_SHCSR_USGFAULTPENDED_Msk: u32 = 4096;
pub const SCB_SHCSR_SYSTICKACT_Pos: u32 = 11;
pub const SCB_SHCSR_SYSTICKACT_Msk: u32 = 2048;
pub const SCB_SHCSR_PENDSVACT_Pos: u32 = 10;
pub const SCB_SHCSR_PENDSVACT_Msk: u32 = 1024;
pub const SCB_SHCSR_MONITORACT_Pos: u32 = 8;
pub const SCB_SHCSR_MONITORACT_Msk: u32 = 256;
pub const SCB_SHCSR_SVCALLACT_Pos: u32 = 7;
pub const SCB_SHCSR_SVCALLACT_Msk: u32 = 128;
pub const SCB_SHCSR_USGFAULTACT_Pos: u32 = 3;
pub const SCB_SHCSR_USGFAULTACT_Msk: u32 = 8;
pub const SCB_SHCSR_BUSFAULTACT_Pos: u32 = 1;
pub const SCB_SHCSR_BUSFAULTACT_Msk: u32 = 2;
pub const SCB_SHCSR_MEMFAULTACT_Pos: u32 = 0;
pub const SCB_SHCSR_MEMFAULTACT_Msk: u32 = 1;
pub const SCB_CFSR_USGFAULTSR_Pos: u32 = 16;
pub const SCB_CFSR_USGFAULTSR_Msk: u32 = 4294901760;
pub const SCB_CFSR_BUSFAULTSR_Pos: u32 = 8;
pub const SCB_CFSR_BUSFAULTSR_Msk: u32 = 65280;
pub const SCB_CFSR_MEMFAULTSR_Pos: u32 = 0;
pub const SCB_CFSR_MEMFAULTSR_Msk: u32 = 255;
pub const SCB_CFSR_MMARVALID_Pos: u32 = 7;
pub const SCB_CFSR_MMARVALID_Msk: u32 = 128;
pub const SCB_CFSR_MLSPERR_Pos: u32 = 5;
pub const SCB_CFSR_MLSPERR_Msk: u32 = 32;
pub const SCB_CFSR_MSTKERR_Pos: u32 = 4;
pub const SCB_CFSR_MSTKERR_Msk: u32 = 16;
pub const SCB_CFSR_MUNSTKERR_Pos: u32 = 3;
pub const SCB_CFSR_MUNSTKERR_Msk: u32 = 8;
pub const SCB_CFSR_DACCVIOL_Pos: u32 = 1;
pub const SCB_CFSR_DACCVIOL_Msk: u32 = 2;
pub const SCB_CFSR_IACCVIOL_Pos: u32 = 0;
pub const SCB_CFSR_IACCVIOL_Msk: u32 = 1;
pub const SCB_CFSR_BFARVALID_Pos: u32 = 15;
pub const SCB_CFSR_BFARVALID_Msk: u32 = 32768;
pub const SCB_CFSR_LSPERR_Pos: u32 = 13;
pub const SCB_CFSR_LSPERR_Msk: u32 = 8192;
pub const SCB_CFSR_STKERR_Pos: u32 = 12;
pub const SCB_CFSR_STKERR_Msk: u32 = 4096;
pub const SCB_CFSR_UNSTKERR_Pos: u32 = 11;
pub const SCB_CFSR_UNSTKERR_Msk: u32 = 2048;
pub const SCB_CFSR_IMPRECISERR_Pos: u32 = 10;
pub const SCB_CFSR_IMPRECISERR_Msk: u32 = 1024;
pub const SCB_CFSR_PRECISERR_Pos: u32 = 9;
pub const SCB_CFSR_PRECISERR_Msk: u32 = 512;
pub const SCB_CFSR_IBUSERR_Pos: u32 = 8;
pub const SCB_CFSR_IBUSERR_Msk: u32 = 256;
pub const SCB_CFSR_DIVBYZERO_Pos: u32 = 25;
pub const SCB_CFSR_DIVBYZERO_Msk: u32 = 33554432;
pub const SCB_CFSR_UNALIGNED_Pos: u32 = 24;
pub const SCB_CFSR_UNALIGNED_Msk: u32 = 16777216;
pub const SCB_CFSR_NOCP_Pos: u32 = 19;
pub const SCB_CFSR_NOCP_Msk: u32 = 524288;
pub const SCB_CFSR_INVPC_Pos: u32 = 18;
pub const SCB_CFSR_INVPC_Msk: u32 = 262144;
pub const SCB_CFSR_INVSTATE_Pos: u32 = 17;
pub const SCB_CFSR_INVSTATE_Msk: u32 = 131072;
pub const SCB_CFSR_UNDEFINSTR_Pos: u32 = 16;
pub const SCB_CFSR_UNDEFINSTR_Msk: u32 = 65536;
pub const SCB_HFSR_DEBUGEVT_Pos: u32 = 31;
pub const SCB_HFSR_DEBUGEVT_Msk: u32 = 2147483648;
pub const SCB_HFSR_FORCED_Pos: u32 = 30;
pub const SCB_HFSR_FORCED_Msk: u32 = 1073741824;
pub const SCB_HFSR_VECTTBL_Pos: u32 = 1;
pub const SCB_HFSR_VECTTBL_Msk: u32 = 2;
pub const SCB_DFSR_EXTERNAL_Pos: u32 = 4;
pub const SCB_DFSR_EXTERNAL_Msk: u32 = 16;
pub const SCB_DFSR_VCATCH_Pos: u32 = 3;
pub const SCB_DFSR_VCATCH_Msk: u32 = 8;
pub const SCB_DFSR_DWTTRAP_Pos: u32 = 2;
pub const SCB_DFSR_DWTTRAP_Msk: u32 = 4;
pub const SCB_DFSR_BKPT_Pos: u32 = 1;
pub const SCB_DFSR_BKPT_Msk: u32 = 2;
pub const SCB_DFSR_HALTED_Pos: u32 = 0;
pub const SCB_DFSR_HALTED_Msk: u32 = 1;
pub const SCnSCB_ICTR_INTLINESNUM_Pos: u32 = 0;
pub const SCnSCB_ICTR_INTLINESNUM_Msk: u32 = 15;
pub const SCnSCB_ACTLR_DISOOFP_Pos: u32 = 9;
pub const SCnSCB_ACTLR_DISOOFP_Msk: u32 = 512;
pub const SCnSCB_ACTLR_DISFPCA_Pos: u32 = 8;
pub const SCnSCB_ACTLR_DISFPCA_Msk: u32 = 256;
pub const SCnSCB_ACTLR_DISFOLD_Pos: u32 = 2;
pub const SCnSCB_ACTLR_DISFOLD_Msk: u32 = 4;
pub const SCnSCB_ACTLR_DISDEFWBUF_Pos: u32 = 1;
pub const SCnSCB_ACTLR_DISDEFWBUF_Msk: u32 = 2;
pub const SCnSCB_ACTLR_DISMCYCINT_Pos: u32 = 0;
pub const SCnSCB_ACTLR_DISMCYCINT_Msk: u32 = 1;
pub const SysTick_CTRL_COUNTFLAG_Pos: u32 = 16;
pub const SysTick_CTRL_COUNTFLAG_Msk: u32 = 65536;
pub const SysTick_CTRL_CLKSOURCE_Pos: u32 = 2;
pub const SysTick_CTRL_CLKSOURCE_Msk: u32 = 4;
pub const SysTick_CTRL_TICKINT_Pos: u32 = 1;
pub const SysTick_CTRL_TICKINT_Msk: u32 = 2;
pub const SysTick_CTRL_ENABLE_Pos: u32 = 0;
pub const SysTick_CTRL_ENABLE_Msk: u32 = 1;
pub const SysTick_LOAD_RELOAD_Pos: u32 = 0;
pub const SysTick_LOAD_RELOAD_Msk: u32 = 16777215;
pub const SysTick_VAL_CURRENT_Pos: u32 = 0;
pub const SysTick_VAL_CURRENT_Msk: u32 = 16777215;
pub const SysTick_CALIB_NOREF_Pos: u32 = 31;
pub const SysTick_CALIB_NOREF_Msk: u32 = 2147483648;
pub const SysTick_CALIB_SKEW_Pos: u32 = 30;
pub const SysTick_CALIB_SKEW_Msk: u32 = 1073741824;
pub const SysTick_CALIB_TENMS_Pos: u32 = 0;
pub const SysTick_CALIB_TENMS_Msk: u32 = 16777215;
pub const ITM_TPR_PRIVMASK_Pos: u32 = 0;
pub const ITM_TPR_PRIVMASK_Msk: u32 = 4294967295;
pub const ITM_TCR_BUSY_Pos: u32 = 23;
pub const ITM_TCR_BUSY_Msk: u32 = 8388608;
pub const ITM_TCR_TraceBusID_Pos: u32 = 16;
pub const ITM_TCR_TraceBusID_Msk: u32 = 8323072;
pub const ITM_TCR_GTSFREQ_Pos: u32 = 10;
pub const ITM_TCR_GTSFREQ_Msk: u32 = 3072;
pub const ITM_TCR_TSPrescale_Pos: u32 = 8;
pub const ITM_TCR_TSPrescale_Msk: u32 = 768;
pub const ITM_TCR_SWOENA_Pos: u32 = 4;
pub const ITM_TCR_SWOENA_Msk: u32 = 16;
pub const ITM_TCR_DWTENA_Pos: u32 = 3;
pub const ITM_TCR_DWTENA_Msk: u32 = 8;
pub const ITM_TCR_SYNCENA_Pos: u32 = 2;
pub const ITM_TCR_SYNCENA_Msk: u32 = 4;
pub const ITM_TCR_TSENA_Pos: u32 = 1;
pub const ITM_TCR_TSENA_Msk: u32 = 2;
pub const ITM_TCR_ITMENA_Pos: u32 = 0;
pub const ITM_TCR_ITMENA_Msk: u32 = 1;
pub const ITM_LSR_ByteAcc_Pos: u32 = 2;
pub const ITM_LSR_ByteAcc_Msk: u32 = 4;
pub const ITM_LSR_Access_Pos: u32 = 1;
pub const ITM_LSR_Access_Msk: u32 = 2;
pub const ITM_LSR_Present_Pos: u32 = 0;
pub const ITM_LSR_Present_Msk: u32 = 1;
pub const DWT_CTRL_NUMCOMP_Pos: u32 = 28;
pub const DWT_CTRL_NUMCOMP_Msk: u32 = 4026531840;
pub const DWT_CTRL_NOTRCPKT_Pos: u32 = 27;
pub const DWT_CTRL_NOTRCPKT_Msk: u32 = 134217728;
pub const DWT_CTRL_NOEXTTRIG_Pos: u32 = 26;
pub const DWT_CTRL_NOEXTTRIG_Msk: u32 = 67108864;
pub const DWT_CTRL_NOCYCCNT_Pos: u32 = 25;
pub const DWT_CTRL_NOCYCCNT_Msk: u32 = 33554432;
pub const DWT_CTRL_NOPRFCNT_Pos: u32 = 24;
pub const DWT_CTRL_NOPRFCNT_Msk: u32 = 16777216;
pub const DWT_CTRL_CYCEVTENA_Pos: u32 = 22;
pub const DWT_CTRL_CYCEVTENA_Msk: u32 = 4194304;
pub const DWT_CTRL_FOLDEVTENA_Pos: u32 = 21;
pub const DWT_CTRL_FOLDEVTENA_Msk: u32 = 2097152;
pub const DWT_CTRL_LSUEVTENA_Pos: u32 = 20;
pub const DWT_CTRL_LSUEVTENA_Msk: u32 = 1048576;
pub const DWT_CTRL_SLEEPEVTENA_Pos: u32 = 19;
pub const DWT_CTRL_SLEEPEVTENA_Msk: u32 = 524288;
pub const DWT_CTRL_EXCEVTENA_Pos: u32 = 18;
pub const DWT_CTRL_EXCEVTENA_Msk: u32 = 262144;
pub const DWT_CTRL_CPIEVTENA_Pos: u32 = 17;
pub const DWT_CTRL_CPIEVTENA_Msk: u32 = 131072;
pub const DWT_CTRL_EXCTRCENA_Pos: u32 = 16;
pub const DWT_CTRL_EXCTRCENA_Msk: u32 = 65536;
pub const DWT_CTRL_PCSAMPLENA_Pos: u32 = 12;
pub const DWT_CTRL_PCSAMPLENA_Msk: u32 = 4096;
pub const DWT_CTRL_SYNCTAP_Pos: u32 = 10;
pub const DWT_CTRL_SYNCTAP_Msk: u32 = 3072;
pub const DWT_CTRL_CYCTAP_Pos: u32 = 9;
pub const DWT_CTRL_CYCTAP_Msk: u32 = 512;
pub const DWT_CTRL_POSTINIT_Pos: u32 = 5;
pub const DWT_CTRL_POSTINIT_Msk: u32 = 480;
pub const DWT_CTRL_POSTPRESET_Pos: u32 = 1;
pub const DWT_CTRL_POSTPRESET_Msk: u32 = 30;
pub const DWT_CTRL_CYCCNTENA_Pos: u32 = 0;
pub const DWT_CTRL_CYCCNTENA_Msk: u32 = 1;
pub const DWT_CPICNT_CPICNT_Pos: u32 = 0;
pub const DWT_CPICNT_CPICNT_Msk: u32 = 255;
pub const DWT_EXCCNT_EXCCNT_Pos: u32 = 0;
pub const DWT_EXCCNT_EXCCNT_Msk: u32 = 255;
pub const DWT_SLEEPCNT_SLEEPCNT_Pos: u32 = 0;
pub const DWT_SLEEPCNT_SLEEPCNT_Msk: u32 = 255;
pub const DWT_LSUCNT_LSUCNT_Pos: u32 = 0;
pub const DWT_LSUCNT_LSUCNT_Msk: u32 = 255;
pub const DWT_FOLDCNT_FOLDCNT_Pos: u32 = 0;
pub const DWT_FOLDCNT_FOLDCNT_Msk: u32 = 255;
pub const DWT_MASK_MASK_Pos: u32 = 0;
pub const DWT_MASK_MASK_Msk: u32 = 31;
pub const DWT_FUNCTION_MATCHED_Pos: u32 = 24;
pub const DWT_FUNCTION_MATCHED_Msk: u32 = 16777216;
pub const DWT_FUNCTION_DATAVADDR1_Pos: u32 = 16;
pub const DWT_FUNCTION_DATAVADDR1_Msk: u32 = 983040;
pub const DWT_FUNCTION_DATAVADDR0_Pos: u32 = 12;
pub const DWT_FUNCTION_DATAVADDR0_Msk: u32 = 61440;
pub const DWT_FUNCTION_DATAVSIZE_Pos: u32 = 10;
pub const DWT_FUNCTION_DATAVSIZE_Msk: u32 = 3072;
pub const DWT_FUNCTION_LNK1ENA_Pos: u32 = 9;
pub const DWT_FUNCTION_LNK1ENA_Msk: u32 = 512;
pub const DWT_FUNCTION_DATAVMATCH_Pos: u32 = 8;
pub const DWT_FUNCTION_DATAVMATCH_Msk: u32 = 256;
pub const DWT_FUNCTION_CYCMATCH_Pos: u32 = 7;
pub const DWT_FUNCTION_CYCMATCH_Msk: u32 = 128;
pub const DWT_FUNCTION_EMITRANGE_Pos: u32 = 5;
pub const DWT_FUNCTION_EMITRANGE_Msk: u32 = 32;
pub const DWT_FUNCTION_FUNCTION_Pos: u32 = 0;
pub const DWT_FUNCTION_FUNCTION_Msk: u32 = 15;
pub const TPI_ACPR_PRESCALER_Pos: u32 = 0;
pub const TPI_ACPR_PRESCALER_Msk: u32 = 8191;
pub const TPI_SPPR_TXMODE_Pos: u32 = 0;
pub const TPI_SPPR_TXMODE_Msk: u32 = 3;
pub const TPI_FFSR_FtNonStop_Pos: u32 = 3;
pub const TPI_FFSR_FtNonStop_Msk: u32 = 8;
pub const TPI_FFSR_TCPresent_Pos: u32 = 2;
pub const TPI_FFSR_TCPresent_Msk: u32 = 4;
pub const TPI_FFSR_FtStopped_Pos: u32 = 1;
pub const TPI_FFSR_FtStopped_Msk: u32 = 2;
pub const TPI_FFSR_FlInProg_Pos: u32 = 0;
pub const TPI_FFSR_FlInProg_Msk: u32 = 1;
pub const TPI_FFCR_TrigIn_Pos: u32 = 8;
pub const TPI_FFCR_TrigIn_Msk: u32 = 256;
pub const TPI_FFCR_EnFCont_Pos: u32 = 1;
pub const TPI_FFCR_EnFCont_Msk: u32 = 2;
pub const TPI_TRIGGER_TRIGGER_Pos: u32 = 0;
pub const TPI_TRIGGER_TRIGGER_Msk: u32 = 1;
pub const TPI_FIFO0_ITM_ATVALID_Pos: u32 = 29;
pub const TPI_FIFO0_ITM_ATVALID_Msk: u32 = 536870912;
pub const TPI_FIFO0_ITM_bytecount_Pos: u32 = 27;
pub const TPI_FIFO0_ITM_bytecount_Msk: u32 = 402653184;
pub const TPI_FIFO0_ETM_ATVALID_Pos: u32 = 26;
pub const TPI_FIFO0_ETM_ATVALID_Msk: u32 = 67108864;
pub const TPI_FIFO0_ETM_bytecount_Pos: u32 = 24;
pub const TPI_FIFO0_ETM_bytecount_Msk: u32 = 50331648;
pub const TPI_FIFO0_ETM2_Pos: u32 = 16;
pub const TPI_FIFO0_ETM2_Msk: u32 = 16711680;
pub const TPI_FIFO0_ETM1_Pos: u32 = 8;
pub const TPI_FIFO0_ETM1_Msk: u32 = 65280;
pub const TPI_FIFO0_ETM0_Pos: u32 = 0;
pub const TPI_FIFO0_ETM0_Msk: u32 = 255;
pub const TPI_ITATBCTR2_ATREADY2_Pos: u32 = 0;
pub const TPI_ITATBCTR2_ATREADY2_Msk: u32 = 1;
pub const TPI_ITATBCTR2_ATREADY1_Pos: u32 = 0;
pub const TPI_ITATBCTR2_ATREADY1_Msk: u32 = 1;
pub const TPI_FIFO1_ITM_ATVALID_Pos: u32 = 29;
pub const TPI_FIFO1_ITM_ATVALID_Msk: u32 = 536870912;
pub const TPI_FIFO1_ITM_bytecount_Pos: u32 = 27;
pub const TPI_FIFO1_ITM_bytecount_Msk: u32 = 402653184;
pub const TPI_FIFO1_ETM_ATVALID_Pos: u32 = 26;
pub const TPI_FIFO1_ETM_ATVALID_Msk: u32 = 67108864;
pub const TPI_FIFO1_ETM_bytecount_Pos: u32 = 24;
pub const TPI_FIFO1_ETM_bytecount_Msk: u32 = 50331648;
pub const TPI_FIFO1_ITM2_Pos: u32 = 16;
pub const TPI_FIFO1_ITM2_Msk: u32 = 16711680;
pub const TPI_FIFO1_ITM1_Pos: u32 = 8;
pub const TPI_FIFO1_ITM1_Msk: u32 = 65280;
pub const TPI_FIFO1_ITM0_Pos: u32 = 0;
pub const TPI_FIFO1_ITM0_Msk: u32 = 255;
pub const TPI_ITATBCTR0_ATREADY2_Pos: u32 = 0;
pub const TPI_ITATBCTR0_ATREADY2_Msk: u32 = 1;
pub const TPI_ITATBCTR0_ATREADY1_Pos: u32 = 0;
pub const TPI_ITATBCTR0_ATREADY1_Msk: u32 = 1;
pub const TPI_ITCTRL_Mode_Pos: u32 = 0;
pub const TPI_ITCTRL_Mode_Msk: u32 = 3;
pub const TPI_DEVID_NRZVALID_Pos: u32 = 11;
pub const TPI_DEVID_NRZVALID_Msk: u32 = 2048;
pub const TPI_DEVID_MANCVALID_Pos: u32 = 10;
pub const TPI_DEVID_MANCVALID_Msk: u32 = 1024;
pub const TPI_DEVID_PTINVALID_Pos: u32 = 9;
pub const TPI_DEVID_PTINVALID_Msk: u32 = 512;
pub const TPI_DEVID_MinBufSz_Pos: u32 = 6;
pub const TPI_DEVID_MinBufSz_Msk: u32 = 448;
pub const TPI_DEVID_AsynClkIn_Pos: u32 = 5;
pub const TPI_DEVID_AsynClkIn_Msk: u32 = 32;
pub const TPI_DEVID_NrTraceInput_Pos: u32 = 0;
pub const TPI_DEVID_NrTraceInput_Msk: u32 = 31;
pub const TPI_DEVTYPE_SubType_Pos: u32 = 4;
pub const TPI_DEVTYPE_SubType_Msk: u32 = 15;
pub const TPI_DEVTYPE_MajorType_Pos: u32 = 0;
pub const TPI_DEVTYPE_MajorType_Msk: u32 = 15;
pub const MPU_TYPE_RALIASES: u32 = 4;
pub const MPU_TYPE_IREGION_Pos: u32 = 16;
pub const MPU_TYPE_IREGION_Msk: u32 = 16711680;
pub const MPU_TYPE_DREGION_Pos: u32 = 8;
pub const MPU_TYPE_DREGION_Msk: u32 = 65280;
pub const MPU_TYPE_SEPARATE_Pos: u32 = 0;
pub const MPU_TYPE_SEPARATE_Msk: u32 = 1;
pub const MPU_CTRL_PRIVDEFENA_Pos: u32 = 2;
pub const MPU_CTRL_PRIVDEFENA_Msk: u32 = 4;
pub const MPU_CTRL_HFNMIENA_Pos: u32 = 1;
pub const MPU_CTRL_HFNMIENA_Msk: u32 = 2;
pub const MPU_CTRL_ENABLE_Pos: u32 = 0;
pub const MPU_CTRL_ENABLE_Msk: u32 = 1;
pub const MPU_RNR_REGION_Pos: u32 = 0;
pub const MPU_RNR_REGION_Msk: u32 = 255;
pub const MPU_RBAR_ADDR_Pos: u32 = 5;
pub const MPU_RBAR_ADDR_Msk: u32 = 4294967264;
pub const MPU_RBAR_VALID_Pos: u32 = 4;
pub const MPU_RBAR_VALID_Msk: u32 = 16;
pub const MPU_RBAR_REGION_Pos: u32 = 0;
pub const MPU_RBAR_REGION_Msk: u32 = 15;
pub const MPU_RASR_ATTRS_Pos: u32 = 16;
pub const MPU_RASR_ATTRS_Msk: u32 = 4294901760;
pub const MPU_RASR_XN_Pos: u32 = 28;
pub const MPU_RASR_XN_Msk: u32 = 268435456;
pub const MPU_RASR_AP_Pos: u32 = 24;
pub const MPU_RASR_AP_Msk: u32 = 117440512;
pub const MPU_RASR_TEX_Pos: u32 = 19;
pub const MPU_RASR_TEX_Msk: u32 = 3670016;
pub const MPU_RASR_S_Pos: u32 = 18;
pub const MPU_RASR_S_Msk: u32 = 262144;
pub const MPU_RASR_C_Pos: u32 = 17;
pub const MPU_RASR_C_Msk: u32 = 131072;
pub const MPU_RASR_B_Pos: u32 = 16;
pub const MPU_RASR_B_Msk: u32 = 65536;
pub const MPU_RASR_SRD_Pos: u32 = 8;
pub const MPU_RASR_SRD_Msk: u32 = 65280;
pub const MPU_RASR_SIZE_Pos: u32 = 1;
pub const MPU_RASR_SIZE_Msk: u32 = 62;
pub const MPU_RASR_ENABLE_Pos: u32 = 0;
pub const MPU_RASR_ENABLE_Msk: u32 = 1;
pub const FPU_FPCCR_ASPEN_Pos: u32 = 31;
pub const FPU_FPCCR_ASPEN_Msk: u32 = 2147483648;
pub const FPU_FPCCR_LSPEN_Pos: u32 = 30;
pub const FPU_FPCCR_LSPEN_Msk: u32 = 1073741824;
pub const FPU_FPCCR_MONRDY_Pos: u32 = 8;
pub const FPU_FPCCR_MONRDY_Msk: u32 = 256;
pub const FPU_FPCCR_BFRDY_Pos: u32 = 6;
pub const FPU_FPCCR_BFRDY_Msk: u32 = 64;
pub const FPU_FPCCR_MMRDY_Pos: u32 = 5;
pub const FPU_FPCCR_MMRDY_Msk: u32 = 32;
pub const FPU_FPCCR_HFRDY_Pos: u32 = 4;
pub const FPU_FPCCR_HFRDY_Msk: u32 = 16;
pub const FPU_FPCCR_THREAD_Pos: u32 = 3;
pub const FPU_FPCCR_THREAD_Msk: u32 = 8;
pub const FPU_FPCCR_USER_Pos: u32 = 1;
pub const FPU_FPCCR_USER_Msk: u32 = 2;
pub const FPU_FPCCR_LSPACT_Pos: u32 = 0;
pub const FPU_FPCCR_LSPACT_Msk: u32 = 1;
pub const FPU_FPCAR_ADDRESS_Pos: u32 = 3;
pub const FPU_FPCAR_ADDRESS_Msk: u32 = 4294967288;
pub const FPU_FPDSCR_AHP_Pos: u32 = 26;
pub const FPU_FPDSCR_AHP_Msk: u32 = 67108864;
pub const FPU_FPDSCR_DN_Pos: u32 = 25;
pub const FPU_FPDSCR_DN_Msk: u32 = 33554432;
pub const FPU_FPDSCR_FZ_Pos: u32 = 24;
pub const FPU_FPDSCR_FZ_Msk: u32 = 16777216;
pub const FPU_FPDSCR_RMode_Pos: u32 = 22;
pub const FPU_FPDSCR_RMode_Msk: u32 = 12582912;
pub const FPU_MVFR0_FP_rounding_modes_Pos: u32 = 28;
pub const FPU_MVFR0_FP_rounding_modes_Msk: u32 = 4026531840;
pub const FPU_MVFR0_Short_vectors_Pos: u32 = 24;
pub const FPU_MVFR0_Short_vectors_Msk: u32 = 251658240;
pub const FPU_MVFR0_Square_root_Pos: u32 = 20;
pub const FPU_MVFR0_Square_root_Msk: u32 = 15728640;
pub const FPU_MVFR0_Divide_Pos: u32 = 16;
pub const FPU_MVFR0_Divide_Msk: u32 = 983040;
pub const FPU_MVFR0_FP_excep_trapping_Pos: u32 = 12;
pub const FPU_MVFR0_FP_excep_trapping_Msk: u32 = 61440;
pub const FPU_MVFR0_Double_precision_Pos: u32 = 8;
pub const FPU_MVFR0_Double_precision_Msk: u32 = 3840;
pub const FPU_MVFR0_Single_precision_Pos: u32 = 4;
pub const FPU_MVFR0_Single_precision_Msk: u32 = 240;
pub const FPU_MVFR0_A_SIMD_registers_Pos: u32 = 0;
pub const FPU_MVFR0_A_SIMD_registers_Msk: u32 = 15;
pub const FPU_MVFR1_FP_fused_MAC_Pos: u32 = 28;
pub const FPU_MVFR1_FP_fused_MAC_Msk: u32 = 4026531840;
pub const FPU_MVFR1_FP_HPFP_Pos: u32 = 24;
pub const FPU_MVFR1_FP_HPFP_Msk: u32 = 251658240;
pub const FPU_MVFR1_D_NaN_mode_Pos: u32 = 4;
pub const FPU_MVFR1_D_NaN_mode_Msk: u32 = 240;
pub const FPU_MVFR1_FtZ_mode_Pos: u32 = 0;
pub const FPU_MVFR1_FtZ_mode_Msk: u32 = 15;
pub const FPU_MVFR2_VFP_Misc_Pos: u32 = 4;
pub const FPU_MVFR2_VFP_Misc_Msk: u32 = 240;
pub const CoreDebug_DHCSR_DBGKEY_Pos: u32 = 16;
pub const CoreDebug_DHCSR_DBGKEY_Msk: u32 = 4294901760;
pub const CoreDebug_DHCSR_S_RESET_ST_Pos: u32 = 25;
pub const CoreDebug_DHCSR_S_RESET_ST_Msk: u32 = 33554432;
pub const CoreDebug_DHCSR_S_RETIRE_ST_Pos: u32 = 24;
pub const CoreDebug_DHCSR_S_RETIRE_ST_Msk: u32 = 16777216;
pub const CoreDebug_DHCSR_S_LOCKUP_Pos: u32 = 19;
pub const CoreDebug_DHCSR_S_LOCKUP_Msk: u32 = 524288;
pub const CoreDebug_DHCSR_S_SLEEP_Pos: u32 = 18;
pub const CoreDebug_DHCSR_S_SLEEP_Msk: u32 = 262144;
pub const CoreDebug_DHCSR_S_HALT_Pos: u32 = 17;
pub const CoreDebug_DHCSR_S_HALT_Msk: u32 = 131072;
pub const CoreDebug_DHCSR_S_REGRDY_Pos: u32 = 16;
pub const CoreDebug_DHCSR_S_REGRDY_Msk: u32 = 65536;
pub const CoreDebug_DHCSR_C_SNAPSTALL_Pos: u32 = 5;
pub const CoreDebug_DHCSR_C_SNAPSTALL_Msk: u32 = 32;
pub const CoreDebug_DHCSR_C_MASKINTS_Pos: u32 = 3;
pub const CoreDebug_DHCSR_C_MASKINTS_Msk: u32 = 8;
pub const CoreDebug_DHCSR_C_STEP_Pos: u32 = 2;
pub const CoreDebug_DHCSR_C_STEP_Msk: u32 = 4;
pub const CoreDebug_DHCSR_C_HALT_Pos: u32 = 1;
pub const CoreDebug_DHCSR_C_HALT_Msk: u32 = 2;
pub const CoreDebug_DHCSR_C_DEBUGEN_Pos: u32 = 0;
pub const CoreDebug_DHCSR_C_DEBUGEN_Msk: u32 = 1;
pub const CoreDebug_DCRSR_REGWnR_Pos: u32 = 16;
pub const CoreDebug_DCRSR_REGWnR_Msk: u32 = 65536;
pub const CoreDebug_DCRSR_REGSEL_Pos: u32 = 0;
pub const CoreDebug_DCRSR_REGSEL_Msk: u32 = 31;
pub const CoreDebug_DEMCR_TRCENA_Pos: u32 = 24;
pub const CoreDebug_DEMCR_TRCENA_Msk: u32 = 16777216;
pub const CoreDebug_DEMCR_MON_REQ_Pos: u32 = 19;
pub const CoreDebug_DEMCR_MON_REQ_Msk: u32 = 524288;
pub const CoreDebug_DEMCR_MON_STEP_Pos: u32 = 18;
pub const CoreDebug_DEMCR_MON_STEP_Msk: u32 = 262144;
pub const CoreDebug_DEMCR_MON_PEND_Pos: u32 = 17;
pub const CoreDebug_DEMCR_MON_PEND_Msk: u32 = 131072;
pub const CoreDebug_DEMCR_MON_EN_Pos: u32 = 16;
pub const CoreDebug_DEMCR_MON_EN_Msk: u32 = 65536;
pub const CoreDebug_DEMCR_VC_HARDERR_Pos: u32 = 10;
pub const CoreDebug_DEMCR_VC_HARDERR_Msk: u32 = 1024;
pub const CoreDebug_DEMCR_VC_INTERR_Pos: u32 = 9;
pub const CoreDebug_DEMCR_VC_INTERR_Msk: u32 = 512;
pub const CoreDebug_DEMCR_VC_BUSERR_Pos: u32 = 8;
pub const CoreDebug_DEMCR_VC_BUSERR_Msk: u32 = 256;
pub const CoreDebug_DEMCR_VC_STATERR_Pos: u32 = 7;
pub const CoreDebug_DEMCR_VC_STATERR_Msk: u32 = 128;
pub const CoreDebug_DEMCR_VC_CHKERR_Pos: u32 = 6;
pub const CoreDebug_DEMCR_VC_CHKERR_Msk: u32 = 64;
pub const CoreDebug_DEMCR_VC_NOCPERR_Pos: u32 = 5;
pub const CoreDebug_DEMCR_VC_NOCPERR_Msk: u32 = 32;
pub const CoreDebug_DEMCR_VC_MMERR_Pos: u32 = 4;
pub const CoreDebug_DEMCR_VC_MMERR_Msk: u32 = 16;
pub const CoreDebug_DEMCR_VC_CORERESET_Pos: u32 = 0;
pub const CoreDebug_DEMCR_VC_CORERESET_Msk: u32 = 1;
pub const SCS_BASE: u32 = 3758153728;
pub const ITM_BASE: u32 = 3758096384;
pub const DWT_BASE: u32 = 3758100480;
pub const TPI_BASE: u32 = 3758358528;
pub const CoreDebug_BASE: u32 = 3758157296;
pub const SysTick_BASE: u32 = 3758153744;
pub const NVIC_BASE: u32 = 3758153984;
pub const SCB_BASE: u32 = 3758157056;
pub const MPU_BASE: u32 = 3758157200;
pub const FPU_BASE: u32 = 3758157616;
pub const NVIC_USER_IRQ_OFFSET: u32 = 16;
pub const EXC_RETURN_HANDLER: u32 = 4294967281;
pub const EXC_RETURN_THREAD_MSP: u32 = 4294967289;
pub const EXC_RETURN_THREAD_PSP: u32 = 4294967293;
pub const EXC_RETURN_HANDLER_FPU: u32 = 4294967265;
pub const EXC_RETURN_THREAD_MSP_FPU: u32 = 4294967273;
pub const EXC_RETURN_THREAD_PSP_FPU: u32 = 4294967277;
pub const ARM_MPU_AP_NONE: u32 = 0;
pub const ARM_MPU_AP_PRIV: u32 = 1;
pub const ARM_MPU_AP_URO: u32 = 2;
pub const ARM_MPU_AP_FULL: u32 = 3;
pub const ARM_MPU_AP_PRO: u32 = 5;
pub const ARM_MPU_AP_RO: u32 = 6;
pub const ARM_MPU_CACHEP_NOCACHE: u32 = 0;
pub const ARM_MPU_CACHEP_WB_WRA: u32 = 1;
pub const ARM_MPU_CACHEP_WT_NWA: u32 = 2;
pub const ARM_MPU_CACHEP_WB_NWA: u32 = 3;
pub const EXTCLK_FREQ: u32 = 75000000;
pub const INRO_FREQ: u32 = 30000;
pub const IPO_FREQ: u32 = 100000000;
pub const ISO_FREQ: u32 = 60000000;
pub const IBRO_FREQ: u32 = 7372800;
pub const ERTCO_FREQ: u32 = 32768;
pub const HIRC_FREQ: u32 = 100000000;
pub const MXC_ROM_MEM_BASE: u32 = 0;
pub const MXC_ROM_MEM_SIZE: u32 = 131072;
pub const MXC_FLASH0_MEM_BASE: u32 = 268435456;
pub const MXC_FLASH_MEM_BASE: u32 = 268435456;
pub const MXC_FLASH_PAGE_SIZE: u32 = 8192;
pub const MXC_FLASH_MEM_SIZE: u32 = 524288;
pub const MXC_INFO0_MEM_BASE: u32 = 276824064;
pub const MXC_INFO_MEM_BASE: u32 = 276824064;
pub const MXC_INFO_MEM_SIZE: u32 = 16384;
pub const MXC_SRAM_MEM_BASE: u32 = 536870912;
pub const MXC_SRAM_MEM_SIZE: u32 = 131072;
pub const MXC_CFG_WDT_INSTANCES: u32 = 2;
pub const MXC_CFG_GPIO_INSTANCES: u32 = 4;
pub const MXC_CFG_GPIO_PINS_PORT: u32 = 32;
pub const MXC_CFG_TMR_INSTANCES: u32 = 6;
pub const MXC_I2C_INSTANCES: u32 = 3;
pub const MXC_I2C_FIFO_DEPTH: u32 = 8;
pub const MXC_DMA_CHANNELS: u32 = 16;
pub const MXC_DMA_INSTANCES: u32 = 1;
pub const MXC_FLC_INSTANCES: u32 = 1;
pub const MXC_ICC_INSTANCES: u32 = 2;
pub const MXC_ADC_MAX_CLOCK: u32 = 8000000;
pub const MXC_CFG_PT_INSTANCES: u32 = 4;
pub const MXC_CFG_SEMA_INSTANCES: u32 = 8;
pub const MXC_UART_INSTANCES: u32 = 4;
pub const MXC_UART_FIFO_DEPTH: u32 = 8;
pub const MXC_SPI_INSTANCES: u32 = 2;
pub const MXC_SPI_SS_INSTANCES: u32 = 4;
pub const MXC_SPI_FIFO_DEPTH: u32 = 32;
pub const MXC_F_GCR_SYSCTRL_BSTAPEN_POS: u32 = 1;
pub const MXC_F_GCR_SYSCTRL_FLASH_PAGE_FLIP_POS: u32 = 4;
pub const MXC_F_GCR_SYSCTRL_ICC0_FLUSH_POS: u32 = 6;
pub const MXC_F_GCR_SYSCTRL_ROMDONE_POS: u32 = 12;
pub const MXC_F_GCR_SYSCTRL_CCHK_POS: u32 = 13;
pub const MXC_F_GCR_SYSCTRL_SWD_DIS_POS: u32 = 14;
pub const MXC_F_GCR_SYSCTRL_CHKRES_POS: u32 = 15;
pub const MXC_F_GCR_SYSCTRL_OVR_POS: u32 = 16;
pub const MXC_F_GCR_RST0_DMA_POS: u32 = 0;
pub const MXC_F_GCR_RST0_WDT0_POS: u32 = 1;
pub const MXC_F_GCR_RST0_GPIO0_POS: u32 = 2;
pub const MXC_F_GCR_RST0_GPIO1_POS: u32 = 3;
pub const MXC_F_GCR_RST0_TMR0_POS: u32 = 5;
pub const MXC_F_GCR_RST0_TMR1_POS: u32 = 6;
pub const MXC_F_GCR_RST0_TMR2_POS: u32 = 7;
pub const MXC_F_GCR_RST0_TMR3_POS: u32 = 8;
pub const MXC_F_GCR_RST0_UART0_POS: u32 = 11;
pub const MXC_F_GCR_RST0_UART1_POS: u32 = 12;
pub const MXC_F_GCR_RST0_SPI1_POS: u32 = 13;
pub const MXC_F_GCR_RST0_I2C0_POS: u32 = 16;
pub const MXC_F_GCR_RST0_RTC_POS: u32 = 17;
pub const MXC_F_GCR_RST0_SMPHR_POS: u32 = 22;
pub const MXC_F_GCR_RST0_TRNG_POS: u32 = 24;
pub const MXC_F_GCR_RST0_CNN_POS: u32 = 25;
pub const MXC_F_GCR_RST0_ADC_POS: u32 = 26;
pub const MXC_F_GCR_RST0_UART2_POS: u32 = 28;
pub const MXC_F_GCR_RST0_SOFT_POS: u32 = 29;
pub const MXC_F_GCR_RST0_PERIPH_POS: u32 = 30;
pub const MXC_F_GCR_RST0_SYS_POS: u32 = 31;
pub const MXC_F_GCR_CLKCTRL_SYSCLK_DIV_POS: u32 = 6;
pub const MXC_F_GCR_CLKCTRL_SYSCLK_SEL_POS: u32 = 9;
pub const MXC_F_GCR_CLKCTRL_SYSCLK_RDY_POS: u32 = 13;
pub const MXC_F_GCR_CLKCTRL_ERTCO_EN_POS: u32 = 17;
pub const MXC_F_GCR_CLKCTRL_ISO_EN_POS: u32 = 18;
pub const MXC_F_GCR_CLKCTRL_IPO_EN_POS: u32 = 19;
pub const MXC_F_GCR_CLKCTRL_IBRO_EN_POS: u32 = 20;
pub const MXC_F_GCR_CLKCTRL_IBRO_VS_POS: u32 = 21;
pub const MXC_F_GCR_CLKCTRL_ERTCO_RDY_POS: u32 = 25;
pub const MXC_F_GCR_CLKCTRL_ISO_RDY_POS: u32 = 26;
pub const MXC_F_GCR_CLKCTRL_IPO_RDY_POS: u32 = 27;
pub const MXC_F_GCR_CLKCTRL_IBRO_RDY_POS: u32 = 28;
pub const MXC_F_GCR_CLKCTRL_INRO_RDY_POS: u32 = 29;
pub const MXC_F_GCR_PM_MODE_POS: u32 = 0;
pub const MXC_F_GCR_PM_GPIO_WE_POS: u32 = 4;
pub const MXC_F_GCR_PM_RTC_WE_POS: u32 = 5;
pub const MXC_F_GCR_PM_WUT_WE_POS: u32 = 7;
pub const MXC_F_GCR_PM_AINCOMP_WE_POS: u32 = 9;
pub const MXC_F_GCR_PM_ISO_PD_POS: u32 = 15;
pub const MXC_F_GCR_PM_IPO_PD_POS: u32 = 16;
pub const MXC_F_GCR_PM_IBRO_PD_POS: u32 = 17;
pub const MXC_F_GCR_PCLKDIV_ADCFRQ_POS: u32 = 10;
pub const MXC_F_GCR_PCLKDIV_CNNCLKDIV_POS: u32 = 14;
pub const MXC_F_GCR_PCLKDIV_CNNCLKSEL_POS: u32 = 17;
pub const MXC_F_GCR_PCLKDIS0_GPIO0_POS: u32 = 0;
pub const MXC_F_GCR_PCLKDIS0_GPIO1_POS: u32 = 1;
pub const MXC_F_GCR_PCLKDIS0_DMA_POS: u32 = 5;
pub const MXC_F_GCR_PCLKDIS0_SPI1_POS: u32 = 6;
pub const MXC_F_GCR_PCLKDIS0_UART0_POS: u32 = 9;
pub const MXC_F_GCR_PCLKDIS0_UART1_POS: u32 = 10;
pub const MXC_F_GCR_PCLKDIS0_I2C0_POS: u32 = 13;
pub const MXC_F_GCR_PCLKDIS0_TMR0_POS: u32 = 15;
pub const MXC_F_GCR_PCLKDIS0_TMR1_POS: u32 = 16;
pub const MXC_F_GCR_PCLKDIS0_TMR2_POS: u32 = 17;
pub const MXC_F_GCR_PCLKDIS0_TMR3_POS: u32 = 18;
pub const MXC_F_GCR_PCLKDIS0_ADC_POS: u32 = 23;
pub const MXC_F_GCR_PCLKDIS0_CNN_POS: u32 = 25;
pub const MXC_F_GCR_PCLKDIS0_I2C1_POS: u32 = 28;
pub const MXC_F_GCR_PCLKDIS0_PT_POS: u32 = 29;
pub const MXC_F_GCR_MEMCTRL_FWS_POS: u32 = 0;
pub const MXC_F_GCR_MEMCTRL_SYSRAM0ECC_POS: u32 = 16;
pub const MXC_F_GCR_MEMZ_RAM0_POS: u32 = 0;
pub const MXC_F_GCR_MEMZ_RAM1_POS: u32 = 1;
pub const MXC_F_GCR_MEMZ_RAM2_POS: u32 = 2;
pub const MXC_F_GCR_MEMZ_RAM3_POS: u32 = 3;
pub const MXC_F_GCR_MEMZ_SYSRAM0ECC_POS: u32 = 4;
pub const MXC_F_GCR_MEMZ_ICC0_POS: u32 = 5;
pub const MXC_F_GCR_MEMZ_ICC1_POS: u32 = 6;
pub const MXC_F_GCR_SYSST_ICELOCK_POS: u32 = 0;
pub const MXC_F_GCR_RST1_I2C1_POS: u32 = 0;
pub const MXC_F_GCR_RST1_PT_POS: u32 = 1;
pub const MXC_F_GCR_RST1_OWM_POS: u32 = 7;
pub const MXC_F_GCR_RST1_CRC_POS: u32 = 9;
pub const MXC_F_GCR_RST1_AES_POS: u32 = 10;
pub const MXC_F_GCR_RST1_SPI0_POS: u32 = 11;
pub const MXC_F_GCR_RST1_SMPHR_POS: u32 = 16;
pub const MXC_F_GCR_RST1_I2S_POS: u32 = 19;
pub const MXC_F_GCR_RST1_I2C2_POS: u32 = 20;
pub const MXC_F_GCR_RST1_DVS_POS: u32 = 24;
pub const MXC_F_GCR_RST1_SIMO_POS: u32 = 25;
pub const MXC_F_GCR_RST1_CPU1_POS: u32 = 31;
pub const MXC_F_GCR_PCLKDIS1_UART2_POS: u32 = 1;
pub const MXC_F_GCR_PCLKDIS1_TRNG_POS: u32 = 2;
pub const MXC_F_GCR_PCLKDIS1_SMPHR_POS: u32 = 9;
pub const MXC_F_GCR_PCLKDIS1_OWM_POS: u32 = 13;
pub const MXC_F_GCR_PCLKDIS1_CRC_POS: u32 = 14;
pub const MXC_F_GCR_PCLKDIS1_AES_POS: u32 = 15;
pub const MXC_F_GCR_PCLKDIS1_SPI0_POS: u32 = 16;
pub const MXC_F_GCR_PCLKDIS1_PCIF_POS: u32 = 18;
pub const MXC_F_GCR_PCLKDIS1_I2S_POS: u32 = 23;
pub const MXC_F_GCR_PCLKDIS1_I2C2_POS: u32 = 24;
pub const MXC_F_GCR_PCLKDIS1_WDT0_POS: u32 = 27;
pub const MXC_F_GCR_PCLKDIS1_CPU1_POS: u32 = 31;
pub const MXC_F_GCR_EVENTEN_DMA_POS: u32 = 0;
pub const MXC_F_GCR_EVENTEN_RX_POS: u32 = 1;
pub const MXC_F_GCR_EVENTEN_TX_POS: u32 = 2;
pub const MXC_F_GCR_REVISION_REVISION_POS: u32 = 0;
pub const MXC_F_GCR_SYSIE_ICEUNLOCK_POS: u32 = 0;
pub const MXC_F_GCR_ECCERR_RAM_POS: u32 = 0;
pub const MXC_F_GCR_ECCCED_RAM_POS: u32 = 0;
pub const MXC_F_GCR_ECCIE_RAM_POS: u32 = 0;
pub const MXC_F_GCR_ECCADDR_ECCERRAD_POS: u32 = 0;
pub const MXC_S_GCR_PCLKDIV_CNNCLKSEL_PCLK: u32 = 0;
pub const MXC_F_BIT_0: u32 = 1;
pub const MXC_F_BIT_1: u32 = 2;
pub const MXC_F_BIT_2: u32 = 4;
pub const MXC_F_BIT_3: u32 = 8;
pub const MXC_F_BIT_4: u32 = 16;
pub const MXC_F_BIT_5: u32 = 32;
pub const MXC_F_BIT_6: u32 = 64;
pub const MXC_F_BIT_7: u32 = 128;
pub const MXC_F_BIT_8: u32 = 256;
pub const MXC_F_BIT_9: u32 = 512;
pub const MXC_F_BIT_10: u32 = 1024;
pub const MXC_F_BIT_11: u32 = 2048;
pub const MXC_F_BIT_12: u32 = 4096;
pub const MXC_F_BIT_13: u32 = 8192;
pub const MXC_F_BIT_14: u32 = 16384;
pub const MXC_F_BIT_15: u32 = 32768;
pub const MXC_F_BIT_16: u32 = 65536;
pub const MXC_F_BIT_17: u32 = 131072;
pub const MXC_F_BIT_18: u32 = 262144;
pub const MXC_F_BIT_19: u32 = 524288;
pub const MXC_F_BIT_20: u32 = 1048576;
pub const MXC_F_BIT_21: u32 = 2097152;
pub const MXC_F_BIT_22: u32 = 4194304;
pub const MXC_F_BIT_23: u32 = 8388608;
pub const MXC_F_BIT_24: u32 = 16777216;
pub const MXC_F_BIT_25: u32 = 33554432;
pub const MXC_F_BIT_26: u32 = 67108864;
pub const MXC_F_BIT_27: u32 = 134217728;
pub const MXC_F_BIT_28: u32 = 268435456;
pub const MXC_F_BIT_29: u32 = 536870912;
pub const MXC_F_BIT_30: u32 = 1073741824;
pub const MXC_F_BIT_31: u32 = 2147483648;
pub const SCB_CPACR_CP10_Pos: u32 = 20;
pub const SCB_CPACR_CP10_Msk: u32 = 3145728;
pub const SCB_CPACR_CP11_Pos: u32 = 22;
pub const SCB_CPACR_CP11_Msk: u32 = 12582912;
pub const E_NO_ERROR: u32 = 0;
pub const E_SUCCESS: u32 = 0;
pub const E_NULL_PTR: i32 = -1;
pub const E_NO_DEVICE: i32 = -2;
pub const E_BAD_PARAM: i32 = -3;
pub const E_INVALID: i32 = -4;
pub const E_UNINITIALIZED: i32 = -5;
pub const E_BUSY: i32 = -6;
pub const E_BAD_STATE: i32 = -7;
pub const E_UNKNOWN: i32 = -8;
pub const E_COMM_ERR: i32 = -9;
pub const E_TIME_OUT: i32 = -10;
pub const E_NO_RESPONSE: i32 = -11;
pub const E_OVERFLOW: i32 = -12;
pub const E_UNDERFLOW: i32 = -13;
pub const E_NONE_AVAIL: i32 = -14;
pub const E_SHUTDOWN: i32 = -15;
pub const E_ABORT: i32 = -16;
pub const E_NOT_SUPPORTED: i32 = -17;
pub const E_FAIL: i32 = -255;
pub const MXC_TMR_REV: u32 = 0;
pub const MXC_UART_REV: u32 = 0;
pub const MXC_F_LPGCR_RST_GPIO2_POS: u32 = 0;
pub const MXC_F_LPGCR_RST_WDT1_POS: u32 = 1;
pub const MXC_F_LPGCR_RST_TMR4_POS: u32 = 2;
pub const MXC_F_LPGCR_RST_TMR5_POS: u32 = 3;
pub const MXC_F_LPGCR_RST_UART3_POS: u32 = 4;
pub const MXC_F_LPGCR_RST_LPCOMP_POS: u32 = 6;
pub const MXC_F_LPGCR_PCLKDIS_GPIO2_POS: u32 = 0;
pub const MXC_F_LPGCR_PCLKDIS_WDT1_POS: u32 = 1;
pub const MXC_F_LPGCR_PCLKDIS_TMR4_POS: u32 = 2;
pub const MXC_F_LPGCR_PCLKDIS_TMR5_POS: u32 = 3;
pub const MXC_F_LPGCR_PCLKDIS_UART3_POS: u32 = 4;
pub const MXC_F_LPGCR_PCLKDIS_LPCOMP_POS: u32 = 6;
pub const MXC_SYS_USN_CHECKSUM_LEN: u32 = 16;
pub const MXC_SYS_USN_CSUM_FIELD_LEN: u32 = 2;
pub const MXC_SYS_USN_LEN: u32 = 13;
pub const DISPLAY_WIDTH: u32 = 320;
pub const DISPLAY_HEIGHT: u32 = 240;
pub const TFT_SPI_FREQ: u32 = 25000000;
pub const BLACK: u32 = 0;
pub const NAVY: u32 = 15;
pub const DARK_GREEN: u32 = 992;
pub const DARK_CYAN: u32 = 1007;
pub const MAROON: u32 = 30720;
pub const PURPLE: u32 = 30735;
pub const OLIVE: u32 = 31712;
pub const LIGTH_GREY: u32 = 50712;
pub const DARK_GREY: u32 = 31727;
pub const BLUE: u32 = 31;
pub const GREEN: u32 = 2016;
pub const CYAN: u32 = 2047;
pub const RED: u32 = 63488;
pub const MAGENTA: u32 = 63519;
pub const YELLOW: u32 = 65504;
pub const WHITE: u32 = 65535;
pub const ORANGE: u32 = 64800;
pub const GREEN_YELLOW: u32 = 45029;
pub const TS_MAX_BUTTONS: u32 = 16;
pub const TS_INVALID_KEY_CODE: i32 = -1;
pub const LED_OFF: u32 = 0;
pub const LED_ON: u32 = 1;
pub const LED1: u32 = 0;
pub const LED2: u32 = 1;
pub const CONSOLE_UART: u32 = 0;
pub const CONSOLE_BAUD: u32 = 115200;
pub const LED_RED: u32 = 0;
pub const LED_GREEN: u32 = 1;
pub const LED3: u32 = 2;
pub const LED_BLUE: u32 = 2;
pub const POWER_OFF: u32 = 0;
pub const POWER_ON: u32 = 1;
pub const MXC_F_FLC_ADDR_ADDR_POS: u32 = 0;
pub const MXC_F_FLC_CLKDIV_CLKDIV_POS: u32 = 0;
pub const MXC_F_FLC_CTRL_WR_POS: u32 = 0;
pub const MXC_F_FLC_CTRL_ME_POS: u32 = 1;
pub const MXC_F_FLC_CTRL_PGE_POS: u32 = 2;
pub const MXC_F_FLC_CTRL_ERASE_CODE_POS: u32 = 8;
pub const MXC_F_FLC_CTRL_PEND_POS: u32 = 24;
pub const MXC_F_FLC_CTRL_LVE_POS: u32 = 25;
pub const MXC_F_FLC_CTRL_UNLOCK_POS: u32 = 28;
pub const MXC_F_FLC_INTR_DONE_POS: u32 = 0;
pub const MXC_F_FLC_INTR_AF_POS: u32 = 1;
pub const MXC_F_FLC_INTR_DONEIE_POS: u32 = 8;
pub const MXC_F_FLC_INTR_AFIE_POS: u32 = 9;
pub const MXC_F_FLC_ECCDATA_EVEN_POS: u32 = 0;
pub const MXC_F_FLC_ECCDATA_ODD_POS: u32 = 16;
pub const MXC_F_FLC_DATA_DATA_POS: u32 = 0;
pub const MXC_F_FLC_ACTRL_ACTRL_POS: u32 = 0;
pub const MXC_F_FLC_WELR0_WELR0_POS: u32 = 0;
pub const MXC_F_FLC_WELR1_WELR1_POS: u32 = 0;
pub const MXC_F_FLC_RLR0_RLR0_POS: u32 = 0;
pub const MXC_F_FLC_RLR1_RLR1_POS: u32 = 0;
pub const MXC_FLASH_PAGE_MASK: i32 = -8192;
pub const MXC_F_I2C_CTRL_EN_POS: u32 = 0;
pub const MXC_F_I2C_CTRL_MST_MODE_POS: u32 = 1;
pub const MXC_F_I2C_CTRL_GC_ADDR_EN_POS: u32 = 2;
pub const MXC_F_I2C_CTRL_IRXM_EN_POS: u32 = 3;
pub const MXC_F_I2C_CTRL_IRXM_ACK_POS: u32 = 4;
pub const MXC_F_I2C_CTRL_SCL_OUT_POS: u32 = 6;
pub const MXC_F_I2C_CTRL_SDA_OUT_POS: u32 = 7;
pub const MXC_F_I2C_CTRL_SCL_POS: u32 = 8;
pub const MXC_F_I2C_CTRL_SDA_POS: u32 = 9;
pub const MXC_F_I2C_CTRL_BB_MODE_POS: u32 = 10;
pub const MXC_F_I2C_CTRL_READ_POS: u32 = 11;
pub const MXC_F_I2C_CTRL_CLKSTR_DIS_POS: u32 = 12;
pub const MXC_F_I2C_CTRL_ONE_MST_MODE_POS: u32 = 13;
pub const MXC_F_I2C_CTRL_HS_EN_POS: u32 = 15;
pub const MXC_F_I2C_STATUS_BUSY_POS: u32 = 0;
pub const MXC_F_I2C_STATUS_RX_EM_POS: u32 = 1;
pub const MXC_F_I2C_STATUS_RX_FULL_POS: u32 = 2;
pub const MXC_F_I2C_STATUS_TX_EM_POS: u32 = 3;
pub const MXC_F_I2C_STATUS_TX_FULL_POS: u32 = 4;
pub const MXC_F_I2C_STATUS_MST_BUSY_POS: u32 = 5;
pub const MXC_F_I2C_INTFL0_DONE_POS: u32 = 0;
pub const MXC_F_I2C_INTFL0_IRXM_POS: u32 = 1;
pub const MXC_F_I2C_INTFL0_GC_ADDR_MATCH_POS: u32 = 2;
pub const MXC_F_I2C_INTFL0_ADDR_MATCH_POS: u32 = 3;
pub const MXC_F_I2C_INTFL0_RX_THD_POS: u32 = 4;
pub const MXC_F_I2C_INTFL0_TX_THD_POS: u32 = 5;
pub const MXC_F_I2C_INTFL0_STOP_POS: u32 = 6;
pub const MXC_F_I2C_INTFL0_ADDR_ACK_POS: u32 = 7;
pub const MXC_F_I2C_INTFL0_ARB_ERR_POS: u32 = 8;
pub const MXC_F_I2C_INTFL0_TO_ERR_POS: u32 = 9;
pub const MXC_F_I2C_INTFL0_ADDR_NACK_ERR_POS: u32 = 10;
pub const MXC_F_I2C_INTFL0_DATA_ERR_POS: u32 = 11;
pub const MXC_F_I2C_INTFL0_DNR_ERR_POS: u32 = 12;
pub const MXC_F_I2C_INTFL0_START_ERR_POS: u32 = 13;
pub const MXC_F_I2C_INTFL0_STOP_ERR_POS: u32 = 14;
pub const MXC_F_I2C_INTFL0_TX_LOCKOUT_POS: u32 = 15;
pub const MXC_F_I2C_INTFL0_MAMI_POS: u32 = 16;
pub const MXC_F_I2C_INTFL0_RD_ADDR_MATCH_POS: u32 = 22;
pub const MXC_F_I2C_INTFL0_WR_ADDR_MATCH_POS: u32 = 23;
pub const MXC_F_I2C_INTEN0_DONE_POS: u32 = 0;
pub const MXC_F_I2C_INTEN0_IRXM_POS: u32 = 1;
pub const MXC_F_I2C_INTEN0_GC_ADDR_MATCH_POS: u32 = 2;
pub const MXC_F_I2C_INTEN0_ADDR_MATCH_POS: u32 = 3;
pub const MXC_F_I2C_INTEN0_RX_THD_POS: u32 = 4;
pub const MXC_F_I2C_INTEN0_TX_THD_POS: u32 = 5;
pub const MXC_F_I2C_INTEN0_STOP_POS: u32 = 6;
pub const MXC_F_I2C_INTEN0_ADDR_ACK_POS: u32 = 7;
pub const MXC_F_I2C_INTEN0_ARB_ERR_POS: u32 = 8;
pub const MXC_F_I2C_INTEN0_TO_ERR_POS: u32 = 9;
pub const MXC_F_I2C_INTEN0_ADDR_NACK_ERR_POS: u32 = 10;
pub const MXC_F_I2C_INTEN0_DATA_ERR_POS: u32 = 11;
pub const MXC_F_I2C_INTEN0_DNR_ERR_POS: u32 = 12;
pub const MXC_F_I2C_INTEN0_START_ERR_POS: u32 = 13;
pub const MXC_F_I2C_INTEN0_STOP_ERR_POS: u32 = 14;
pub const MXC_F_I2C_INTEN0_TX_LOCKOUT_POS: u32 = 15;
pub const MXC_F_I2C_INTEN0_MAMI_POS: u32 = 16;
pub const MXC_F_I2C_INTEN0_RD_ADDR_MATCH_POS: u32 = 22;
pub const MXC_F_I2C_INTEN0_WR_ADDR_MATCH_POS: u32 = 23;
pub const MXC_F_I2C_INTFL1_RX_OV_POS: u32 = 0;
pub const MXC_F_I2C_INTFL1_TX_UN_POS: u32 = 1;
pub const MXC_F_I2C_INTFL1_START_POS: u32 = 2;
pub const MXC_F_I2C_INTEN1_RX_OV_POS: u32 = 0;
pub const MXC_F_I2C_INTEN1_TX_UN_POS: u32 = 1;
pub const MXC_F_I2C_INTEN1_START_POS: u32 = 2;
pub const MXC_F_I2C_FIFOLEN_RX_DEPTH_POS: u32 = 0;
pub const MXC_F_I2C_FIFOLEN_TX_DEPTH_POS: u32 = 8;
pub const MXC_F_I2C_RXCTRL0_DNR_POS: u32 = 0;
pub const MXC_F_I2C_RXCTRL0_FLUSH_POS: u32 = 7;
pub const MXC_F_I2C_RXCTRL0_THD_LVL_POS: u32 = 8;
pub const MXC_F_I2C_RXCTRL1_CNT_POS: u32 = 0;
pub const MXC_F_I2C_RXCTRL1_LVL_POS: u32 = 8;
pub const MXC_F_I2C_TXCTRL0_PRELOAD_MODE_POS: u32 = 0;
pub const MXC_F_I2C_TXCTRL0_TX_READY_MODE_POS: u32 = 1;
pub const MXC_F_I2C_TXCTRL0_GC_ADDR_FLUSH_DIS_POS: u32 = 2;
pub const MXC_F_I2C_TXCTRL0_WR_ADDR_FLUSH_DIS_POS: u32 = 3;
pub const MXC_F_I2C_TXCTRL0_RD_ADDR_FLUSH_DIS_POS: u32 = 4;
pub const MXC_F_I2C_TXCTRL0_NACK_FLUSH_DIS_POS: u32 = 5;
pub const MXC_F_I2C_TXCTRL0_FLUSH_POS: u32 = 7;
pub const MXC_F_I2C_TXCTRL0_THD_VAL_POS: u32 = 8;
pub const MXC_F_I2C_TXCTRL1_PRELOAD_RDY_POS: u32 = 0;
pub const MXC_F_I2C_TXCTRL1_LVL_POS: u32 = 8;
pub const MXC_F_I2C_FIFO_DATA_POS: u32 = 0;
pub const MXC_F_I2C_MSTCTRL_START_POS: u32 = 0;
pub const MXC_F_I2C_MSTCTRL_RESTART_POS: u32 = 1;
pub const MXC_F_I2C_MSTCTRL_STOP_POS: u32 = 2;
pub const MXC_F_I2C_MSTCTRL_EX_ADDR_EN_POS: u32 = 7;
pub const MXC_F_I2C_CLKLO_LO_POS: u32 = 0;
pub const MXC_F_I2C_CLKHI_HI_POS: u32 = 0;
pub const MXC_F_I2C_HSCLK_LO_POS: u32 = 0;
pub const MXC_F_I2C_HSCLK_HI_POS: u32 = 8;
pub const MXC_F_I2C_TIMEOUT_SCL_TO_VAL_POS: u32 = 0;
pub const MXC_F_I2C_DMA_TX_EN_POS: u32 = 0;
pub const MXC_F_I2C_DMA_RX_EN_POS: u32 = 1;
pub const MXC_F_I2C_SLAVE_MULTI_ADDR_POS: u32 = 0;
pub const MXC_F_I2C_SLAVE_MULTI_DIS_POS: u32 = 10;
pub const MXC_F_I2C_SLAVE_MULTI_EXT_ADDR_EN_POS: u32 = 15;
pub const MXC_F_ICC_INFO_RELNUM_POS: u32 = 0;
pub const MXC_F_ICC_INFO_PARTNUM_POS: u32 = 6;
pub const MXC_F_ICC_INFO_ID_POS: u32 = 10;
pub const MXC_F_ICC_SZ_CCH_POS: u32 = 0;
pub const MXC_F_ICC_SZ_MEM_POS: u32 = 16;
pub const MXC_F_ICC_CTRL_EN_POS: u32 = 0;
pub const MXC_F_ICC_CTRL_RDY_POS: u32 = 16;
pub const MXC_F_ICC_INVALIDATE_INVALID_POS: u32 = 0;
pub const MXC_F_TRNG_CTRL_RND_IE_POS: u32 = 1;
pub const MXC_F_TRNG_CTRL_KEYGEN_POS: u32 = 3;
pub const MXC_F_TRNG_CTRL_KEYWIPE_POS: u32 = 15;
pub const MXC_F_TRNG_STATUS_RDY_POS: u32 = 0;
pub const MXC_F_TRNG_DATA_DATA_POS: u32 = 0;
pub const MXC_F_UART_CTRL_RX_THD_VAL_POS: u32 = 0;
pub const MXC_F_UART_CTRL_PAR_EN_POS: u32 = 4;
pub const MXC_F_UART_CTRL_PAR_EO_POS: u32 = 5;
pub const MXC_F_UART_CTRL_PAR_MD_POS: u32 = 6;
pub const MXC_F_UART_CTRL_CTS_DIS_POS: u32 = 7;
pub const MXC_F_UART_CTRL_TX_FLUSH_POS: u32 = 8;
pub const MXC_F_UART_CTRL_RX_FLUSH_POS: u32 = 9;
pub const MXC_F_UART_CTRL_CHAR_SIZE_POS: u32 = 10;
pub const MXC_F_UART_CTRL_STOPBITS_POS: u32 = 12;
pub const MXC_F_UART_CTRL_HFC_EN_POS: u32 = 13;
pub const MXC_F_UART_CTRL_RTSDC_POS: u32 = 14;
pub const MXC_F_UART_CTRL_BCLKEN_POS: u32 = 15;
pub const MXC_F_UART_CTRL_BCLKSRC_POS: u32 = 16;
pub const MXC_F_UART_CTRL_DPFE_EN_POS: u32 = 18;
pub const MXC_F_UART_CTRL_BCLKRDY_POS: u32 = 19;
pub const MXC_F_UART_CTRL_UCAGM_POS: u32 = 20;
pub const MXC_F_UART_CTRL_FDM_POS: u32 = 21;
pub const MXC_F_UART_CTRL_DESM_POS: u32 = 22;
pub const MXC_F_UART_STATUS_TX_BUSY_POS: u32 = 0;
pub const MXC_F_UART_STATUS_RX_BUSY_POS: u32 = 1;
pub const MXC_F_UART_STATUS_RX_EM_POS: u32 = 4;
pub const MXC_F_UART_STATUS_RX_FULL_POS: u32 = 5;
pub const MXC_F_UART_STATUS_TX_EM_POS: u32 = 6;
pub const MXC_F_UART_STATUS_TX_FULL_POS: u32 = 7;
pub const MXC_F_UART_STATUS_RX_LVL_POS: u32 = 8;
pub const MXC_F_UART_STATUS_TX_LVL_POS: u32 = 12;
pub const MXC_F_UART_INT_EN_RX_FERR_POS: u32 = 0;
pub const MXC_F_UART_INT_EN_RX_PAR_POS: u32 = 1;
pub const MXC_F_UART_INT_EN_CTS_EV_POS: u32 = 2;
pub const MXC_F_UART_INT_EN_RX_OV_POS: u32 = 3;
pub const MXC_F_UART_INT_EN_RX_THD_POS: u32 = 4;
pub const MXC_F_UART_INT_EN_TX_OB_POS: u32 = 5;
pub const MXC_F_UART_INT_EN_TX_HE_POS: u32 = 6;
pub const MXC_F_UART_INT_FL_RX_FERR_POS: u32 = 0;
pub const MXC_F_UART_INT_FL_RX_PAR_POS: u32 = 1;
pub const MXC_F_UART_INT_FL_CTS_EV_POS: u32 = 2;
pub const MXC_F_UART_INT_FL_RX_OV_POS: u32 = 3;
pub const MXC_F_UART_INT_FL_RX_THD_POS: u32 = 4;
pub const MXC_F_UART_INT_FL_TX_OB_POS: u32 = 5;
pub const MXC_F_UART_INT_FL_TX_HE_POS: u32 = 6;
pub const MXC_F_UART_CLKDIV_CLKDIV_POS: u32 = 0;
pub const MXC_F_UART_OSR_OSR_POS: u32 = 0;
pub const MXC_F_UART_TXPEEK_DATA_POS: u32 = 0;
pub const MXC_F_UART_PNR_CTS_POS: u32 = 0;
pub const MXC_F_UART_PNR_RTS_POS: u32 = 1;
pub const MXC_F_UART_FIFO_DATA_POS: u32 = 0;
pub const MXC_F_UART_FIFO_RX_PAR_POS: u32 = 8;
pub const MXC_F_UART_DMA_TX_THD_VAL_POS: u32 = 0;
pub const MXC_F_UART_DMA_TX_EN_POS: u32 = 4;
pub const MXC_F_UART_DMA_RX_THD_VAL_POS: u32 = 5;
pub const MXC_F_UART_DMA_RX_EN_POS: u32 = 9;
pub const MXC_F_UART_WKEN_RX_NE_POS: u32 = 0;
pub const MXC_F_UART_WKEN_RX_FULL_POS: u32 = 1;
pub const MXC_F_UART_WKEN_RX_THD_POS: u32 = 2;
pub const MXC_F_UART_WKFL_RX_NE_POS: u32 = 0;
pub const MXC_F_UART_WKFL_RX_FULL_POS: u32 = 1;
pub const MXC_F_UART_WKFL_RX_THD_POS: u32 = 2;
pub const UART_EXTCLK_FREQ: u32 = 75000000;
pub const MXC_F_WDT_CTRL_INT_LATE_VAL_POS: u32 = 0;
pub const MXC_F_WDT_CTRL_RST_LATE_VAL_POS: u32 = 4;
pub const MXC_F_WDT_CTRL_EN_POS: u32 = 8;
pub const MXC_F_WDT_CTRL_INT_LATE_POS: u32 = 9;
pub const MXC_F_WDT_CTRL_WDT_INT_EN_POS: u32 = 10;
pub const MXC_F_WDT_CTRL_WDT_RST_EN_POS: u32 = 11;
pub const MXC_F_WDT_CTRL_INT_EARLY_POS: u32 = 12;
pub const MXC_F_WDT_CTRL_INT_EARLY_VAL_POS: u32 = 16;
pub const MXC_F_WDT_CTRL_RST_EARLY_VAL_POS: u32 = 20;
pub const MXC_F_WDT_CTRL_CLKRDY_IE_POS: u32 = 27;
pub const MXC_F_WDT_CTRL_CLKRDY_POS: u32 = 28;
pub const MXC_F_WDT_CTRL_WIN_EN_POS: u32 = 29;
pub const MXC_F_WDT_CTRL_RST_EARLY_POS: u32 = 30;
pub const MXC_F_WDT_CTRL_RST_LATE_POS: u32 = 31;
pub const MXC_F_WDT_RST_RESET_POS: u32 = 0;
pub const MXC_F_WDT_CLKSEL_SOURCE_POS: u32 = 0;
pub const MXC_F_WDT_CNT_COUNT_POS: u32 = 0;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_longlong;
pub type __uint64_t = ::core::ffi::c_ulonglong;
pub type __int_least8_t = ::core::ffi::c_schar;
pub type __uint_least8_t = ::core::ffi::c_uchar;
pub type __int_least16_t = ::core::ffi::c_short;
pub type __uint_least16_t = ::core::ffi::c_ushort;
pub type __int_least32_t = ::core::ffi::c_int;
pub type __uint_least32_t = ::core::ffi::c_uint;
pub type __int_least64_t = ::core::ffi::c_longlong;
pub type __uint_least64_t = ::core::ffi::c_ulonglong;
pub type __intmax_t = ::core::ffi::c_longlong;
pub type __uintmax_t = ::core::ffi::c_ulonglong;
pub type __intptr_t = ::core::ffi::c_int;
pub type __uintptr_t = ::core::ffi::c_uint;
pub type wchar_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::core::ffi::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::core::mem::MaybeUninit<max_align_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        16usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        8usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __gnuc_va_list = u32;
pub type va_list = __gnuc_va_list;
pub type wint_t = ::core::ffi::c_int;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blksize_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
pub type __dev_t = ::core::ffi::c_short;
pub type __uid_t = ::core::ffi::c_ushort;
pub type __gid_t = ::core::ffi::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = ::core::ffi::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = ::core::ffi::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = ::core::ffi::c_long;
pub type _fpos_t = ::core::ffi::c_long;
pub type __size_t = ::core::ffi::c_uint;
pub type _ssize_t = ::core::ffi::c_int;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: ::core::ffi::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [::core::ffi::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout__mbstate_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_mbstate_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout__mbstate_t() {
    const UNINIT: ::core::mem::MaybeUninit<_mbstate_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(_mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
pub type _iconv_t = *mut ::core::ffi::c_void;
pub type __clock_t = ::core::ffi::c_ulong;
pub type __time_t = __int_least64_t;
pub type __clockid_t = ::core::ffi::c_ulong;
pub type __daddr_t = ::core::ffi::c_long;
pub type __timer_t = ::core::ffi::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = ::core::ffi::c_int;
pub type __nlink_t = ::core::ffi::c_ushort;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_ulong;
pub type __va_list = u32;
pub type __ULong = ::core::ffi::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lock {
    _unused: [u8; 0],
}
pub type _LOCK_T = *mut __lock;
extern "C" {
    pub fn __retarget_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_init_recursive(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_try_acquire(lock: _LOCK_T) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __retarget_lock_try_acquire_recursive(lock: _LOCK_T) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __retarget_lock_release(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_release_recursive(lock: _LOCK_T);
}
pub type _flock_t = _LOCK_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: ::core::ffi::c_int,
    pub _maxwds: ::core::ffi::c_int,
    pub _sign: ::core::ffi::c_int,
    pub _wds: ::core::ffi::c_int,
    pub _x: [__ULong; 1usize],
}
#[test]
fn bindgen_test_layout__Bigint() {
    const UNINIT: ::core::mem::MaybeUninit<_Bigint> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_Bigint>(),
        24usize,
        concat!("Size of: ", stringify!(_Bigint))
    );
    assert_eq!(
        ::core::mem::align_of::<_Bigint>(),
        4usize,
        concat!("Alignment of ", stringify!(_Bigint))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._k) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_k)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._maxwds) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_maxwds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._sign) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_sign)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wds) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_wds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._x) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: ::core::ffi::c_int,
    pub __tm_min: ::core::ffi::c_int,
    pub __tm_hour: ::core::ffi::c_int,
    pub __tm_mday: ::core::ffi::c_int,
    pub __tm_mon: ::core::ffi::c_int,
    pub __tm_year: ::core::ffi::c_int,
    pub __tm_wday: ::core::ffi::c_int,
    pub __tm_yday: ::core::ffi::c_int,
    pub __tm_isdst: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___tm() {
    const UNINIT: ::core::mem::MaybeUninit<__tm> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__tm>(),
        36usize,
        concat!("Size of: ", stringify!(__tm))
    );
    assert_eq!(
        ::core::mem::align_of::<__tm>(),
        4usize,
        concat!("Alignment of ", stringify!(__tm))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_year)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_isdst)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut ::core::ffi::c_void; 32usize],
    pub _dso_handle: [*mut ::core::ffi::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[test]
fn bindgen_test_layout__on_exit_args() {
    const UNINIT: ::core::mem::MaybeUninit<_on_exit_args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_on_exit_args>(),
        264usize,
        concat!("Size of: ", stringify!(_on_exit_args))
    );
    assert_eq!(
        ::core::mem::align_of::<_on_exit_args>(),
        4usize,
        concat!("Alignment of ", stringify!(_on_exit_args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._fnargs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_fnargs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._dso_handle) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_dso_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._fntypes) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_fntypes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._is_cxa) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_is_cxa)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: ::core::ffi::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
#[test]
fn bindgen_test_layout__atexit() {
    const UNINIT: ::core::mem::MaybeUninit<_atexit> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_atexit>(),
        400usize,
        concat!("Size of: ", stringify!(_atexit))
    );
    assert_eq!(
        ::core::mem::align_of::<_atexit>(),
        4usize,
        concat!("Alignment of ", stringify!(_atexit))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ind) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_ind)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._fns) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_fns)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._on_exit_args) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_on_exit_args)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::core::ffi::c_uchar,
    pub _size: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    const UNINIT: ::core::mem::MaybeUninit<__sbuf> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__sbuf>(),
        8usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::core::mem::align_of::<__sbuf>(),
        4usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::core::ffi::c_uchar,
    pub _r: ::core::ffi::c_int,
    pub _w: ::core::ffi::c_int,
    pub _flags: ::core::ffi::c_short,
    pub _file: ::core::ffi::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::core::ffi::c_int,
    pub _cookie: *mut ::core::ffi::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: *mut ::core::ffi::c_char,
            arg4: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: *const ::core::ffi::c_char,
            arg4: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
            arg3: _fpos_t,
            arg4: ::core::ffi::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::core::ffi::c_void,
        ) -> ::core::ffi::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut ::core::ffi::c_uchar,
    pub _ur: ::core::ffi::c_int,
    pub _ubuf: [::core::ffi::c_uchar; 3usize],
    pub _nbuf: [::core::ffi::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::core::ffi::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout___sFILE() {
    const UNINIT: ::core::mem::MaybeUninit<__sFILE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__sFILE>(),
        104usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::core::mem::align_of::<__sFILE>(),
        4usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._r) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._w) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._file) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._bf) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lbfsize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._cookie) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._read) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._write) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._seek) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._close) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ub) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._up) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_up)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ur) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ubuf) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._nbuf) as usize - ptr as usize },
        67usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lb) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._blksize) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._data) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbstate) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_mbstate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags2)
        )
    );
}
pub type __FILE = __sFILE;
extern "C" {
    pub static mut __sf: [__FILE; 3usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: ::core::ffi::c_int,
    pub _iobs: *mut __FILE,
}
#[test]
fn bindgen_test_layout__glue() {
    const UNINIT: ::core::mem::MaybeUninit<_glue> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_glue>(),
        12usize,
        concat!("Size of: ", stringify!(_glue))
    );
    assert_eq!(
        ::core::mem::align_of::<_glue>(),
        4usize,
        concat!("Alignment of ", stringify!(_glue))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._niobs) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_niobs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._iobs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_iobs)
        )
    );
}
extern "C" {
    pub static mut __sglue: _glue;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [::core::ffi::c_ushort; 3usize],
    pub _mult: [::core::ffi::c_ushort; 3usize],
    pub _add: ::core::ffi::c_ushort,
}
#[test]
fn bindgen_test_layout__rand48() {
    const UNINIT: ::core::mem::MaybeUninit<_rand48> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_rand48>(),
        14usize,
        concat!("Size of: ", stringify!(_rand48))
    );
    assert_eq!(
        ::core::mem::align_of::<_rand48>(),
        2usize,
        concat!("Alignment of ", stringify!(_rand48))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._seed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_seed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mult) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_mult)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._add) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_add)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: ::core::ffi::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: ::core::ffi::c_int,
    pub _emergency: [::core::ffi::c_char; 25usize],
    pub _locale: *mut __locale_t,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: ::core::ffi::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: ::core::ffi::c_int,
    pub _cvtbuf: *mut ::core::ffi::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: ::core::ffi::c_int)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _reent__bindgen_ty_1 {
    pub _reent: _reent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _strtok_last: *mut ::core::ffi::c_char,
    pub _asctime_buf: [::core::ffi::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: ::core::ffi::c_int,
    pub _rand_next: ::core::ffi::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [::core::ffi::c_char; 8usize],
    pub _signal_buf: [::core::ffi::c_char; 24usize],
    pub _getdate_err: ::core::ffi::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_reent__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_1>(),
        200usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._strtok_last) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_strtok_last)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._asctime_buf) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_asctime_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._localtime_buf) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_localtime_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._gamma_signgam) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_gamma_signgam)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._rand_next) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_rand_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._r48) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_r48)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mblen_state) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mblen_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbtowc_state) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbtowc_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wctomb_state) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wctomb_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._l64a_buf) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_l64a_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._signal_buf) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_signal_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._getdate_err) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_getdate_err)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbrlen_state) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbrlen_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbrtowc_state) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbrtowc_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbsrtowcs_state) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbsrtowcs_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wcrtomb_state) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wcrtomb_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wcsrtombs_state) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wcsrtombs_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._h_errno) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_h_errno)
        )
    );
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_reent__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1>(),
        200usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_reent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._reent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1),
            "::",
            stringify!(_reent)
        )
    );
}
#[test]
fn bindgen_test_layout__reent() {
    const UNINIT: ::core::mem::MaybeUninit<_reent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_reent>(),
        288usize,
        concat!("Size of: ", stringify!(_reent))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent>(),
        8usize,
        concat!("Alignment of ", stringify!(_reent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._errno) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_errno)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._stdin) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stdin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._stdout) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stdout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._stderr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stderr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._inc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_inc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._emergency) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_emergency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._locale) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_locale)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__cleanup) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__cleanup)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._result) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_result)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._result_k) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_result_k)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._p5s) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_p5s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._freelist) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_freelist)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._cvtlen) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_cvtlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._cvtbuf) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_cvtbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._new) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_new)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._sig_func) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_sig_func)
        )
    );
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static mut _impure_data: _reent;
}
extern "C" {
    pub static mut __atexit: *mut _atexit;
}
extern "C" {
    pub static mut __atexit0: _atexit;
}
extern "C" {
    pub static mut __stdio_exit_handler: ::core::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
extern "C" {
    pub fn _fwalk_sglue(
        arg1: *mut _reent,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut __FILE) -> ::core::ffi::c_int,
        >,
        arg3: *mut _glue,
    ) -> ::core::ffi::c_int;
}
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
pub type off_t = __off_t;
extern "C" {
    pub fn ctermid(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn tempnam(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::core::ffi::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fprintf(arg1: *mut FILE, arg2: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fscanf(arg1: *mut FILE, arg2: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn printf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn scanf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::core::ffi::c_char,
        arg3: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const ::core::ffi::c_char, arg2: u32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::core::ffi::c_char,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn fputc(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::core::ffi::c_char, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getchar() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn putc(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ungetc(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fread(
        arg1: *mut ::core::ffi::c_void,
        _size: ::core::ffi::c_uint,
        _n: ::core::ffi::c_uint,
        arg2: *mut FILE,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn fwrite(
        arg1: *const ::core::ffi::c_void,
        _size: ::core::ffi::c_uint,
        _n: ::core::ffi::c_uint,
        arg2: *mut FILE,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::core::ffi::c_long,
        arg3: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn perror(arg1: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn fopen(_name: *const ::core::ffi::c_char, _type: *const ::core::ffi::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn rename(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fseeko(arg1: *mut FILE, arg2: off_t, arg3: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsnprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: ::core::ffi::c_uint,
        arg3: *const ::core::ffi::c_char,
        arg4: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vfscanf(
        arg1: *mut FILE,
        arg2: *const ::core::ffi::c_char,
        arg3: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vscanf(arg1: *const ::core::ffi::c_char, arg2: u32) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn asiprintf(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn asniprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn asnprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn diprintf(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fiprintf(arg1: *mut FILE, arg2: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fiscanf(arg1: *mut FILE, arg2: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn iprintf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn iscanf(arg1: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn siprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn siscanf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sniprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: usize,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vasiprintf(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vasniprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn vasnprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn vdiprintf(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vfiprintf(
        arg1: *mut FILE,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vfiscanf(
        arg1: *mut FILE,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn viprintf(arg1: *const ::core::ffi::c_char, arg2: __gnuc_va_list) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn viscanf(arg1: *const ::core::ffi::c_char, arg2: __gnuc_va_list) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsiprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsiscanf(
        arg1: *const ::core::ffi::c_char,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsniprintf(
        arg1: *mut ::core::ffi::c_char,
        arg2: usize,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fdopen(arg1: ::core::ffi::c_int, arg2: *const ::core::ffi::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn popen(arg1: *const ::core::ffi::c_char, arg2: *const ::core::ffi::c_char) -> *mut FILE;
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut ::core::ffi::c_char, arg3: ::core::ffi::c_int);
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putw(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn putc_unlocked(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fmemopen(
        arg1: *mut ::core::ffi::c_void,
        arg2: usize,
        arg3: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(arg1: *mut *mut ::core::ffi::c_char, arg2: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn renameat(
        arg1: ::core::ffi::c_int,
        arg2: *const ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _asiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _asniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *mut usize,
        arg4: *const ::core::ffi::c_char,
        ...
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _asnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *mut usize,
        arg4: *const ::core::ffi::c_char,
        ...
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _asprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _diprintf_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _dprintf_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fclose_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fcloseall_r(arg1: *mut _reent) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fdopen_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fflush_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fgetc_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fgetc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fgets_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: *mut FILE,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _fgets_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: ::core::ffi::c_int,
        arg4: *mut FILE,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _fgetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *mut fpos_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fsetpos_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const fpos_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fmemopen_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        arg3: usize,
        arg4: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fopen_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _freopen_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fpurge_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fputc_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fputc_unlocked_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fputs_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fputs_unlocked_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fread_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fread_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fseek_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: ::core::ffi::c_long,
        arg4: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _fseeko_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: _off_t,
        arg4: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _ftell_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn _ftello_r(arg1: *mut _reent, arg2: *mut FILE) -> _off_t;
}
extern "C" {
    pub fn _rewind_r(arg1: *mut _reent, arg2: *mut FILE);
}
extern "C" {
    pub fn _fwrite_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fwrite_unlocked_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _getc_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _getc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _getchar_r(arg1: *mut _reent) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _getchar_unlocked_r(arg1: *mut _reent) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _gets_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _iprintf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _iscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _open_memstream_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _perror_r(arg1: *mut _reent, arg2: *const ::core::ffi::c_char);
}
extern "C" {
    pub fn _printf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _putc_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _putc_unlocked_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _putchar_unlocked_r(arg1: *mut _reent, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _putchar_r(arg1: *mut _reent, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _puts_r(arg1: *mut _reent, arg2: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _remove_r(arg1: *mut _reent, arg2: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _rename_r(
        arg1: *mut _reent,
        _old: *const ::core::ffi::c_char,
        _new: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _scanf_r(arg1: *mut _reent, arg2: *const ::core::ffi::c_char, ...)
        -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _siprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _siscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _sniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
        arg4: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _snprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
        arg4: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _sprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _sscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _tempnam_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _tmpfile_r(arg1: *mut _reent) -> *mut FILE;
}
extern "C" {
    pub fn _tmpnam_r(arg1: *mut _reent, arg2: *mut ::core::ffi::c_char)
        -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _ungetc_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vasiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vasniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *mut usize,
        arg4: *const ::core::ffi::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _vasnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *mut usize,
        arg4: *const ::core::ffi::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _vasprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vdiprintf_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vdprintf_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vfiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vfiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vfprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vfscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _viprintf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _viscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vprintf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vsiprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vsiscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vsniprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
        arg4: *const ::core::ffi::c_char,
        arg5: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vsnprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: usize,
        arg4: *const ::core::ffi::c_char,
        arg5: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vsprintf_r(
        arg1: *mut _reent,
        arg2: *mut ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _vsscanf_r(
        arg1: *mut _reent,
        arg2: *const ::core::ffi::c_char,
        arg3: *const ::core::ffi::c_char,
        arg4: __gnuc_va_list,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __getdelim(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: ::core::ffi::c_int,
        arg4: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn __getline(
        arg1: *mut *mut ::core::ffi::c_char,
        arg2: *mut usize,
        arg3: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fflush_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fputc_unlocked(arg1: ::core::ffi::c_int, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        arg1: *mut ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        arg1: *const ::core::ffi::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn __srget_r(arg1: *mut _reent, arg2: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __swbuf_r(
        arg1: *mut _reent,
        arg2: ::core::ffi::c_int,
        arg3: *mut FILE,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn funopen(
        __cookie: *const ::core::ffi::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __buf: *mut ::core::ffi::c_char,
                __n: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __buf: *const ::core::ffi::c_char,
                __n: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __off: fpos_t,
                __whence: ::core::ffi::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _funopen_r(
        arg1: *mut _reent,
        __cookie: *const ::core::ffi::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __buf: *mut ::core::ffi::c_char,
                __n: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __buf: *const ::core::ffi::c_char,
                __n: ::core::ffi::c_int,
            ) -> ::core::ffi::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut ::core::ffi::c_void,
                __off: fpos_t,
                __whence: ::core::ffi::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
        >,
    ) -> *mut FILE;
}
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type int_fast16_t = ::core::ffi::c_short;
pub type uint_fast16_t = ::core::ffi::c_ushort;
pub type int_fast32_t = ::core::ffi::c_int;
pub type uint_fast32_t = ::core::ffi::c_uint;
pub type int_fast64_t = ::core::ffi::c_longlong;
pub type uint_fast64_t = ::core::ffi::c_ulonglong;
#[doc = " @ingroup spi_registers\n Structure type to access the SPI Registers."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mxc_spi_regs_t {
    pub __bindgen_anon_1: mxc_spi_regs_t__bindgen_ty_1,
    #[doc = "< <tt>\\b 0x04:</tt> SPI CTRL0 Register"]
    pub ctrl0: u32,
    #[doc = "< <tt>\\b 0x08:</tt> SPI CTRL1 Register"]
    pub ctrl1: u32,
    #[doc = "< <tt>\\b 0x0C:</tt> SPI CTRL2 Register"]
    pub ctrl2: u32,
    #[doc = "< <tt>\\b 0x10:</tt> SPI SSTIME Register"]
    pub sstime: u32,
    #[doc = "< <tt>\\b 0x14:</tt> SPI CLKCTRL Register"]
    pub clkctrl: u32,
    pub rsv_0x18: u32,
    #[doc = "< <tt>\\b 0x1C:</tt> SPI DMA Register"]
    pub dma: u32,
    #[doc = "< <tt>\\b 0x20:</tt> SPI INTFL Register"]
    pub intfl: u32,
    #[doc = "< <tt>\\b 0x24:</tt> SPI INTEN Register"]
    pub inten: u32,
    #[doc = "< <tt>\\b 0x28:</tt> SPI WKFL Register"]
    pub wkfl: u32,
    #[doc = "< <tt>\\b 0x2C:</tt> SPI WKEN Register"]
    pub wken: u32,
    #[doc = "< <tt>\\b 0x30:</tt> SPI STAT Register"]
    pub stat: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mxc_spi_regs_t__bindgen_ty_1 {
    #[doc = "< <tt>\\b 0x00:</tt> SPI FIFO32 Register"]
    pub fifo32: u32,
    #[doc = "< <tt>\\b 0x00:</tt> SPI FIFO16 Register"]
    pub fifo16: [u16; 2usize],
    #[doc = "< <tt>\\b 0x00:</tt> SPI FIFO8 Register"]
    pub fifo8: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_mxc_spi_regs_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<mxc_spi_regs_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mxc_spi_regs_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(mxc_spi_regs_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<mxc_spi_regs_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(mxc_spi_regs_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fifo32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_spi_regs_t__bindgen_ty_1),
            "::",
            stringify!(fifo32)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fifo16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_spi_regs_t__bindgen_ty_1),
            "::",
            stringify!(fifo16)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fifo8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_spi_regs_t__bindgen_ty_1),
            "::",
            stringify!(fifo8)
        )
    );
}
#[test]
fn bindgen_test_layout_mxc_spi_regs_t() {
    const UNINIT: ::core::mem::MaybeUninit<mxc_spi_regs_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mxc_spi_regs_t>(),
        52usize,
        concat!("Size of: ", stringify!(mxc_spi_regs_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mxc_spi_regs_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mxc_spi_regs_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctrl0) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_spi_regs_t),
            "::",
            stringify!(ctrl0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctrl1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_spi_regs_t),
            "::",
            stringify!(ctrl1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctrl2) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_spi_regs_t),
            "::",
            stringify!(ctrl2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sstime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_spi_regs_t),
            "::",
            stringify!(sstime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clkctrl) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_spi_regs_t),
            "::",
            stringify!(clkctrl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsv_0x18) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_spi_regs_t),
            "::",
            stringify!(rsv_0x18)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dma) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_spi_regs_t),
            "::",
            stringify!(dma)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).intfl) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_spi_regs_t),
            "::",
            stringify!(intfl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inten) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_spi_regs_t),
            "::",
            stringify!(inten)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wkfl) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_spi_regs_t),
            "::",
            stringify!(wkfl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wken) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_spi_regs_t),
            "::",
            stringify!(wken)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stat) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_spi_regs_t),
            "::",
            stringify!(stat)
        )
    );
}
#[doc = " @ingroup gpio_registers\n Structure type to access the GPIO Registers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mxc_gpio_regs_t {
    #[doc = "< <tt>\\b 0x00:</tt> GPIO EN0 Register"]
    pub en0: u32,
    #[doc = "< <tt>\\b 0x04:</tt> GPIO EN0_SET Register"]
    pub en0_set: u32,
    #[doc = "< <tt>\\b 0x08:</tt> GPIO EN0_CLR Register"]
    pub en0_clr: u32,
    #[doc = "< <tt>\\b 0x0C:</tt> GPIO OUTEN Register"]
    pub outen: u32,
    #[doc = "< <tt>\\b 0x10:</tt> GPIO OUTEN_SET Register"]
    pub outen_set: u32,
    #[doc = "< <tt>\\b 0x14:</tt> GPIO OUTEN_CLR Register"]
    pub outen_clr: u32,
    #[doc = "< <tt>\\b 0x18:</tt> GPIO OUT Register"]
    pub out: u32,
    #[doc = "< <tt>\\b 0x1C:</tt> GPIO OUT_SET Register"]
    pub out_set: u32,
    #[doc = "< <tt>\\b 0x20:</tt> GPIO OUT_CLR Register"]
    pub out_clr: u32,
    #[doc = "< <tt>\\b 0x24:</tt> GPIO IN Register"]
    pub in_: u32,
    #[doc = "< <tt>\\b 0x28:</tt> GPIO INTMODE Register"]
    pub intmode: u32,
    #[doc = "< <tt>\\b 0x2C:</tt> GPIO INTPOL Register"]
    pub intpol: u32,
    #[doc = "< <tt>\\b 0x30:</tt> GPIO INEN Register"]
    pub inen: u32,
    #[doc = "< <tt>\\b 0x34:</tt> GPIO INTEN Register"]
    pub inten: u32,
    #[doc = "< <tt>\\b 0x38:</tt> GPIO INTEN_SET Register"]
    pub inten_set: u32,
    #[doc = "< <tt>\\b 0x3C:</tt> GPIO INTEN_CLR Register"]
    pub inten_clr: u32,
    #[doc = "< <tt>\\b 0x40:</tt> GPIO INTFL Register"]
    pub intfl: u32,
    pub rsv_0x44: u32,
    #[doc = "< <tt>\\b 0x48:</tt> GPIO INTFL_CLR Register"]
    pub intfl_clr: u32,
    #[doc = "< <tt>\\b 0x4C:</tt> GPIO WKEN Register"]
    pub wken: u32,
    #[doc = "< <tt>\\b 0x50:</tt> GPIO WKEN_SET Register"]
    pub wken_set: u32,
    #[doc = "< <tt>\\b 0x54:</tt> GPIO WKEN_CLR Register"]
    pub wken_clr: u32,
    pub rsv_0x58: u32,
    #[doc = "< <tt>\\b 0x5C:</tt> GPIO DUALEDGE Register"]
    pub dualedge: u32,
    #[doc = "< <tt>\\b 0x60:</tt> GPIO PADCTRL0 Register"]
    pub padctrl0: u32,
    #[doc = "< <tt>\\b 0x64:</tt> GPIO PADCTRL1 Register"]
    pub padctrl1: u32,
    #[doc = "< <tt>\\b 0x68:</tt> GPIO EN1 Register"]
    pub en1: u32,
    #[doc = "< <tt>\\b 0x6C:</tt> GPIO EN1_SET Register"]
    pub en1_set: u32,
    #[doc = "< <tt>\\b 0x70:</tt> GPIO EN1_CLR Register"]
    pub en1_clr: u32,
    #[doc = "< <tt>\\b 0x74:</tt> GPIO EN2 Register"]
    pub en2: u32,
    #[doc = "< <tt>\\b 0x78:</tt> GPIO EN2_SET Register"]
    pub en2_set: u32,
    #[doc = "< <tt>\\b 0x7C:</tt> GPIO EN2_CLR Register"]
    pub en2_clr: u32,
    pub rsv_0x80_0xa7: [u32; 10usize],
    #[doc = "< <tt>\\b 0xA8:</tt> GPIO HYSEN Register"]
    pub hysen: u32,
    #[doc = "< <tt>\\b 0xAC:</tt> GPIO SRSEL Register"]
    pub srsel: u32,
    #[doc = "< <tt>\\b 0xB0:</tt> GPIO DS0 Register"]
    pub ds0: u32,
    #[doc = "< <tt>\\b 0xB4:</tt> GPIO DS1 Register"]
    pub ds1: u32,
    #[doc = "< <tt>\\b 0xB8:</tt> GPIO PS Register"]
    pub ps: u32,
    pub rsv_0xbc: u32,
    #[doc = "< <tt>\\b 0xC0:</tt> GPIO VSSEL Register"]
    pub vssel: u32,
}
#[test]
fn bindgen_test_layout_mxc_gpio_regs_t() {
    const UNINIT: ::core::mem::MaybeUninit<mxc_gpio_regs_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mxc_gpio_regs_t>(),
        196usize,
        concat!("Size of: ", stringify!(mxc_gpio_regs_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mxc_gpio_regs_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mxc_gpio_regs_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).en0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(en0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).en0_set) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(en0_set)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).en0_clr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(en0_clr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).outen) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(outen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).outen_set) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(outen_set)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).outen_clr) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(outen_clr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).out) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(out)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).out_set) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(out_set)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).out_clr) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(out_clr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).in_) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(in_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).intmode) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(intmode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).intpol) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(intpol)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inen) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(inen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inten) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(inten)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inten_set) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(inten_set)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inten_clr) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(inten_clr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).intfl) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(intfl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsv_0x44) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(rsv_0x44)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).intfl_clr) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(intfl_clr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wken) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(wken)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wken_set) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(wken_set)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wken_clr) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(wken_clr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsv_0x58) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(rsv_0x58)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dualedge) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(dualedge)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padctrl0) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(padctrl0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padctrl1) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(padctrl1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).en1) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(en1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).en1_set) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(en1_set)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).en1_clr) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(en1_clr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).en2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(en2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).en2_set) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(en2_set)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).en2_clr) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(en2_clr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsv_0x80_0xa7) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(rsv_0x80_0xa7)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hysen) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(hysen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).srsel) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(srsel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ds0) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(ds0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ds1) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(ds1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ps) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(ps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsv_0xbc) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(rsv_0xbc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vssel) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_regs_t),
            "::",
            stringify!(vssel)
        )
    );
}
pub const IRQn_Type_NonMaskableInt_IRQn: IRQn_Type = -14;
pub const IRQn_Type_HardFault_IRQn: IRQn_Type = -13;
pub const IRQn_Type_MemoryManagement_IRQn: IRQn_Type = -12;
pub const IRQn_Type_BusFault_IRQn: IRQn_Type = -11;
pub const IRQn_Type_UsageFault_IRQn: IRQn_Type = -10;
pub const IRQn_Type_SVCall_IRQn: IRQn_Type = -5;
pub const IRQn_Type_DebugMonitor_IRQn: IRQn_Type = -4;
pub const IRQn_Type_PendSV_IRQn: IRQn_Type = -2;
pub const IRQn_Type_SysTick_IRQn: IRQn_Type = -1;
pub const IRQn_Type_PF_IRQn: IRQn_Type = 0;
pub const IRQn_Type_WDT0_IRQn: IRQn_Type = 1;
pub const IRQn_Type_RSV02_IRQn: IRQn_Type = 2;
pub const IRQn_Type_RTC_IRQn: IRQn_Type = 3;
pub const IRQn_Type_TRNG_IRQn: IRQn_Type = 4;
pub const IRQn_Type_TMR0_IRQn: IRQn_Type = 5;
pub const IRQn_Type_TMR1_IRQn: IRQn_Type = 6;
pub const IRQn_Type_TMR2_IRQn: IRQn_Type = 7;
pub const IRQn_Type_TMR3_IRQn: IRQn_Type = 8;
pub const IRQn_Type_TMR4_IRQn: IRQn_Type = 9;
pub const IRQn_Type_TMR5_IRQn: IRQn_Type = 10;
pub const IRQn_Type_RSV11_IRQn: IRQn_Type = 11;
pub const IRQn_Type_RSV12_IRQn: IRQn_Type = 12;
pub const IRQn_Type_I2C0_IRQn: IRQn_Type = 13;
pub const IRQn_Type_UART0_IRQn: IRQn_Type = 14;
pub const IRQn_Type_UART1_IRQn: IRQn_Type = 15;
pub const IRQn_Type_SPI1_IRQn: IRQn_Type = 16;
pub const IRQn_Type_RSV17_IRQn: IRQn_Type = 17;
pub const IRQn_Type_RSV18_IRQn: IRQn_Type = 18;
pub const IRQn_Type_RSV19_IRQn: IRQn_Type = 19;
pub const IRQn_Type_ADC_IRQn: IRQn_Type = 20;
pub const IRQn_Type_RSV21_IRQn: IRQn_Type = 21;
pub const IRQn_Type_RSV22_IRQn: IRQn_Type = 22;
pub const IRQn_Type_FLC0_IRQn: IRQn_Type = 23;
pub const IRQn_Type_GPIO0_IRQn: IRQn_Type = 24;
pub const IRQn_Type_GPIO1_IRQn: IRQn_Type = 25;
pub const IRQn_Type_GPIO2_IRQn: IRQn_Type = 26;
pub const IRQn_Type_RSV27_IRQn: IRQn_Type = 27;
pub const IRQn_Type_DMA0_IRQn: IRQn_Type = 28;
pub const IRQn_Type_DMA1_IRQn: IRQn_Type = 29;
pub const IRQn_Type_DMA2_IRQn: IRQn_Type = 30;
pub const IRQn_Type_DMA3_IRQn: IRQn_Type = 31;
pub const IRQn_Type_RSV32_IRQn: IRQn_Type = 32;
pub const IRQn_Type_RSV33_IRQn: IRQn_Type = 33;
pub const IRQn_Type_UART2_IRQn: IRQn_Type = 34;
pub const IRQn_Type_RSV35_IRQn: IRQn_Type = 35;
pub const IRQn_Type_I2C1_IRQn: IRQn_Type = 36;
pub const IRQn_Type_RSV37_IRQn: IRQn_Type = 37;
pub const IRQn_Type_RSV38_IRQn: IRQn_Type = 38;
pub const IRQn_Type_RSV39_IRQn: IRQn_Type = 39;
pub const IRQn_Type_RSV40_IRQn: IRQn_Type = 40;
pub const IRQn_Type_RSV41_IRQn: IRQn_Type = 41;
pub const IRQn_Type_RSV42_IRQn: IRQn_Type = 42;
pub const IRQn_Type_RSV43_IRQn: IRQn_Type = 43;
pub const IRQn_Type_RSV44_IRQn: IRQn_Type = 44;
pub const IRQn_Type_RSV45_IRQn: IRQn_Type = 45;
pub const IRQn_Type_RSV46_IRQn: IRQn_Type = 46;
pub const IRQn_Type_RSV47_IRQn: IRQn_Type = 47;
pub const IRQn_Type_RSV48_IRQn: IRQn_Type = 48;
pub const IRQn_Type_RSV49_IRQn: IRQn_Type = 49;
pub const IRQn_Type_RSV50_IRQn: IRQn_Type = 50;
pub const IRQn_Type_RSV51_IRQn: IRQn_Type = 51;
pub const IRQn_Type_RSV52_IRQn: IRQn_Type = 52;
pub const IRQn_Type_WUT_IRQn: IRQn_Type = 53;
pub const IRQn_Type_GPIOWAKE_IRQn: IRQn_Type = 54;
pub const IRQn_Type_RSV55_IRQn: IRQn_Type = 55;
pub const IRQn_Type_SPI0_IRQn: IRQn_Type = 56;
pub const IRQn_Type_WDT1_IRQn: IRQn_Type = 57;
pub const IRQn_Type_RSV58_IRQn: IRQn_Type = 58;
pub const IRQn_Type_PT_IRQn: IRQn_Type = 59;
pub const IRQn_Type_RSV60_IRQn: IRQn_Type = 60;
pub const IRQn_Type_RSV61_IRQn: IRQn_Type = 61;
pub const IRQn_Type_I2C2_IRQn: IRQn_Type = 62;
pub const IRQn_Type_RISCV_IRQn: IRQn_Type = 63;
pub const IRQn_Type_RSV64_IRQn: IRQn_Type = 64;
pub const IRQn_Type_RSV65_IRQn: IRQn_Type = 65;
pub const IRQn_Type_RSV66_IRQn: IRQn_Type = 66;
pub const IRQn_Type_OWM_IRQn: IRQn_Type = 67;
pub const IRQn_Type_RSV68_IRQn: IRQn_Type = 68;
pub const IRQn_Type_RSV69_IRQn: IRQn_Type = 69;
pub const IRQn_Type_RSV70_IRQn: IRQn_Type = 70;
pub const IRQn_Type_RSV71_IRQn: IRQn_Type = 71;
pub const IRQn_Type_RSV72_IRQn: IRQn_Type = 72;
pub const IRQn_Type_RSV73_IRQn: IRQn_Type = 73;
pub const IRQn_Type_RSV74_IRQn: IRQn_Type = 74;
pub const IRQn_Type_RSV75_IRQn: IRQn_Type = 75;
pub const IRQn_Type_RSV76_IRQn: IRQn_Type = 76;
pub const IRQn_Type_RSV77_IRQn: IRQn_Type = 77;
pub const IRQn_Type_RSV78_IRQn: IRQn_Type = 78;
pub const IRQn_Type_RSV79_IRQn: IRQn_Type = 79;
pub const IRQn_Type_RSV80_IRQn: IRQn_Type = 80;
pub const IRQn_Type_RSV81_IRQn: IRQn_Type = 81;
pub const IRQn_Type_ECC_IRQn: IRQn_Type = 82;
pub const IRQn_Type_DVS_IRQn: IRQn_Type = 83;
pub const IRQn_Type_SIMO_IRQn: IRQn_Type = 84;
pub const IRQn_Type_RSV85_IRQn: IRQn_Type = 85;
pub const IRQn_Type_RSV86_IRQn: IRQn_Type = 86;
pub const IRQn_Type_RSV87_IRQn: IRQn_Type = 87;
pub const IRQn_Type_UART3_IRQn: IRQn_Type = 88;
pub const IRQn_Type_RSV89_IRQn: IRQn_Type = 89;
pub const IRQn_Type_RSV90_IRQn: IRQn_Type = 90;
pub const IRQn_Type_PCIF_IRQn: IRQn_Type = 91;
pub const IRQn_Type_RSV92_IRQn: IRQn_Type = 92;
pub const IRQn_Type_RSV93_IRQn: IRQn_Type = 93;
pub const IRQn_Type_RSV94_IRQn: IRQn_Type = 94;
pub const IRQn_Type_RSV95_IRQn: IRQn_Type = 95;
pub const IRQn_Type_RSV96_IRQn: IRQn_Type = 96;
pub const IRQn_Type_AES_IRQn: IRQn_Type = 97;
pub const IRQn_Type_RSV98_IRQn: IRQn_Type = 98;
pub const IRQn_Type_I2S_IRQn: IRQn_Type = 99;
pub const IRQn_Type_CNN_FIFO_IRQn: IRQn_Type = 100;
pub const IRQn_Type_CNN_IRQn: IRQn_Type = 101;
pub const IRQn_Type_RSV102_IRQn: IRQn_Type = 102;
pub const IRQn_Type_LPCMP_IRQn: IRQn_Type = 103;
pub const IRQn_Type_MXC_IRQ_EXT_COUNT: IRQn_Type = 104;
pub type IRQn_Type = ::core::ffi::c_int;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct T_UINT32 {
    pub v: u32,
}
#[test]
fn bindgen_test_layout_T_UINT32() {
    const UNINIT: ::core::mem::MaybeUninit<T_UINT32> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<T_UINT32>(),
        4usize,
        concat!("Size of: ", stringify!(T_UINT32))
    );
    assert_eq!(
        ::core::mem::align_of::<T_UINT32>(),
        1usize,
        concat!("Alignment of ", stringify!(T_UINT32))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(T_UINT32),
            "::",
            stringify!(v)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct T_UINT16_WRITE {
    pub v: u16,
}
#[test]
fn bindgen_test_layout_T_UINT16_WRITE() {
    const UNINIT: ::core::mem::MaybeUninit<T_UINT16_WRITE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<T_UINT16_WRITE>(),
        2usize,
        concat!("Size of: ", stringify!(T_UINT16_WRITE))
    );
    assert_eq!(
        ::core::mem::align_of::<T_UINT16_WRITE>(),
        1usize,
        concat!("Alignment of ", stringify!(T_UINT16_WRITE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(T_UINT16_WRITE),
            "::",
            stringify!(v)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct T_UINT16_READ {
    pub v: u16,
}
#[test]
fn bindgen_test_layout_T_UINT16_READ() {
    const UNINIT: ::core::mem::MaybeUninit<T_UINT16_READ> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<T_UINT16_READ>(),
        2usize,
        concat!("Size of: ", stringify!(T_UINT16_READ))
    );
    assert_eq!(
        ::core::mem::align_of::<T_UINT16_READ>(),
        1usize,
        concat!("Alignment of ", stringify!(T_UINT16_READ))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(T_UINT16_READ),
            "::",
            stringify!(v)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct T_UINT32_WRITE {
    pub v: u32,
}
#[test]
fn bindgen_test_layout_T_UINT32_WRITE() {
    const UNINIT: ::core::mem::MaybeUninit<T_UINT32_WRITE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<T_UINT32_WRITE>(),
        4usize,
        concat!("Size of: ", stringify!(T_UINT32_WRITE))
    );
    assert_eq!(
        ::core::mem::align_of::<T_UINT32_WRITE>(),
        1usize,
        concat!("Alignment of ", stringify!(T_UINT32_WRITE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(T_UINT32_WRITE),
            "::",
            stringify!(v)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct T_UINT32_READ {
    pub v: u32,
}
#[test]
fn bindgen_test_layout_T_UINT32_READ() {
    const UNINIT: ::core::mem::MaybeUninit<T_UINT32_READ> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<T_UINT32_READ>(),
        4usize,
        concat!("Size of: ", stringify!(T_UINT32_READ))
    );
    assert_eq!(
        ::core::mem::align_of::<T_UINT32_READ>(),
        1usize,
        concat!("Alignment of ", stringify!(T_UINT32_READ))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(T_UINT32_READ),
            "::",
            stringify!(v)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union APSR_Type {
    pub b: APSR_Type__bindgen_ty_1,
    pub w: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct APSR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_APSR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<APSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(APSR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<APSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(APSR_Type__bindgen_ty_1))
    );
}
impl APSR_Type__bindgen_ty_1 {
    #[inline]
    pub fn _reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set__reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn GE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_GE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set__reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn Q(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Q(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn V(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_V(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn C(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_C(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Z(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Z(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn N(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_N(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        _reserved0: u32,
        GE: u32,
        _reserved1: u32,
        Q: u32,
        V: u32,
        C: u32,
        Z: u32,
        N: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
            _reserved0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let GE: u32 = unsafe { ::core::mem::transmute(GE) };
            GE as u64
        });
        __bindgen_bitfield_unit.set(20usize, 7u8, {
            let _reserved1: u32 = unsafe { ::core::mem::transmute(_reserved1) };
            _reserved1 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let Q: u32 = unsafe { ::core::mem::transmute(Q) };
            Q as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let V: u32 = unsafe { ::core::mem::transmute(V) };
            V as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let C: u32 = unsafe { ::core::mem::transmute(C) };
            C as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let Z: u32 = unsafe { ::core::mem::transmute(Z) };
            Z as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let N: u32 = unsafe { ::core::mem::transmute(N) };
            N as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_APSR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<APSR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<APSR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(APSR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<APSR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(APSR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(APSR_Type),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(APSR_Type),
            "::",
            stringify!(w)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IPSR_Type {
    pub b: IPSR_Type__bindgen_ty_1,
    pub w: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IPSR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_IPSR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<IPSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(IPSR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<IPSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(IPSR_Type__bindgen_ty_1))
    );
}
impl IPSR_Type__bindgen_ty_1 {
    #[inline]
    pub fn ISR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_ISR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set__reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ISR: u32, _reserved0: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let ISR: u32 = unsafe { ::core::mem::transmute(ISR) };
            ISR as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
            _reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_IPSR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<IPSR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<IPSR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(IPSR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<IPSR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(IPSR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPSR_Type),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPSR_Type),
            "::",
            stringify!(w)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xPSR_Type {
    pub b: xPSR_Type__bindgen_ty_1,
    pub w: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct xPSR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_xPSR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<xPSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(xPSR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<xPSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(xPSR_Type__bindgen_ty_1))
    );
}
impl xPSR_Type__bindgen_ty_1 {
    #[inline]
    pub fn ISR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_ISR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set__reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ICI_IT_1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_ICI_IT_1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn GE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_GE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set__reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn T(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_T(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ICI_IT_2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ICI_IT_2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Q(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Q(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn V(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_V(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn C(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_C(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Z(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Z(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn N(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_N(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ISR: u32,
        _reserved0: u32,
        ICI_IT_1: u32,
        GE: u32,
        _reserved1: u32,
        T: u32,
        ICI_IT_2: u32,
        Q: u32,
        V: u32,
        C: u32,
        Z: u32,
        N: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let ISR: u32 = unsafe { ::core::mem::transmute(ISR) };
            ISR as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
            _reserved0 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let ICI_IT_1: u32 = unsafe { ::core::mem::transmute(ICI_IT_1) };
            ICI_IT_1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let GE: u32 = unsafe { ::core::mem::transmute(GE) };
            GE as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let _reserved1: u32 = unsafe { ::core::mem::transmute(_reserved1) };
            _reserved1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let T: u32 = unsafe { ::core::mem::transmute(T) };
            T as u64
        });
        __bindgen_bitfield_unit.set(25usize, 2u8, {
            let ICI_IT_2: u32 = unsafe { ::core::mem::transmute(ICI_IT_2) };
            ICI_IT_2 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let Q: u32 = unsafe { ::core::mem::transmute(Q) };
            Q as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let V: u32 = unsafe { ::core::mem::transmute(V) };
            V as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let C: u32 = unsafe { ::core::mem::transmute(C) };
            C as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let Z: u32 = unsafe { ::core::mem::transmute(Z) };
            Z as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let N: u32 = unsafe { ::core::mem::transmute(N) };
            N as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_xPSR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<xPSR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<xPSR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(xPSR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<xPSR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(xPSR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xPSR_Type),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xPSR_Type),
            "::",
            stringify!(w)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CONTROL_Type {
    pub b: CONTROL_Type__bindgen_ty_1,
    pub w: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CONTROL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_CONTROL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<CONTROL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(CONTROL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<CONTROL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(CONTROL_Type__bindgen_ty_1))
    );
}
impl CONTROL_Type__bindgen_ty_1 {
    #[inline]
    pub fn nPRIV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nPRIV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SPSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SPSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FPCA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FPCA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set__reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        nPRIV: u32,
        SPSEL: u32,
        FPCA: u32,
        _reserved0: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let nPRIV: u32 = unsafe { ::core::mem::transmute(nPRIV) };
            nPRIV as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SPSEL: u32 = unsafe { ::core::mem::transmute(SPSEL) };
            SPSEL as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let FPCA: u32 = unsafe { ::core::mem::transmute(FPCA) };
            FPCA as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
            _reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_CONTROL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<CONTROL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CONTROL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(CONTROL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<CONTROL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(CONTROL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CONTROL_Type),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CONTROL_Type),
            "::",
            stringify!(w)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NVIC_Type {
    pub ISER: [u32; 8usize],
    pub RESERVED0: [u32; 24usize],
    pub ICER: [u32; 8usize],
    pub RESERVED1: [u32; 24usize],
    pub ISPR: [u32; 8usize],
    pub RESERVED2: [u32; 24usize],
    pub ICPR: [u32; 8usize],
    pub RESERVED3: [u32; 24usize],
    pub IABR: [u32; 8usize],
    pub RESERVED4: [u32; 56usize],
    pub IP: [u8; 240usize],
    pub RESERVED5: [u32; 644usize],
    pub STIR: u32,
}
#[test]
fn bindgen_test_layout_NVIC_Type() {
    const UNINIT: ::core::mem::MaybeUninit<NVIC_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NVIC_Type>(),
        3588usize,
        concat!("Size of: ", stringify!(NVIC_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<NVIC_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(NVIC_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ISER) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(ISER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED0) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ICER) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(ICER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ISPR) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(ISPR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED2) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ICPR) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(ICPR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED3) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IABR) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(IABR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED4) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IP) as usize - ptr as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(IP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED5) as usize - ptr as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).STIR) as usize - ptr as usize },
        3584usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(STIR)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCB_Type {
    pub CPUID: u32,
    pub ICSR: u32,
    pub VTOR: u32,
    pub AIRCR: u32,
    pub SCR: u32,
    pub CCR: u32,
    pub SHP: [u8; 12usize],
    pub SHCSR: u32,
    pub CFSR: u32,
    pub HFSR: u32,
    pub DFSR: u32,
    pub MMFAR: u32,
    pub BFAR: u32,
    pub AFSR: u32,
    pub PFR: [u32; 2usize],
    pub DFR: u32,
    pub ADR: u32,
    pub MMFR: [u32; 4usize],
    pub ISAR: [u32; 5usize],
    pub RESERVED0: [u32; 5usize],
    pub CPACR: u32,
}
#[test]
fn bindgen_test_layout_SCB_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SCB_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SCB_Type>(),
        140usize,
        concat!("Size of: ", stringify!(SCB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SCB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SCB_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CPUID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(CPUID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ICSR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(ICSR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VTOR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(VTOR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AIRCR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(AIRCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SCR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(SCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(CCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SHP) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(SHP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SHCSR) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(SHCSR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CFSR) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(CFSR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HFSR) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(HFSR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DFSR) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(DFSR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MMFAR) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(MMFAR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BFAR) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(BFAR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AFSR) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(AFSR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PFR) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(PFR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DFR) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(DFR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ADR) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(ADR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MMFR) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(MMFR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ISAR) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(ISAR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED0) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(RESERVED0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CPACR) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(CPACR)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCnSCB_Type {
    pub RESERVED0: [u32; 1usize],
    pub ICTR: u32,
    pub ACTLR: u32,
}
#[test]
fn bindgen_test_layout_SCnSCB_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SCnSCB_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SCnSCB_Type>(),
        12usize,
        concat!("Size of: ", stringify!(SCnSCB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SCnSCB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SCnSCB_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SCnSCB_Type),
            "::",
            stringify!(RESERVED0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ICTR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SCnSCB_Type),
            "::",
            stringify!(ICTR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ACTLR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SCnSCB_Type),
            "::",
            stringify!(ACTLR)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysTick_Type {
    pub CTRL: u32,
    pub LOAD: u32,
    pub VAL: u32,
    pub CALIB: u32,
}
#[test]
fn bindgen_test_layout_SysTick_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SysTick_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SysTick_Type>(),
        16usize,
        concat!("Size of: ", stringify!(SysTick_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SysTick_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SysTick_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SysTick_Type),
            "::",
            stringify!(CTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LOAD) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SysTick_Type),
            "::",
            stringify!(LOAD)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VAL) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SysTick_Type),
            "::",
            stringify!(VAL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CALIB) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SysTick_Type),
            "::",
            stringify!(CALIB)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ITM_Type {
    pub PORT: [ITM_Type__bindgen_ty_1; 32usize],
    pub RESERVED0: [u32; 864usize],
    pub TER: u32,
    pub RESERVED1: [u32; 15usize],
    pub TPR: u32,
    pub RESERVED2: [u32; 15usize],
    pub TCR: u32,
    pub RESERVED3: [u32; 32usize],
    pub RESERVED4: [u32; 43usize],
    pub LAR: u32,
    pub LSR: u32,
    pub RESERVED5: [u32; 6usize],
    pub PID4: u32,
    pub PID5: u32,
    pub PID6: u32,
    pub PID7: u32,
    pub PID0: u32,
    pub PID1: u32,
    pub PID2: u32,
    pub PID3: u32,
    pub CID0: u32,
    pub CID1: u32,
    pub CID2: u32,
    pub CID3: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ITM_Type__bindgen_ty_1 {
    pub u8_: u8,
    pub u16_: u16,
    pub u32_: u32,
}
#[test]
fn bindgen_test_layout_ITM_Type__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<ITM_Type__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ITM_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(ITM_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ITM_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ITM_Type__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u8_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type__bindgen_ty_1),
            "::",
            stringify!(u8_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u16_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type__bindgen_ty_1),
            "::",
            stringify!(u16_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type__bindgen_ty_1),
            "::",
            stringify!(u32_)
        )
    );
}
#[test]
fn bindgen_test_layout_ITM_Type() {
    const UNINIT: ::core::mem::MaybeUninit<ITM_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ITM_Type>(),
        4096usize,
        concat!("Size of: ", stringify!(ITM_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ITM_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(ITM_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PORT) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(PORT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED0) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(RESERVED0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TER) as usize - ptr as usize },
        3584usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(TER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize },
        3588usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TPR) as usize - ptr as usize },
        3648usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(TPR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED2) as usize - ptr as usize },
        3652usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TCR) as usize - ptr as usize },
        3712usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(TCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED3) as usize - ptr as usize },
        3716usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(RESERVED3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED4) as usize - ptr as usize },
        3844usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(RESERVED4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LAR) as usize - ptr as usize },
        4016usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(LAR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LSR) as usize - ptr as usize },
        4020usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(LSR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED5) as usize - ptr as usize },
        4024usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(RESERVED5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PID4) as usize - ptr as usize },
        4048usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(PID4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PID5) as usize - ptr as usize },
        4052usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(PID5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PID6) as usize - ptr as usize },
        4056usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(PID6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PID7) as usize - ptr as usize },
        4060usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(PID7)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PID0) as usize - ptr as usize },
        4064usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(PID0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PID1) as usize - ptr as usize },
        4068usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(PID1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PID2) as usize - ptr as usize },
        4072usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(PID2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PID3) as usize - ptr as usize },
        4076usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(PID3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CID0) as usize - ptr as usize },
        4080usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(CID0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CID1) as usize - ptr as usize },
        4084usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(CID1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CID2) as usize - ptr as usize },
        4088usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(CID2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CID3) as usize - ptr as usize },
        4092usize,
        concat!(
            "Offset of field: ",
            stringify!(ITM_Type),
            "::",
            stringify!(CID3)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DWT_Type {
    pub CTRL: u32,
    pub CYCCNT: u32,
    pub CPICNT: u32,
    pub EXCCNT: u32,
    pub SLEEPCNT: u32,
    pub LSUCNT: u32,
    pub FOLDCNT: u32,
    pub PCSR: u32,
    pub COMP0: u32,
    pub MASK0: u32,
    pub FUNCTION0: u32,
    pub RESERVED0: [u32; 1usize],
    pub COMP1: u32,
    pub MASK1: u32,
    pub FUNCTION1: u32,
    pub RESERVED1: [u32; 1usize],
    pub COMP2: u32,
    pub MASK2: u32,
    pub FUNCTION2: u32,
    pub RESERVED2: [u32; 1usize],
    pub COMP3: u32,
    pub MASK3: u32,
    pub FUNCTION3: u32,
}
#[test]
fn bindgen_test_layout_DWT_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DWT_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DWT_Type>(),
        92usize,
        concat!("Size of: ", stringify!(DWT_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DWT_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DWT_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(CTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CYCCNT) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(CYCCNT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CPICNT) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(CPICNT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EXCCNT) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(EXCCNT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SLEEPCNT) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(SLEEPCNT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LSUCNT) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(LSUCNT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FOLDCNT) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(FOLDCNT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PCSR) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(PCSR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).COMP0) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(COMP0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MASK0) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(MASK0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FUNCTION0) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(FUNCTION0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED0) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(RESERVED0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).COMP1) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(COMP1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MASK1) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(MASK1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FUNCTION1) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(FUNCTION1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).COMP2) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(COMP2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MASK2) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(MASK2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FUNCTION2) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(FUNCTION2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED2) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).COMP3) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(COMP3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MASK3) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(MASK3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FUNCTION3) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(DWT_Type),
            "::",
            stringify!(FUNCTION3)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPI_Type {
    pub SSPSR: u32,
    pub CSPSR: u32,
    pub RESERVED0: [u32; 2usize],
    pub ACPR: u32,
    pub RESERVED1: [u32; 55usize],
    pub SPPR: u32,
    pub RESERVED2: [u32; 131usize],
    pub FFSR: u32,
    pub FFCR: u32,
    pub FSCR: u32,
    pub RESERVED3: [u32; 759usize],
    pub TRIGGER: u32,
    pub FIFO0: u32,
    pub ITATBCTR2: u32,
    pub RESERVED4: [u32; 1usize],
    pub ITATBCTR0: u32,
    pub FIFO1: u32,
    pub ITCTRL: u32,
    pub RESERVED5: [u32; 39usize],
    pub CLAIMSET: u32,
    pub CLAIMCLR: u32,
    pub RESERVED7: [u32; 8usize],
    pub DEVID: u32,
    pub DEVTYPE: u32,
}
#[test]
fn bindgen_test_layout_TPI_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TPI_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TPI_Type>(),
        4048usize,
        concat!("Size of: ", stringify!(TPI_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TPI_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TPI_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SSPSR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(SSPSR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CSPSR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(CSPSR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED0) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(RESERVED0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ACPR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(ACPR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SPPR) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(SPPR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED2) as usize - ptr as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FFSR) as usize - ptr as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(FFSR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FFCR) as usize - ptr as usize },
        772usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(FFCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FSCR) as usize - ptr as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(FSCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED3) as usize - ptr as usize },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(RESERVED3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TRIGGER) as usize - ptr as usize },
        3816usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(TRIGGER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FIFO0) as usize - ptr as usize },
        3820usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(FIFO0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ITATBCTR2) as usize - ptr as usize },
        3824usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(ITATBCTR2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED4) as usize - ptr as usize },
        3828usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(RESERVED4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ITATBCTR0) as usize - ptr as usize },
        3832usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(ITATBCTR0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FIFO1) as usize - ptr as usize },
        3836usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(FIFO1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ITCTRL) as usize - ptr as usize },
        3840usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(ITCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED5) as usize - ptr as usize },
        3844usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(RESERVED5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CLAIMSET) as usize - ptr as usize },
        4000usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(CLAIMSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CLAIMCLR) as usize - ptr as usize },
        4004usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(CLAIMCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED7) as usize - ptr as usize },
        4008usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(RESERVED7)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DEVID) as usize - ptr as usize },
        4040usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(DEVID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DEVTYPE) as usize - ptr as usize },
        4044usize,
        concat!(
            "Offset of field: ",
            stringify!(TPI_Type),
            "::",
            stringify!(DEVTYPE)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MPU_Type {
    pub TYPE: u32,
    pub CTRL: u32,
    pub RNR: u32,
    pub RBAR: u32,
    pub RASR: u32,
    pub RBAR_A1: u32,
    pub RASR_A1: u32,
    pub RBAR_A2: u32,
    pub RASR_A2: u32,
    pub RBAR_A3: u32,
    pub RASR_A3: u32,
}
#[test]
fn bindgen_test_layout_MPU_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MPU_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MPU_Type>(),
        44usize,
        concat!("Size of: ", stringify!(MPU_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MPU_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MPU_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TYPE) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Type),
            "::",
            stringify!(TYPE)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRL) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Type),
            "::",
            stringify!(CTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RNR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Type),
            "::",
            stringify!(RNR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RBAR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Type),
            "::",
            stringify!(RBAR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RASR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Type),
            "::",
            stringify!(RASR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RBAR_A1) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Type),
            "::",
            stringify!(RBAR_A1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RASR_A1) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Type),
            "::",
            stringify!(RASR_A1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RBAR_A2) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Type),
            "::",
            stringify!(RBAR_A2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RASR_A2) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Type),
            "::",
            stringify!(RASR_A2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RBAR_A3) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Type),
            "::",
            stringify!(RBAR_A3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RASR_A3) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Type),
            "::",
            stringify!(RASR_A3)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPU_Type {
    pub RESERVED0: [u32; 1usize],
    pub FPCCR: u32,
    pub FPCAR: u32,
    pub FPDSCR: u32,
    pub MVFR0: u32,
    pub MVFR1: u32,
    pub MVFR2: u32,
}
#[test]
fn bindgen_test_layout_FPU_Type() {
    const UNINIT: ::core::mem::MaybeUninit<FPU_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FPU_Type>(),
        28usize,
        concat!("Size of: ", stringify!(FPU_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<FPU_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(FPU_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FPU_Type),
            "::",
            stringify!(RESERVED0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FPCCR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FPU_Type),
            "::",
            stringify!(FPCCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FPCAR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FPU_Type),
            "::",
            stringify!(FPCAR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FPDSCR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FPU_Type),
            "::",
            stringify!(FPDSCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MVFR0) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FPU_Type),
            "::",
            stringify!(MVFR0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MVFR1) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FPU_Type),
            "::",
            stringify!(MVFR1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MVFR2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FPU_Type),
            "::",
            stringify!(MVFR2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CoreDebug_Type {
    pub DHCSR: u32,
    pub DCRSR: u32,
    pub DCRDR: u32,
    pub DEMCR: u32,
}
#[test]
fn bindgen_test_layout_CoreDebug_Type() {
    const UNINIT: ::core::mem::MaybeUninit<CoreDebug_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CoreDebug_Type>(),
        16usize,
        concat!("Size of: ", stringify!(CoreDebug_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<CoreDebug_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(CoreDebug_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DHCSR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CoreDebug_Type),
            "::",
            stringify!(DHCSR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DCRSR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CoreDebug_Type),
            "::",
            stringify!(DCRSR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DCRDR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CoreDebug_Type),
            "::",
            stringify!(DCRDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DEMCR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CoreDebug_Type),
            "::",
            stringify!(DEMCR)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ARM_MPU_Region_t {
    pub RBAR: u32,
    pub RASR: u32,
}
#[test]
fn bindgen_test_layout_ARM_MPU_Region_t() {
    const UNINIT: ::core::mem::MaybeUninit<ARM_MPU_Region_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ARM_MPU_Region_t>(),
        8usize,
        concat!("Size of: ", stringify!(ARM_MPU_Region_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ARM_MPU_Region_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ARM_MPU_Region_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RBAR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ARM_MPU_Region_t),
            "::",
            stringify!(RBAR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RASR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ARM_MPU_Region_t),
            "::",
            stringify!(RASR)
        )
    );
}
extern "C" {
    pub static mut ITM_RxBuffer: i32;
}
extern "C" {
    #[doc = "< System Clock Frequency (Core Clock)"]
    pub static mut SystemCoreClock: u32;
}
extern "C" {
    pub fn SystemInit();
}
extern "C" {
    pub fn SystemCoreClockUpdate();
}
#[doc = " @ingroup gcr_registers\n Structure type to access the GCR Registers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mxc_gcr_regs_t {
    #[doc = "< <tt>\\b 0x00:</tt> GCR SYSCTRL Register"]
    pub sysctrl: u32,
    #[doc = "< <tt>\\b 0x04:</tt> GCR RST0 Register"]
    pub rst0: u32,
    #[doc = "< <tt>\\b 0x08:</tt> GCR CLKCTRL Register"]
    pub clkctrl: u32,
    #[doc = "< <tt>\\b 0x0C:</tt> GCR PM Register"]
    pub pm: u32,
    pub rsv_0x10_0x17: [u32; 2usize],
    #[doc = "< <tt>\\b 0x18:</tt> GCR PCLKDIV Register"]
    pub pclkdiv: u32,
    pub rsv_0x1c_0x23: [u32; 2usize],
    #[doc = "< <tt>\\b 0x24:</tt> GCR PCLKDIS0 Register"]
    pub pclkdis0: u32,
    #[doc = "< <tt>\\b 0x28:</tt> GCR MEMCTRL Register"]
    pub memctrl: u32,
    #[doc = "< <tt>\\b 0x2C:</tt> GCR MEMZ Register"]
    pub memz: u32,
    pub rsv_0x30_0x3f: [u32; 4usize],
    #[doc = "< <tt>\\b 0x40:</tt> GCR SYSST Register"]
    pub sysst: u32,
    #[doc = "< <tt>\\b 0x44:</tt> GCR RST1 Register"]
    pub rst1: u32,
    #[doc = "< <tt>\\b 0x48:</tt> GCR PCLKDIS1 Register"]
    pub pclkdis1: u32,
    #[doc = "< <tt>\\b 0x4C:</tt> GCR EVENTEN Register"]
    pub eventen: u32,
    #[doc = "< <tt>\\b 0x50:</tt> GCR REVISION Register"]
    pub revision: u32,
    #[doc = "< <tt>\\b 0x54:</tt> GCR SYSIE Register"]
    pub sysie: u32,
    pub rsv_0x58_0x63: [u32; 3usize],
    #[doc = "< <tt>\\b 0x64:</tt> GCR ECCERR Register"]
    pub eccerr: u32,
    #[doc = "< <tt>\\b 0x68:</tt> GCR ECCCED Register"]
    pub eccced: u32,
    #[doc = "< <tt>\\b 0x6C:</tt> GCR ECCIE Register"]
    pub eccie: u32,
    #[doc = "< <tt>\\b 0x70:</tt> GCR ECCADDR Register"]
    pub eccaddr: u32,
    pub rsv_0x74_0x7f: [u32; 3usize],
    #[doc = "< <tt>\\b 0x80:</tt> GCR GPR Register"]
    pub gpr: u32,
}
#[test]
fn bindgen_test_layout_mxc_gcr_regs_t() {
    const UNINIT: ::core::mem::MaybeUninit<mxc_gcr_regs_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mxc_gcr_regs_t>(),
        132usize,
        concat!("Size of: ", stringify!(mxc_gcr_regs_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mxc_gcr_regs_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mxc_gcr_regs_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sysctrl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gcr_regs_t),
            "::",
            stringify!(sysctrl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rst0) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gcr_regs_t),
            "::",
            stringify!(rst0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clkctrl) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gcr_regs_t),
            "::",
            stringify!(clkctrl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pm) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gcr_regs_t),
            "::",
            stringify!(pm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsv_0x10_0x17) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gcr_regs_t),
            "::",
            stringify!(rsv_0x10_0x17)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pclkdiv) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gcr_regs_t),
            "::",
            stringify!(pclkdiv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsv_0x1c_0x23) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gcr_regs_t),
            "::",
            stringify!(rsv_0x1c_0x23)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pclkdis0) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gcr_regs_t),
            "::",
            stringify!(pclkdis0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memctrl) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gcr_regs_t),
            "::",
            stringify!(memctrl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memz) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gcr_regs_t),
            "::",
            stringify!(memz)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsv_0x30_0x3f) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gcr_regs_t),
            "::",
            stringify!(rsv_0x30_0x3f)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sysst) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gcr_regs_t),
            "::",
            stringify!(sysst)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rst1) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gcr_regs_t),
            "::",
            stringify!(rst1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pclkdis1) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gcr_regs_t),
            "::",
            stringify!(pclkdis1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eventen) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gcr_regs_t),
            "::",
            stringify!(eventen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).revision) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gcr_regs_t),
            "::",
            stringify!(revision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sysie) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gcr_regs_t),
            "::",
            stringify!(sysie)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsv_0x58_0x63) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gcr_regs_t),
            "::",
            stringify!(rsv_0x58_0x63)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eccerr) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gcr_regs_t),
            "::",
            stringify!(eccerr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eccced) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gcr_regs_t),
            "::",
            stringify!(eccced)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eccie) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gcr_regs_t),
            "::",
            stringify!(eccie)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eccaddr) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gcr_regs_t),
            "::",
            stringify!(eccaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsv_0x74_0x7f) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gcr_regs_t),
            "::",
            stringify!(rsv_0x74_0x7f)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gpr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gcr_regs_t),
            "::",
            stringify!(gpr)
        )
    );
}
#[doc = " @brief      Type alias for a GPIO callback function with prototype:\n @code\nvoid callback_fn(void *cbdata);\n @endcode\n @param      cbdata  A void pointer to the data type as registered when\n                     MXC_GPIO_RegisterCallback() was called."]
pub type mxc_gpio_callback_fn =
    ::core::option::Option<unsafe extern "C" fn(cbdata: *mut ::core::ffi::c_void)>;
#[doc = "< GPIO Input"]
pub const mxc_gpio_func_t_MXC_GPIO_FUNC_IN: mxc_gpio_func_t = 0;
#[doc = "< GPIO Output"]
pub const mxc_gpio_func_t_MXC_GPIO_FUNC_OUT: mxc_gpio_func_t = 1;
#[doc = "< Alternate Function Selection"]
pub const mxc_gpio_func_t_MXC_GPIO_FUNC_ALT1: mxc_gpio_func_t = 2;
#[doc = "< Alternate Function Selection"]
pub const mxc_gpio_func_t_MXC_GPIO_FUNC_ALT2: mxc_gpio_func_t = 3;
#[doc = "< Alternate Function Selection"]
pub const mxc_gpio_func_t_MXC_GPIO_FUNC_ALT3: mxc_gpio_func_t = 4;
#[doc = "< Alternate Function Selection"]
pub const mxc_gpio_func_t_MXC_GPIO_FUNC_ALT4: mxc_gpio_func_t = 5;
#[doc = " @brief   Enumeration type for the GPIO Function Type"]
pub type mxc_gpio_func_t = ::core::ffi::c_uint;
#[doc = "< Set pin to VIDDIO voltage"]
pub const mxc_gpio_vssel_t_MXC_GPIO_VSSEL_VDDIO: mxc_gpio_vssel_t = 0;
#[doc = "< Set pin to VIDDIOH voltage"]
pub const mxc_gpio_vssel_t_MXC_GPIO_VSSEL_VDDIOH: mxc_gpio_vssel_t = 1;
#[doc = " @brief   Enumeration type for the voltage level on a given pin."]
pub type mxc_gpio_vssel_t = ::core::ffi::c_uint;
#[doc = "< No pull-up or pull-down"]
pub const mxc_gpio_pad_t_MXC_GPIO_PAD_NONE: mxc_gpio_pad_t = 0;
#[doc = "< Set pad to strong pull-up"]
pub const mxc_gpio_pad_t_MXC_GPIO_PAD_PULL_UP: mxc_gpio_pad_t = 1;
#[doc = "< Set pad to strong pull-down"]
pub const mxc_gpio_pad_t_MXC_GPIO_PAD_PULL_DOWN: mxc_gpio_pad_t = 2;
#[doc = "< Set pad to weak pull-up"]
pub const mxc_gpio_pad_t_MXC_GPIO_PAD_WEAK_PULL_UP: mxc_gpio_pad_t = 3;
#[doc = "< Set pad to weak pull-down"]
pub const mxc_gpio_pad_t_MXC_GPIO_PAD_WEAK_PULL_DOWN: mxc_gpio_pad_t = 4;
#[doc = " @brief   Enumeration type for the type of GPIO pad on a given pin."]
pub type mxc_gpio_pad_t = ::core::ffi::c_uint;
#[doc = " @brief   Structure type for configuring a GPIO port."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mxc_gpio_cfg_t {
    #[doc = "< Pointer to GPIO regs"]
    pub port: *mut mxc_gpio_regs_t,
    #[doc = "< Pin mask (multiple pins may be set)"]
    pub mask: u32,
    #[doc = "< Function type"]
    pub func: mxc_gpio_func_t,
    #[doc = "< Pad type"]
    pub pad: mxc_gpio_pad_t,
    #[doc = "< Voltage select"]
    pub vssel: mxc_gpio_vssel_t,
}
#[test]
fn bindgen_test_layout_mxc_gpio_cfg_t() {
    const UNINIT: ::core::mem::MaybeUninit<mxc_gpio_cfg_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mxc_gpio_cfg_t>(),
        20usize,
        concat!("Size of: ", stringify!(mxc_gpio_cfg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mxc_gpio_cfg_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mxc_gpio_cfg_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_cfg_t),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_cfg_t),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_cfg_t),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_cfg_t),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vssel) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_gpio_cfg_t),
            "::",
            stringify!(vssel)
        )
    );
}
#[doc = "< Interrupt is level sensitive"]
pub const mxc_gpio_int_mode_t_MXC_GPIO_INT_LEVEL: mxc_gpio_int_mode_t = 0;
#[doc = "< Interrupt is edge sensitive"]
pub const mxc_gpio_int_mode_t_MXC_GPIO_INT_EDGE: mxc_gpio_int_mode_t = 1;
#[doc = " @brief   Enumeration type for the interrupt modes."]
pub type mxc_gpio_int_mode_t = ::core::ffi::c_uint;
#[doc = "< Interrupt triggers on falling edge"]
pub const mxc_gpio_int_pol_t_MXC_GPIO_INT_FALLING: mxc_gpio_int_pol_t = 0;
#[doc = "< Interrupt triggers when level is high"]
pub const mxc_gpio_int_pol_t_MXC_GPIO_INT_HIGH: mxc_gpio_int_pol_t = 1;
#[doc = "< Interrupt triggers on rising edge"]
pub const mxc_gpio_int_pol_t_MXC_GPIO_INT_RISING: mxc_gpio_int_pol_t = 2;
#[doc = "< Interrupt triggers when level is low"]
pub const mxc_gpio_int_pol_t_MXC_GPIO_INT_LOW: mxc_gpio_int_pol_t = 3;
#[doc = "< Interrupt triggers on either edge"]
pub const mxc_gpio_int_pol_t_MXC_GPIO_INT_BOTH: mxc_gpio_int_pol_t = 4;
#[doc = " @brief   Enumeration type for the interrupt polarity."]
pub type mxc_gpio_int_pol_t = ::core::ffi::c_uint;
extern "C" {
    #[doc = " @brief      Initialize GPIO.\n @param      portMask     Mask for the port to be initialized\n @return     #E_NO_ERROR if everything is successful."]
    pub fn MXC_GPIO_Init(portMask: u32) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Shutdown GPIO.\n @param      portMask     Mask for the port to be initialized\n @return     #E_NO_ERROR if everything is successful."]
    pub fn MXC_GPIO_Shutdown(portMask: u32) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Reset GPIO.\n @param      portMask     Mask for the port to be initialized\n @return     #E_NO_ERROR if everything is successful."]
    pub fn MXC_GPIO_Reset(portMask: u32) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Configure GPIO pin(s).\n @param      cfg   Pointer to configuration structure describing the pin.\n @return     #E_NO_ERROR if everything is successful."]
    pub fn MXC_GPIO_Config(cfg: *const mxc_gpio_cfg_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Gets the pin(s) input state.\n @param      port  Pointer to the GPIO port\n @param      mask  Mask of the pin(s) to read\n @return     The requested pin state."]
    pub fn MXC_GPIO_InGet(port: *mut mxc_gpio_regs_t, mask: u32) -> u32;
}
extern "C" {
    #[doc = " @brief      Sets the pin(s) to a high level output.\n @param      port  Pointer to the GPIO port\n @param      mask  Mask of the pin(s) to set"]
    pub fn MXC_GPIO_OutSet(port: *mut mxc_gpio_regs_t, mask: u32);
}
extern "C" {
    #[doc = " @brief      Clears the pin(s) to a low level output.\n @param      port  Pointer to the GPIO port\n @param      mask  Mask of the pin(s) to clear"]
    pub fn MXC_GPIO_OutClr(port: *mut mxc_gpio_regs_t, mask: u32);
}
extern "C" {
    #[doc = " @brief      Gets the pin(s) output state.\n @param      port Pointer to the GPIO port\n @param      mask  Mask of the pin(s) to read the output state of\n @return     The state of the requested pin.\n"]
    pub fn MXC_GPIO_OutGet(port: *mut mxc_gpio_regs_t, mask: u32) -> u32;
}
extern "C" {
    #[doc = " @brief      Write the pin(s) to a desired output level.\n @param      port  Pointer to the GPIO port\n @param      mask  Mask of the pin(s) to set output level of\n @param      val   Desired output level of the pin(s). This will be masked\n                   with the configuration mask."]
    pub fn MXC_GPIO_OutPut(port: *mut mxc_gpio_regs_t, mask: u32, val: u32);
}
extern "C" {
    #[doc = " @brief      Toggles the the pin(s) output level.\n @param      port  Pointer to the GPIO port\n @param      mask  Mask of the pin(s) to toggle"]
    pub fn MXC_GPIO_OutToggle(port: *mut mxc_gpio_regs_t, mask: u32);
}
extern "C" {
    #[doc = " @brief      Configure GPIO interrupt(s)\n @param      cfg   Pointer to configuration structure describing the pin.\n @param      pol   Requested interrupt polarity.\n @return     #E_NO_ERROR if everything is successful."]
    pub fn MXC_GPIO_IntConfig(
        cfg: *const mxc_gpio_cfg_t,
        pol: mxc_gpio_int_pol_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Enables the specified GPIO interrupt\n @param      port  Pointer to the GPIO port\n @param      mask  Mask of the pin(s) to enable interrupts for\n"]
    pub fn MXC_GPIO_EnableInt(port: *mut mxc_gpio_regs_t, mask: u32);
}
extern "C" {
    #[doc = " @brief      Disables the specified GPIO interrupt.\n @param      port  Pointer to the GPIO port\n @param      mask  Mask of the pin(s) to disable interrupts for"]
    pub fn MXC_GPIO_DisableInt(port: *mut mxc_gpio_regs_t, mask: u32);
}
extern "C" {
    #[doc = " @brief      Gets the interrupt(s) status on a GPIO port\n\n @param      port   Pointer to the port requested\n\n @return     The requested interrupt status."]
    pub fn MXC_GPIO_GetFlags(port: *mut mxc_gpio_regs_t) -> u32;
}
extern "C" {
    #[doc = " @brief      Gets the interrupt(s) status on a GPIO port\n\n @param      port   Pointer to the port requested\n @param      flags  The flags to clear"]
    pub fn MXC_GPIO_ClearFlags(port: *mut mxc_gpio_regs_t, flags: u32);
}
extern "C" {
    #[doc = " @brief      Registers a callback for the interrupt on a given port and pin.\n @param      cfg       Pointer to configuration structure describing the pin\n @param      callback  A pointer to a function of type #callback_fn.\n @param      cbdata    The parameter to be passed to the callback function, #callback_fn, when an interrupt occurs.\n"]
    pub fn MXC_GPIO_RegisterCallback(
        cfg: *const mxc_gpio_cfg_t,
        callback: mxc_gpio_callback_fn,
        cbdata: *mut ::core::ffi::c_void,
    );
}
extern "C" {
    #[doc = " @brief      GPIO IRQ Handler. @note If a callback is registered for a given\n             interrupt, the callback function will be called.\n\n @param      port number of the port that generated the interrupt service routine.\n"]
    pub fn MXC_GPIO_Handler(port: ::core::ffi::c_uint);
}
extern "C" {
    #[doc = " @brief      Set Voltage select for pins to VDDIO or VDDIOH\n\n @param      port   The GPIO port\n @param[in]  vssel  VDDIO or VDDIOH to set the voltatge to\n @param[in]  mask   Pins in the GPIO port that will be set to the voltage.\n\n @return   E_NO_ERROR if succesfful, otherwise E_BAD_PARAM."]
    pub fn MXC_GPIO_SetVSSEL(
        port: *mut mxc_gpio_regs_t,
        vssel: mxc_gpio_vssel_t,
        mask: u32,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Enables GPIO pins to be used as a wakeup source.\n\n @param      port   The GPIO port\n @param      mask   Pins in the GPIO port that will be enabled as a wakeup source."]
    pub fn MXC_GPIO_SetWakeEn(port: *mut mxc_gpio_regs_t, mask: u32);
}
extern "C" {
    #[doc = " @brief      Disables GPIO pins from being used as a wakeup source.\n\n @param      port   The GPIO port\n @param      mask   Pins in the GPIO port that will be disabled as a wakeup source."]
    pub fn MXC_GPIO_ClearWakeEn(port: *mut mxc_gpio_regs_t, mask: u32);
}
extern "C" {
    #[doc = " @brief      Returns the pins currently enabled as wakeup sources.\n\n @param      port   The GPIO port to check.\n\n @returns    The value of the wake enable register."]
    pub fn MXC_GPIO_GetWakeEn(port: *mut mxc_gpio_regs_t) -> u32;
}
extern "C" {
    #[doc = " Global Variables"]
    pub static gpio_cfg_extclk: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_i2c0: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_i2c1: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_i2c2: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_uart0: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_uart0_flow: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_uart0_flow_disable: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_uart1: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_uart2: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_uart3: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_tmr0: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_tmr1: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_tmr2: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_tmr3: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_tmr0b: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_tmr1b: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_tmr2b: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_tmr3b: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_tmr4: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_tmr5: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_i2s0: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_i2s0_extclk: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_owm: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_owmb: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_spi0: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_spi1: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_rtcsqw: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_rtcsqwb: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_pt0: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_pt1: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_pt2: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_pt3: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_pcif_P0_BITS_0_7: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_pcif_P0_BITS_8_9: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_pcif_P1_BITS_10_11: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_pcif_hsync: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_pcif_vsync: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_pcif_xclk: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_adc_ain0: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_adc_ain1: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_adc_ain2: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_adc_ain3: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_adc_ain4: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_adc_ain5: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_adc_ain6: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_adc_ain7: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_cmp0: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_cmp1: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_cmp2: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_cmp3: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_spi0_standard: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_spi0_3wire: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_spi0_dual: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_spi0_quad: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_spi1_standard: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_spi1_3wire: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_spi1_dual: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_spi1_quad: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_spi0_ts0: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_spi0_ts1: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_spi0_ts2: mxc_gpio_cfg_t;
}
extern "C" {
    pub static gpio_cfg_spi1_ts0: mxc_gpio_cfg_t;
}
#[doc = " @ingroup lpgcr_registers\n Structure type to access the LPGCR Registers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mxc_lpgcr_regs_t {
    pub rsv_0x0_0x7: [u32; 2usize],
    #[doc = "< <tt>\\b 0x08:</tt> LPGCR RST Register"]
    pub rst: u32,
    #[doc = "< <tt>\\b 0x0C:</tt> LPGCR PCLKDIS Register"]
    pub pclkdis: u32,
}
#[test]
fn bindgen_test_layout_mxc_lpgcr_regs_t() {
    const UNINIT: ::core::mem::MaybeUninit<mxc_lpgcr_regs_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mxc_lpgcr_regs_t>(),
        16usize,
        concat!("Size of: ", stringify!(mxc_lpgcr_regs_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mxc_lpgcr_regs_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mxc_lpgcr_regs_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsv_0x0_0x7) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_lpgcr_regs_t),
            "::",
            stringify!(rsv_0x0_0x7)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rst) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_lpgcr_regs_t),
            "::",
            stringify!(rst)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pclkdis) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_lpgcr_regs_t),
            "::",
            stringify!(pclkdis)
        )
    );
}
#[doc = "< Reset DMA"]
pub const mxc_sys_reset_t_MXC_SYS_RESET0_DMA: mxc_sys_reset_t = 0;
#[doc = "< Reset WDT"]
pub const mxc_sys_reset_t_MXC_SYS_RESET0_WDT0: mxc_sys_reset_t = 1;
#[doc = "< Reset GPIO0"]
pub const mxc_sys_reset_t_MXC_SYS_RESET0_GPIO0: mxc_sys_reset_t = 2;
#[doc = "< Reset GPIO1"]
pub const mxc_sys_reset_t_MXC_SYS_RESET0_GPIO1: mxc_sys_reset_t = 3;
#[doc = "< Reset TMR0"]
pub const mxc_sys_reset_t_MXC_SYS_RESET0_TMR0: mxc_sys_reset_t = 5;
#[doc = "< Reset TMR1"]
pub const mxc_sys_reset_t_MXC_SYS_RESET0_TMR1: mxc_sys_reset_t = 6;
#[doc = "< Reset TMR2"]
pub const mxc_sys_reset_t_MXC_SYS_RESET0_TMR2: mxc_sys_reset_t = 7;
#[doc = "< Reset TMR3"]
pub const mxc_sys_reset_t_MXC_SYS_RESET0_TMR3: mxc_sys_reset_t = 8;
#[doc = "< Reset UART0"]
pub const mxc_sys_reset_t_MXC_SYS_RESET0_UART0: mxc_sys_reset_t = 11;
#[doc = "< Reset UART1"]
pub const mxc_sys_reset_t_MXC_SYS_RESET0_UART1: mxc_sys_reset_t = 12;
#[doc = "< Reset SPI1"]
pub const mxc_sys_reset_t_MXC_SYS_RESET0_SPI1: mxc_sys_reset_t = 13;
#[doc = "< Reset I2C0"]
pub const mxc_sys_reset_t_MXC_SYS_RESET0_I2C0: mxc_sys_reset_t = 16;
#[doc = "< Reset RTC"]
pub const mxc_sys_reset_t_MXC_SYS_RESET0_RTC: mxc_sys_reset_t = 17;
#[doc = "< Reset SMPHR"]
pub const mxc_sys_reset_t_MXC_SYS_RESET0_SMPHR: mxc_sys_reset_t = 22;
#[doc = "< Reset TRNG"]
pub const mxc_sys_reset_t_MXC_SYS_RESET0_TRNG: mxc_sys_reset_t = 24;
#[doc = "< Reset CNN"]
pub const mxc_sys_reset_t_MXC_SYS_RESET0_CNN: mxc_sys_reset_t = 25;
#[doc = "< Reset ADC"]
pub const mxc_sys_reset_t_MXC_SYS_RESET0_ADC: mxc_sys_reset_t = 26;
#[doc = "< Reset UART2"]
pub const mxc_sys_reset_t_MXC_SYS_RESET0_UART2: mxc_sys_reset_t = 28;
#[doc = "< Soft reset"]
pub const mxc_sys_reset_t_MXC_SYS_RESET0_SOFT: mxc_sys_reset_t = 29;
#[doc = "< Peripheral reset"]
pub const mxc_sys_reset_t_MXC_SYS_RESET0_PERIPH: mxc_sys_reset_t = 30;
#[doc = "< System reset"]
pub const mxc_sys_reset_t_MXC_SYS_RESET0_SYS: mxc_sys_reset_t = 31;
#[doc = "< Reset I2C1"]
pub const mxc_sys_reset_t_MXC_SYS_RESET1_I2C1: mxc_sys_reset_t = 32;
#[doc = "< Reset PT"]
pub const mxc_sys_reset_t_MXC_SYS_RESET1_PT: mxc_sys_reset_t = 33;
#[doc = "< Reset OWM"]
pub const mxc_sys_reset_t_MXC_SYS_RESET1_OWM: mxc_sys_reset_t = 39;
#[doc = "< Reset CRC"]
pub const mxc_sys_reset_t_MXC_SYS_RESET1_CRC: mxc_sys_reset_t = 41;
#[doc = "< Reset AES"]
pub const mxc_sys_reset_t_MXC_SYS_RESET1_AES: mxc_sys_reset_t = 42;
#[doc = "< Reset SMPHR"]
pub const mxc_sys_reset_t_MXC_SYS_RESET1_SMPHR: mxc_sys_reset_t = 48;
#[doc = "< Reset I2C2"]
pub const mxc_sys_reset_t_MXC_SYS_RESET1_I2C2: mxc_sys_reset_t = 52;
#[doc = "< Reset I2S"]
pub const mxc_sys_reset_t_MXC_SYS_RESET1_I2S: mxc_sys_reset_t = 51;
#[doc = "< Reset DVS"]
pub const mxc_sys_reset_t_MXC_SYS_RESET1_DVS: mxc_sys_reset_t = 56;
#[doc = "< Reset SIMO"]
pub const mxc_sys_reset_t_MXC_SYS_RESET1_SIMO: mxc_sys_reset_t = 57;
#[doc = "< Reset SPI0"]
pub const mxc_sys_reset_t_MXC_SYS_RESET1_SPI0: mxc_sys_reset_t = 43;
#[doc = "< Reset CPU1"]
pub const mxc_sys_reset_t_MXC_SYS_RESET1_CPU1: mxc_sys_reset_t = 63;
#[doc = "< Reset GPIO2"]
pub const mxc_sys_reset_t_MXC_SYS_RESET_GPIO2: mxc_sys_reset_t = 64;
#[doc = "< Reset WDT1"]
pub const mxc_sys_reset_t_MXC_SYS_RESET_WDT1: mxc_sys_reset_t = 65;
#[doc = "< Reset TMR4"]
pub const mxc_sys_reset_t_MXC_SYS_RESET_TMR4: mxc_sys_reset_t = 66;
#[doc = "< Reset TMR5"]
pub const mxc_sys_reset_t_MXC_SYS_RESET_TMR5: mxc_sys_reset_t = 67;
#[doc = "< Reset UART3"]
pub const mxc_sys_reset_t_MXC_SYS_RESET_UART3: mxc_sys_reset_t = 68;
#[doc = "< Reset LPCOMP"]
pub const mxc_sys_reset_t_MXC_SYS_RESET_LPCOMP: mxc_sys_reset_t = 70;
#[doc = " @brief System reset0 and reset1 enumeration. Used in MXC_SYS_PeriphReset0 function"]
pub type mxc_sys_reset_t = ::core::ffi::c_uint;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_GPIO0: mxc_sys_periph_clock_t = 0;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_GPIO1: mxc_sys_periph_clock_t = 1;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_DMA: mxc_sys_periph_clock_t = 5;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_SPI1: mxc_sys_periph_clock_t = 6;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_UART0: mxc_sys_periph_clock_t = 9;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_UART1: mxc_sys_periph_clock_t = 10;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_I2C0: mxc_sys_periph_clock_t = 13;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_TMR0: mxc_sys_periph_clock_t = 15;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_TMR1: mxc_sys_periph_clock_t = 16;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_TMR2: mxc_sys_periph_clock_t = 17;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_TMR3: mxc_sys_periph_clock_t = 18;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_ADC: mxc_sys_periph_clock_t = 23;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_CNN: mxc_sys_periph_clock_t = 25;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_I2C1: mxc_sys_periph_clock_t = 28;
#[doc = "< Disable MXC_F_GCR_PCLKDIS0_PT clock"]
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_PT: mxc_sys_periph_clock_t = 29;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_UART2: mxc_sys_periph_clock_t = 33;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_TRNG: mxc_sys_periph_clock_t = 34;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_SMPHR: mxc_sys_periph_clock_t = 41;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_OWIRE: mxc_sys_periph_clock_t = 45;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_CRC: mxc_sys_periph_clock_t = 46;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_AES: mxc_sys_periph_clock_t = 47;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_I2S: mxc_sys_periph_clock_t = 55;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_SPI0: mxc_sys_periph_clock_t = 48;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_PCIF: mxc_sys_periph_clock_t = 50;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_I2C2: mxc_sys_periph_clock_t = 56;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_WDT0: mxc_sys_periph_clock_t = 59;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_CPU1: mxc_sys_periph_clock_t = 63;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_GPIO2: mxc_sys_periph_clock_t = 64;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_WDT1: mxc_sys_periph_clock_t = 65;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_TMR4: mxc_sys_periph_clock_t = 66;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_TMR5: mxc_sys_periph_clock_t = 67;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_UART3: mxc_sys_periph_clock_t = 68;
pub const mxc_sys_periph_clock_t_MXC_SYS_PERIPH_CLOCK_LPCOMP: mxc_sys_periph_clock_t = 70;
#[doc = " @brief System clock disable enumeration. Used in MXC_SYS_ClockDisable and MXC_SYS_ClockEnable functions"]
pub type mxc_sys_periph_clock_t = ::core::ffi::c_uint;
pub const mxc_sys_system_clock_t_MXC_SYS_CLOCK_IPO: mxc_sys_system_clock_t = 4;
pub const mxc_sys_system_clock_t_MXC_SYS_CLOCK_IBRO: mxc_sys_system_clock_t = 5;
pub const mxc_sys_system_clock_t_MXC_SYS_CLOCK_ISO: mxc_sys_system_clock_t = 0;
pub const mxc_sys_system_clock_t_MXC_SYS_CLOCK_INRO: mxc_sys_system_clock_t = 3;
pub const mxc_sys_system_clock_t_MXC_SYS_CLOCK_ERTCO: mxc_sys_system_clock_t = 6;
pub const mxc_sys_system_clock_t_MXC_SYS_CLOCK_EXTCLK: mxc_sys_system_clock_t = 7;
#[doc = " @brief Enumeration to select System Clock source"]
pub type mxc_sys_system_clock_t = ::core::ffi::c_uint;
pub const mxc_sys_system_clock_div_t_MXC_SYS_CLOCK_DIV_1: mxc_sys_system_clock_div_t = 0;
pub const mxc_sys_system_clock_div_t_MXC_SYS_CLOCK_DIV_2: mxc_sys_system_clock_div_t = 64;
pub const mxc_sys_system_clock_div_t_MXC_SYS_CLOCK_DIV_4: mxc_sys_system_clock_div_t = 128;
pub const mxc_sys_system_clock_div_t_MXC_SYS_CLOCK_DIV_8: mxc_sys_system_clock_div_t = 192;
pub const mxc_sys_system_clock_div_t_MXC_SYS_CLOCK_DIV_16: mxc_sys_system_clock_div_t = 256;
pub const mxc_sys_system_clock_div_t_MXC_SYS_CLOCK_DIV_32: mxc_sys_system_clock_div_t = 320;
pub const mxc_sys_system_clock_div_t_MXC_SYS_CLOCK_DIV_64: mxc_sys_system_clock_div_t = 384;
pub const mxc_sys_system_clock_div_t_MXC_SYS_CLOCK_DIV_128: mxc_sys_system_clock_div_t = 448;
#[doc = " @brief Enumeration to set the System Clock divider"]
pub type mxc_sys_system_clock_div_t = ::core::ffi::c_uint;
#[doc = " Function Prototypes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mxc_crit_state_t {
    pub ie_status: ::core::ffi::c_int,
    pub in_critical: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_mxc_crit_state_t() {
    const UNINIT: ::core::mem::MaybeUninit<mxc_crit_state_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mxc_crit_state_t>(),
        8usize,
        concat!("Size of: ", stringify!(mxc_crit_state_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mxc_crit_state_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mxc_crit_state_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ie_status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_crit_state_t),
            "::",
            stringify!(ie_status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).in_critical) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_crit_state_t),
            "::",
            stringify!(in_critical)
        )
    );
}
extern "C" {
    pub static mut _state: mxc_crit_state_t;
}
extern "C" {
    #[doc = " @brief Reads the device USN and verifies the checksum.\n @param usn       Pointer to store the USN. Array must be at least MXC_SYS_USN_LEN bytes long.\n @param checksum  Optional pointer to store the AES checksum. If not NULL, checksum is verified with AES engine.\n @returns         E_NO_ERROR if everything is successful."]
    pub fn MXC_SYS_GetUSN(usn: *mut u8, checksum: *mut u8) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Determines if the selected peripheral clock is enabled.\n @param clock   Enumeration for desired clock.\n @returns       0 is the clock is disabled, non 0 if the clock is enabled."]
    pub fn MXC_SYS_IsClockEnabled(clock: mxc_sys_periph_clock_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Disables the selected peripheral clock.\n @param clock   Enumeration for desired clock."]
    pub fn MXC_SYS_ClockDisable(clock: mxc_sys_periph_clock_t);
}
extern "C" {
    #[doc = " @brief Enables the selected peripheral clock.\n @param clock   Enumeration for desired clock."]
    pub fn MXC_SYS_ClockEnable(clock: mxc_sys_periph_clock_t);
}
extern "C" {
    #[doc = " @brief Enables the 32kHz oscillator\n @param mxc_sys_cfg   Not used, may be NULL."]
    pub fn MXC_SYS_RTCClockEnable();
}
extern "C" {
    #[doc = " @brief Disables the 32kHz oscillator\n @returns         E_NO_ERROR if everything is successful"]
    pub fn MXC_SYS_RTCClockDisable() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Enable System Clock Source without switching to it\n @param      clock The clock to enable\n @return     E_NO_ERROR if everything is successful"]
    pub fn MXC_SYS_ClockSourceEnable(clock: mxc_sys_system_clock_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Disable System Clock Source\n @param      clock The clock to disable\n @return     E_NO_ERROR if everything is successful"]
    pub fn MXC_SYS_ClockSourceDisable(clock: mxc_sys_system_clock_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Get the current system clock divider.\n @returns The enumerator for the current system clock divider."]
    pub fn MXC_SYS_GetClockDiv() -> mxc_sys_system_clock_div_t;
}
extern "C" {
    #[doc = " @brief Set the system clock divider.\n @param div       Enumeration for desired clock divider."]
    pub fn MXC_SYS_SetClockDiv(div: mxc_sys_system_clock_div_t);
}
extern "C" {
    #[doc = " @brief Select the system clock.\n @param clock     Enumeration for desired clock.  Note:  If using the external clock input be sure to define EXTCLK_FREQ correctly.\n                  The default EXTCLK_FREQ value is defined in the system_max78000.h file and can be overridden at compile time.\n @returns         E_NO_ERROR if everything is successful."]
    pub fn MXC_SYS_Clock_Select(clock: mxc_sys_system_clock_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Wait for a clock to enable with timeout\n @param      ready The clock to wait for\n @return     E_NO_ERROR if ready, E_TIME_OUT if timeout"]
    pub fn MXC_SYS_Clock_Timeout(ready: u32) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Reset the peripherals and/or CPU in the rstr0 or rstr1 register.\n @param           Enumeration for what to reset. Can reset multiple items at once."]
    pub fn MXC_SYS_Reset_Periph(reset: mxc_sys_reset_t);
}
extern "C" {
    #[doc = " @brief Returns the clock rate (in Hz) of the Risc-V core."]
    pub fn MXC_SYS_RiscVClockRate() -> u32;
}
extern "C" {
    #[doc = " @brief      Assert an error when the given expression fails during debugging.\n @param      expr  String with the expression that failed the assertion.\n @param      file  File containing the failed assertion.\n @param      line  Line number for the failed assertion.\n @note       This is defined as a weak function and can be overridden at the\n             application layer to print the debugging information.\n             @code\n             printf(\"%s, file: %s, line %d\\n\", expr, file, line);\n             @endcode\n @note       To use debug assertions, the symbol @c MXC_ASSERT_ENABLE must be\n             defined."]
    pub fn mxc_assert(
        expr: *const ::core::ffi::c_char,
        file: *const ::core::ffi::c_char,
        line: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " @brief      Attempts to acquire the lock.\n @details    This in an interrupt safe function that can be used as a mutex.\n             The lock variable must remain in scope until the lock is\n             released. Will not block if another thread has already acquired\n             the lock.\n @param      lock   Pointer to variable that is used for the lock.\n @param      value  Value to be place in the lock. Can not be 0.\n\n @return     #E_NO_ERROR if everything successful, #E_BUSY if lock is taken."]
    pub fn MXC_GetLock(lock: *mut u32, value: u32) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief         Free the given lock.\n @param[in,out] lock  Pointer to the variable used for the lock. When the lock\n                      is free, the value pointed to by @p lock is set to zero."]
    pub fn MXC_FreeLock(lock: *mut u32);
}
#[doc = "< 1 Data line, half duplex"]
pub const mxc_spi_width_t_SPI_WIDTH_3WIRE: mxc_spi_width_t = 0;
#[doc = "< MISO/MOSI, full duplex"]
pub const mxc_spi_width_t_SPI_WIDTH_STANDARD: mxc_spi_width_t = 1;
#[doc = "< 2 Data lines, half duplex"]
pub const mxc_spi_width_t_SPI_WIDTH_DUAL: mxc_spi_width_t = 2;
#[doc = "< 4 Data lines, half duplex"]
pub const mxc_spi_width_t_SPI_WIDTH_QUAD: mxc_spi_width_t = 3;
#[doc = " @brief   The list of SPI Widths supported\n\n The SPI Width can be set on a per-transaction basis.\n An example use case of SPI_WIDTH_STANDARD_HALFDUPLEX is\n given.\n\n Using a MAX31865 RTD-to-SPI IC, read back the temperature\n The IC requires a SPI Read to be executed as\n 1. Assert SS\n 2. Write an 8bit register address\n 3. Read back the 8 bit register\n 4. Deassert SS\n This can be accomplished with the STANDARD_HALFDUPLEX width\n 1. set txData to the address, txLen=1\n 2. set rxData to a buffer of 1 byte, rxLen=1\n 3. The driver will transmit the txData, and after completion of\n    txData begin to recieve data, padding MOSI with DefaultTXData\n"]
pub type mxc_spi_width_t = ::core::ffi::c_uint;
#[doc = "< clock phase = 0, clock polarity = 0"]
pub const mxc_spi_mode_t_SPI_MODE_0: mxc_spi_mode_t = 0;
#[doc = "< clock phase = 0, clock polarity = 1"]
pub const mxc_spi_mode_t_SPI_MODE_1: mxc_spi_mode_t = 1;
#[doc = "< clock phase = 1, clock polarity = 0"]
pub const mxc_spi_mode_t_SPI_MODE_2: mxc_spi_mode_t = 2;
#[doc = "< clock phase = 1, clock polarity = 1"]
pub const mxc_spi_mode_t_SPI_MODE_3: mxc_spi_mode_t = 3;
#[doc = " @brief The list of SPI modes\n\n SPI supports four combinations of clock and phase polarity\n\n Clock polarity is controlled using the bit SPIn_CTRL2.cpol\n and determines if the clock is active high or active low\n\n Clock phase determines when the data must be stable for sampling\n"]
pub type mxc_spi_mode_t = ::core::ffi::c_uint;
#[doc = " @brief Structure used to initialize SPI pins.\n\n @note All values must be initialized.\n\n @note True equals pin is set for the spi function false the pin is left to its latest state."]
pub type mxc_spi_pins_t = _mxc_spi_pins_t;
#[doc = " @brief Structure used to initialize SPI pins.\n\n @note All values must be initialized.\n\n @note True equals pin is set for the spi function false the pin is left to its latest state."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _mxc_spi_pins_t {
    #[doc = "<Clock pin"]
    pub clock: bool,
    #[doc = "< Slave select pin 0"]
    pub ss0: bool,
    #[doc = "< Slave select pin 1"]
    pub ss1: bool,
    #[doc = "< Slave select pin 2"]
    pub ss2: bool,
    #[doc = "< miso pin"]
    pub miso: bool,
    #[doc = "< mosi pin"]
    pub mosi: bool,
    #[doc = "< SDIO2 pin"]
    pub sdio2: bool,
    #[doc = "< SDIO3 pin"]
    pub sdio3: bool,
    #[doc = "< VDDIOH Select"]
    pub vddioh: bool,
}
#[test]
fn bindgen_test_layout__mxc_spi_pins_t() {
    const UNINIT: ::core::mem::MaybeUninit<_mxc_spi_pins_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_mxc_spi_pins_t>(),
        9usize,
        concat!("Size of: ", stringify!(_mxc_spi_pins_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_mxc_spi_pins_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_mxc_spi_pins_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mxc_spi_pins_t),
            "::",
            stringify!(clock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ss0) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_mxc_spi_pins_t),
            "::",
            stringify!(ss0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ss1) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_mxc_spi_pins_t),
            "::",
            stringify!(ss1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ss2) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_mxc_spi_pins_t),
            "::",
            stringify!(ss2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).miso) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_mxc_spi_pins_t),
            "::",
            stringify!(miso)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mosi) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_mxc_spi_pins_t),
            "::",
            stringify!(mosi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sdio2) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_mxc_spi_pins_t),
            "::",
            stringify!(sdio2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sdio3) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(_mxc_spi_pins_t),
            "::",
            stringify!(sdio3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vddioh) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_mxc_spi_pins_t),
            "::",
            stringify!(vddioh)
        )
    );
}
#[doc = " @brief   The information required to perform a complete SPI transaction\n\n This structure is used by blocking, async, and DMA based transactions.\n @note   \"completeCB\" only needs to be initialized for interrupt driven (Async) and DMA transactions."]
pub type mxc_spi_req_t = _mxc_spi_req_t;
#[doc = " @brief   The callback routine used to indicate the transaction has terminated.\n\n @param   req         The details of the transaction.\n @param   result      See \\ref MXC_Error_Codes for the list of error codes."]
pub type spi_complete_cb_t = ::core::option::Option<
    unsafe extern "C" fn(req: *mut ::core::ffi::c_void, result: ::core::ffi::c_int),
>;
#[doc = " @brief   The information required to perform a complete SPI transaction\n\n This structure is used by blocking, async, and DMA based transactions.\n @note   \"completeCB\" only needs to be initialized for interrupt driven (Async) and DMA transactions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _mxc_spi_req_t {
    #[doc = "<Point to SPI registers"]
    pub spi: *mut mxc_spi_regs_t,
    #[doc = "< Slave select line to use (Master only, ignored in slave mode)"]
    pub ssIdx: ::core::ffi::c_int,
    #[doc = "< 1 - Deassert SS at end of transaction, 0 - leave SS asserted"]
    pub ssDeassert: ::core::ffi::c_int,
    #[doc = "< Buffer containing transmit data. For character sizes\n< < 8 bits, pad the MSB of each byte with zeros. For\n< character sizes > 8 bits, use two bytes per character\n< and pad the MSB of the upper byte with zeros"]
    pub txData: *mut u8,
    #[doc = "< Buffer to store received data For character sizes\n< < 8 bits, pad the MSB of each byte with zeros. For\n< character sizes > 8 bits, use two bytes per character\n< and pad the MSB of the upper byte with zeros"]
    pub rxData: *mut u8,
    #[doc = "< Number of bytes to be sent from txData"]
    pub txLen: u32,
    #[doc = "< Number of bytes to be stored in rxData"]
    pub rxLen: u32,
    #[doc = "< Number of bytes actually transmitted from txData"]
    pub txCnt: u32,
    #[doc = "< Number of bytes stored in rxData"]
    pub rxCnt: u32,
    #[doc = "< Pointer to function called when transaction is complete"]
    pub completeCB: spi_complete_cb_t,
}
#[test]
fn bindgen_test_layout__mxc_spi_req_t() {
    const UNINIT: ::core::mem::MaybeUninit<_mxc_spi_req_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_mxc_spi_req_t>(),
        40usize,
        concat!("Size of: ", stringify!(_mxc_spi_req_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_mxc_spi_req_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_mxc_spi_req_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spi) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mxc_spi_req_t),
            "::",
            stringify!(spi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssIdx) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_mxc_spi_req_t),
            "::",
            stringify!(ssIdx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ssDeassert) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_mxc_spi_req_t),
            "::",
            stringify!(ssDeassert)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).txData) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_mxc_spi_req_t),
            "::",
            stringify!(txData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rxData) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_mxc_spi_req_t),
            "::",
            stringify!(rxData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).txLen) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_mxc_spi_req_t),
            "::",
            stringify!(txLen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rxLen) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_mxc_spi_req_t),
            "::",
            stringify!(rxLen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).txCnt) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_mxc_spi_req_t),
            "::",
            stringify!(txCnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rxCnt) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_mxc_spi_req_t),
            "::",
            stringify!(rxCnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).completeCB) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_mxc_spi_req_t),
            "::",
            stringify!(completeCB)
        )
    );
}
extern "C" {
    #[doc = " @brief   Initialize and enable SPI peripheral.\n\n This function initializes everything necessary to call a SPI transaction function.\n Some parameters are set to defaults as follows:\n SPI Mode - 0\n SPI Width - SPI_WIDTH_STANDARD (even if quadModeUsed is set)\n\n These parameters can be modified after initialization using low level functions\n\n @param   spi             Pointer to SPI registers (selects the SPI block used.)\n @param   masterMode      Whether to put the device in master or slave mode. Use\n                          non-zero for master mode, and zero for slave mode.\n @param   quadModeUsed    Whether to obtain control of the SDIO2/3 pins. Use\n                          non-zero if the pins are needed (if Quad Mode will\n                          be used), and zero if they are not needed (quad mode\n                          will never be used).\n @param   numSlaves       The number of slaves used, if in master mode. This\n                          is used to obtain control of the necessary SS pins.\n                          In slave mode this is ignored and SS1 is used.\n @param   ssPolarity      This field sets the SS active polarity for each\n                          slave, each bit position corresponds to each SS line.\n @param   hz              The requested clock frequency. The actual clock frequency\n                          will be returned by the function if successful. Used in\n                          master mode only.\n @param   pins            SPI pin structure. Pins selected as true will be initialized\n                          for the requested SPI block.\n\n @return  If successful, the actual clock frequency is returned. Otherwise, see\n          \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_SPI_Init(
        spi: *mut mxc_spi_regs_t,
        masterMode: ::core::ffi::c_int,
        quadModeUsed: ::core::ffi::c_int,
        numSlaves: ::core::ffi::c_int,
        ssPolarity: ::core::ffi::c_uint,
        hz: ::core::ffi::c_uint,
        pins: mxc_spi_pins_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Disable and shutdown SPI peripheral.\n\n @param   spi         Pointer to SPI registers (selects the SPI block used.)\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_SPI_Shutdown(spi: *mut mxc_spi_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Checks if the given SPI bus can be placed in sleep mode.\n\n This functions checks to see if there are any on-going SPI transactions in\n progress. If there are transactions in progress, the application should\n wait until the SPI bus is free before entering a low-power state.\n\n @param   spi         Pointer to SPI registers (selects the SPI block used.)\n\n @return  #E_NO_ERROR if ready, and non-zero if busy or error. See \\ref\n          MXC_Error_Codes for the list of error return codes."]
    pub fn MXC_SPI_ReadyForSleep(spi: *mut mxc_spi_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Returns the frequency of the clock used as the bit rate generator for a given SPI instance.\n\n @param   spi         Pointer to SPI registers (selects the SPI block used.)\n\n @return  Frequency of the clock used as the bit rate generator"]
    pub fn MXC_SPI_GetPeripheralClock(spi: *mut mxc_spi_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Set the frequency of the SPI interface.\n\n This function is applicable in Master mode only\n\n @param   spi         Pointer to SPI registers (selects the SPI block used.)\n @param   hz          The desired frequency in Hertz.\n\n @return  Negative if error, otherwise actual speed set. See \\ref\n          MXC_Error_Codes for the list of error return codes."]
    pub fn MXC_SPI_SetFrequency(
        spi: *mut mxc_spi_regs_t,
        hz: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Get the frequency of the SPI interface.\n\n This function is applicable in Master mode only\n\n @param   spi         Pointer to SPI registers (selects the SPI block used.)\n\n @return  The SPI bus frequency in Hertz"]
    pub fn MXC_SPI_GetFrequency(spi: *mut mxc_spi_regs_t) -> ::core::ffi::c_uint;
}
extern "C" {
    #[doc = " @brief   Sets the number of bits per character\n\n @param   spi         Pointer to SPI registers (selects the SPI block used.)\n @param   dataSize    The number of bits per character\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_SPI_SetDataSize(
        spi: *mut mxc_spi_regs_t,
        dataSize: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Gets the number of bits per character\n\n @param   spi         Pointer to SPI registers (selects the SPI block used.)\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_SPI_GetDataSize(spi: *mut mxc_spi_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Sets the slave select (SS) line used for transmissions\n\n This function is applicable in Master mode only\n\n @param   spi         Pointer to SPI registers (selects the SPI block used.)\n @param   ssIdx       Slave select index\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_SPI_SetSlave(
        spi: *mut mxc_spi_regs_t,
        ssIdx: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Gets the slave select (SS) line used for transmissions\n\n This function is applicable in Master mode only\n\n @param   spi         Pointer to SPI registers (selects the SPI block used.)\n\n @return  slave slect"]
    pub fn MXC_SPI_GetSlave(spi: *mut mxc_spi_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Sets the SPI width used for transmissions\n\n @param   spi         Pointer to SPI registers (selects the SPI block used.)\n @param   spiWidth    SPI Width (3-Wire, Standard, Dual SPI, Quad SPI)\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_SPI_SetWidth(
        spi: *mut mxc_spi_regs_t,
        spiWidth: mxc_spi_width_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Gets the SPI width used for transmissions\n\n @param   spi         Pointer to SPI registers (selects the SPI block used.)\n\n @return  Spi Width"]
    pub fn MXC_SPI_GetWidth(spi: *mut mxc_spi_regs_t) -> mxc_spi_width_t;
}
extern "C" {
    #[doc = " @brief   Sets the spi mode using clock polarity and clock phase\n\n @param spi           Pointer to SPI registers (selects the SPI block used.)\n @param spiMode       \\ref mxc_spi_mode_t\n\n @return Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_SPI_SetMode(spi: *mut mxc_spi_regs_t, spiMode: mxc_spi_mode_t)
        -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Gets the spi mode\n\n @param spi           Pointer to SPI registers (selects the SPI block used.)\n\n @return mxc_spi_mode_t   \\ref mxc_spi_mode_t"]
    pub fn MXC_SPI_GetMode(spi: *mut mxc_spi_regs_t) -> mxc_spi_mode_t;
}
extern "C" {
    #[doc = " @brief   Starts a SPI Transmission\n\n This function is applicable in Master mode only\n\n The user must ensure that there are no ongoing transmissions before\n calling this function\n\n @param   spi         Pointer to SPI registers (selects the SPI block used.)\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_SPI_StartTransmission(spi: *mut mxc_spi_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Checks the SPI Peripheral for an ongoing transmission\n\n This function is applicable in Master mode only\n\n @param   spi         Pointer to SPI registers (selects the SPI block used.)\n\n @return  Active/Inactive, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_SPI_GetActive(spi: *mut mxc_spi_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Aborts an ongoing SPI Transmission\n\n This function is applicable in Master mode only\n\n @param   spi         Pointer to SPI registers (selects the SPI block used.)\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_SPI_AbortTransmission(spi: *mut mxc_spi_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Unloads bytes from the receive FIFO.\n\n @param   spi         Pointer to SPI registers (selects the SPI block used.)\n @param   bytes       The buffer to read the data into.\n @param   len         The number of bytes to read.\n\n @return  The number of bytes actually read."]
    pub fn MXC_SPI_ReadRXFIFO(
        spi: *mut mxc_spi_regs_t,
        bytes: *mut ::core::ffi::c_uchar,
        len: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    #[doc = " @brief   Get the number of bytes currently available in the receive FIFO.\n\n @param   spi         Pointer to SPI registers (selects the SPI block used.)\n\n @return  The number of bytes available."]
    pub fn MXC_SPI_GetRXFIFOAvailable(spi: *mut mxc_spi_regs_t) -> ::core::ffi::c_uint;
}
extern "C" {
    #[doc = " @brief   Loads bytes into the transmit FIFO.\n\n @param   spi         Pointer to SPI registers (selects the SPI block used.)\n @param   bytes       The buffer containing the bytes to write\n @param   len         The number of bytes to write.\n\n @return  The number of bytes actually written."]
    pub fn MXC_SPI_WriteTXFIFO(
        spi: *mut mxc_spi_regs_t,
        bytes: *mut ::core::ffi::c_uchar,
        len: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    #[doc = " @brief   Get the amount of free space available in the transmit FIFO.\n\n @param   spi         Pointer to SPI registers (selects the SPI block used.)\n\n @return  The number of bytes available."]
    pub fn MXC_SPI_GetTXFIFOAvailable(spi: *mut mxc_spi_regs_t) -> ::core::ffi::c_uint;
}
extern "C" {
    #[doc = " @brief   Removes and discards all bytes currently in the receive FIFO.\n\n @param   spi         Pointer to SPI registers (selects the SPI block used.)"]
    pub fn MXC_SPI_ClearRXFIFO(spi: *mut mxc_spi_regs_t);
}
extern "C" {
    #[doc = " @brief   Removes and discards all bytes currently in the transmit FIFO.\n\n @param   spi         Pointer to SPI registers (selects the SPI block used.)"]
    pub fn MXC_SPI_ClearTXFIFO(spi: *mut mxc_spi_regs_t);
}
extern "C" {
    #[doc = " @brief   Set the receive threshold level.\n\n RX FIFO Receive threshold. Smaller values will cause\n interrupts to occur more often, but reduce the possibility\n of losing data because of a FIFO overflow. Larger values\n will reduce the time required by the ISR, but increase the\n possibility of data loss. Passing an invalid value will\n cause the driver to use the value already set in the\n appropriate register.\n\n @param   spi         Pointer to SPI registers (selects the SPI block used.)\n @param   numBytes    The threshold level to set. This value must be\n                      between 0 and 8 inclusive.\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_SPI_SetRXThreshold(
        spi: *mut mxc_spi_regs_t,
        numBytes: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Get the current receive threshold level.\n\n @param   spi         Pointer to SPI registers (selects the SPI block used.)\n\n @return  The receive threshold value (in bytes)."]
    pub fn MXC_SPI_GetRXThreshold(spi: *mut mxc_spi_regs_t) -> ::core::ffi::c_uint;
}
extern "C" {
    #[doc = " @brief   Set the transmit threshold level.\n\n TX FIFO threshold. Smaller values will cause interrupts\n to occur more often, but reduce the possibility of terminating\n a transaction early in master mode, or transmitting invalid data\n in slave mode. Larger values will reduce the time required by\n the ISR, but increase the possibility errors occurring. Passing\n an invalid value will cause the driver to use the value already\n set in the appropriate register.\n\n @param   spi         Pointer to SPI registers (selects the SPI block used.)\n @param   numBytes    The threshold level to set.  This value must be\n                      between 0 and 8 inclusive.\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_SPI_SetTXThreshold(
        spi: *mut mxc_spi_regs_t,
        numBytes: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Get the current transmit threshold level.\n\n @param   spi         Pointer to SPI registers (selects the SPI block used.)\n\n @return  The transmit threshold value (in bytes)."]
    pub fn MXC_SPI_GetTXThreshold(spi: *mut mxc_spi_regs_t) -> ::core::ffi::c_uint;
}
extern "C" {
    #[doc = " @brief   Gets the interrupt flags that are currently set\n\n These functions should not be used while using non-blocking Transaction Level\n functions (Async or DMA)\n\n @param   spi         Pointer to SPI registers (selects the SPI block used.)\n\n @return The interrupt flags"]
    pub fn MXC_SPI_GetFlags(spi: *mut mxc_spi_regs_t) -> ::core::ffi::c_uint;
}
extern "C" {
    #[doc = " @brief   Clears the interrupt flags that are currently set\n\n These functions should not be used while using non-blocking Transaction Level\n functions (Async or DMA)\n\n @param   spi         Pointer to SPI registers (selects the SPI block used.)\n"]
    pub fn MXC_SPI_ClearFlags(spi: *mut mxc_spi_regs_t);
}
extern "C" {
    #[doc = " @brief   Enables specific interrupts\n\n These functions should not be used while using non-blocking Transaction Level\n functions (Async or DMA)\n\n @param   spi         Pointer to SPI registers (selects the SPI block used.)\n @param   intEn       The interrupts to be enabled"]
    pub fn MXC_SPI_EnableInt(spi: *mut mxc_spi_regs_t, intEn: ::core::ffi::c_uint);
}
extern "C" {
    #[doc = " @brief   Disables specific interrupts\n\n These functions should not be used while using non-blocking Transaction Level\n functions (Async or DMA)\n\n @param   spi         Pointer to SPI registers (selects the SPI block used.)\n @param   intDis      The interrupts to be disabled"]
    pub fn MXC_SPI_DisableInt(spi: *mut mxc_spi_regs_t, intDis: ::core::ffi::c_uint);
}
extern "C" {
    #[doc = " @brief   Performs a blocking SPI transaction.\n\n Performs a blocking SPI transaction.\n These actions will be performed in Master Mode:\n 1. Assert the specified SS\n 2. In Full Duplex Modes, send TX data while receiving RX Data\n      if rxLen > txLen, pad txData with DefaultTXData\n      if txLen > rxLen, discard rxData where rxCnt > rxLen\n 3. In Half Duplex Modes, send TX Data, then receive RX Data\n 4. Deassert the specified SS\n\n These actions will be performed in Slave Mode:\n 1. Fill FIFO with txData\n 2. Wait for SS Assert\n 3. If needed, pad txData with DefaultTXData\n 4. Unload RX FIFO as needed\n 5. On SS Deassert, return\n\n @param   req         Pointer to details of the transaction\n\n @return  See \\ref MXC_Error_Codes for the list of error return codes."]
    pub fn MXC_SPI_MasterTransaction(req: *mut mxc_spi_req_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Setup an interrupt-driven SPI transaction\n\n The TX FIFO will be filled with txData, padded with DefaultTXData if necessary\n Relevant interrupts will be enabled, and relevant registers set (SS, Width, etc)\n\n @param   req         Pointer to details of the transaction\n\n @return  See \\ref MXC_Error_Codes for the list of error return codes."]
    pub fn MXC_SPI_MasterTransactionAsync(req: *mut mxc_spi_req_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Setup a DMA driven SPI transaction\n\n The TX FIFO will be filled with txData, padded with DefaultTXData if necessary\n Relevant interrupts will be enabled, and relevant registers set (SS, Width, etc)\n\n The lowest-indexed unused DMA channel will be acquired (using the DMA API) and\n set up to load/unload the FIFOs with as few interrupt-based events as\n possible. The channel will be reset and returned to the system at the end of\n the transaction.\n\n @param   req             Pointer to details of the transaction\n\n @return  See \\ref MXC_Error_Codes for the list of error return codes."]
    pub fn MXC_SPI_MasterTransactionDMA(req: *mut mxc_spi_req_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Performs a blocking SPI transaction.\n\n Performs a blocking SPI transaction.\n These actions will be performed in Slave Mode:\n 1. Fill FIFO with txData\n 2. Wait for SS Assert\n 3. If needed, pad txData with DefaultTXData\n 4. Unload RX FIFO as needed\n 5. On SS Deassert, return\n\n @param   req         Pointer to details of the transaction\n\n @return  See \\ref MXC_Error_Codes for the list of error return codes."]
    pub fn MXC_SPI_SlaveTransaction(req: *mut mxc_spi_req_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Setup an interrupt-driven SPI transaction\n\n The TX FIFO will be filled with txData, padded with DefaultTXData if necessary\n Relevant interrupts will be enabled, and relevant registers set (SS, Width, etc)\n\n @param   req         Pointer to details of the transactionz\n\n @return  See \\ref MXC_Error_Codes for the list of error return codes."]
    pub fn MXC_SPI_SlaveTransactionAsync(req: *mut mxc_spi_req_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Setup a DMA driven SPI transaction\n\n The TX FIFO will be filled with txData, padded with DefaultTXData if necessary\n Relevant interrupts will be enabled, and relevant registers set (SS, Width, etc)\n\n The lowest-indexed unused DMA channel will be acquired (using the DMA API) and\n set up to load/unload the FIFOs with as few interrupt-based events as\n possible. The channel will be reset and returned to the system at the end of\n the transaction.\n\n @param   req             Pointer to details of the transaction\n\n @return  See \\ref MXC_Error_Codes for the list of error return codes."]
    pub fn MXC_SPI_SlaveTransactionDMA(req: *mut mxc_spi_req_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Sets the TX data to transmit as a 'dummy' byte\n\n In single wire master mode, this data is transmitted on MOSI when performing\n an RX (MISO) only transaction. This defaults to 0.\n\n @param   spi             Pointer to SPI registers (selects the SPI block used.)\n @param   defaultTXData   Data to shift out in RX-only transactions\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_SPI_SetDefaultTXData(
        spi: *mut mxc_spi_regs_t,
        defaultTXData: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Abort any asynchronous requests in progress.\n\n Abort any asynchronous requests in progress. Any callbacks associated with\n the active transaction will be executed to indicate when the transaction\n has been terminated.\n\n @param   spi         Pointer to SPI registers (selects the SPI block used.)"]
    pub fn MXC_SPI_AbortAsync(spi: *mut mxc_spi_regs_t);
}
extern "C" {
    #[doc = " @brief   The processing function for asynchronous transactions.\n\n When using the asynchronous functions, the application must call this\n function periodically. This can be done from within the SPI interrupt\n handler or periodically by the application if SPI interrupts are disabled.\n\n @param   spi         Pointer to SPI registers (selects the SPI block used.)"]
    pub fn MXC_SPI_AsyncHandler(spi: *mut mxc_spi_regs_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct area_t {
    pub x: u16,
    pub y: u16,
    pub w: u16,
    pub h: u16,
}
#[test]
fn bindgen_test_layout_area_t() {
    const UNINIT: ::core::mem::MaybeUninit<area_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<area_t>(),
        8usize,
        concat!("Size of: ", stringify!(area_t))
    );
    assert_eq!(
        ::core::mem::align_of::<area_t>(),
        2usize,
        concat!("Alignment of ", stringify!(area_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(area_t), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        2usize,
        concat!("Offset of field: ", stringify!(area_t), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(area_t), "::", stringify!(w))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        6usize,
        concat!("Offset of field: ", stringify!(area_t), "::", stringify!(h))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct text_t {
    pub data: *mut ::core::ffi::c_char,
    pub len: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_text_t() {
    const UNINIT: ::core::mem::MaybeUninit<text_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<text_t>(),
        8usize,
        concat!("Size of: ", stringify!(text_t))
    );
    assert_eq!(
        ::core::mem::align_of::<text_t>(),
        4usize,
        concat!("Alignment of ", stringify!(text_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(text_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(text_t),
            "::",
            stringify!(len)
        )
    );
}
pub const tft_rotation_t_ROTATE_0: tft_rotation_t = 0;
pub const tft_rotation_t_ROTATE_90: tft_rotation_t = 1;
pub const tft_rotation_t_ROTATE_180: tft_rotation_t = 2;
pub const tft_rotation_t_ROTATE_270: tft_rotation_t = 3;
pub type tft_rotation_t = ::core::ffi::c_uint;
extern "C" {
    pub static img_1_rgb565: [::core::ffi::c_uchar; 0usize];
}
extern "C" {
    pub static img_2_rgb565: [::core::ffi::c_uchar; 0usize];
}
extern "C" {
    pub static img_3_rgb565: [::core::ffi::c_uchar; 0usize];
}
extern "C" {
    pub static img_4_rgb565: [::core::ffi::c_uchar; 0usize];
}
extern "C" {
    pub static image_pattern_rgb565: [::core::ffi::c_uchar; 0usize];
}
extern "C" {
    pub static logo_rgb565: [::core::ffi::c_uchar; 0usize];
}
extern "C" {
    pub static Arial12x12: [::core::ffi::c_uchar; 0usize];
}
extern "C" {
    pub static Arial24x23: [::core::ffi::c_uchar; 0usize];
}
extern "C" {
    pub static Arial28x28: [::core::ffi::c_uchar; 0usize];
}
extern "C" {
    pub static SansSerif19x19: [::core::ffi::c_uchar; 0usize];
}
extern "C" {
    pub static SansSerif16x16: [::core::ffi::c_uchar; 0usize];
}
extern "C" {
    #[doc = " @brief      Initialize the TFT display\n\n @param      tft_spi          The SPI instance the TFT is connected to\n @param      ss_idx           The SSEL index to use when communicating with the attached TFT\n @param      reset_ctrl       The GPIO pin configuration for the TFT's reset pin.  Use NULL if\n                              the reset pin of the TFT is not connected to the microcontroller.\n @param      bl_ctrl          The GPIO pin configuration for the backlight enable pin.  Use NULL if\n                              the microcontroller does not have control of the backlight enable.\n\n @return     See \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_TFT_Init(
        tft_spi: *mut mxc_spi_regs_t,
        ss_idx: ::core::ffi::c_int,
        reset_ctrl: *mut mxc_gpio_cfg_t,
        bl_ctrl: *mut mxc_gpio_cfg_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Turns backlight on or off\n\n @param      on           Zero to turn off, nonzero for on"]
    pub fn MXC_TFT_Backlight(on: ::core::ffi::c_int);
}
extern "C" {
    #[doc = " @brief      Fills screen with background color\n"]
    pub fn MXC_TFT_ClearScreen();
}
extern "C" {
    #[doc = " @brief      Draw and fill a rectangle\n\n @param      area   Location and size of rectangle\n @param      color  Palette index of rectangle color"]
    pub fn MXC_TFT_FillRect(area: *mut area_t, color: ::core::ffi::c_int);
}
extern "C" {
    #[doc = " @brief      Write a Pixel on TFT display\n\n @param      pixelX           x location of image\n @param      pixelY           y location of image\n @param      width            width of pixel\n @param      height           height of pixel\n @param      color            RGB value of image"]
    pub fn MXC_TFT_WritePixel(
        pixelX: ::core::ffi::c_int,
        pixelY: ::core::ffi::c_int,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
        color: u32,
    );
}
extern "C" {
    #[doc = " @brief      Draw a bitmap\n\n @param      x0           x location of image\n @param      y0           y location of image\n @param      id           Bitmap number (pointer)"]
    pub fn MXC_TFT_ShowImage(
        x0: ::core::ffi::c_int,
        y0: ::core::ffi::c_int,
        id: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " @brief      Draw a RGB565 buffer to a window location\n\n @param      x0           x location of image\n @param      y0           y location of image\n @param      image        RGB565 image buffer (pointer)\n @param      width        image width\n @param      height       image height"]
    pub fn MXC_TFT_WriteBufferRGB565(
        x0: ::core::ffi::c_int,
        y0: ::core::ffi::c_int,
        image: *mut u8,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " @brief      Display captured RGB565 image on TFT\n\n @param      x0           x location of image\n @param      y0           y location of image\n @param      image        RGB565 image (pointer)\n @param      iWidth       image width\n @param      iHeight      image height"]
    pub fn MXC_TFT_ShowImageCameraRGB565(
        x0: ::core::ffi::c_int,
        y0: ::core::ffi::c_int,
        image: *mut u8,
        iWidth: ::core::ffi::c_int,
        iHeight: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " @brief      Fills screen with one color\n\n @param      index_color  index of screen color"]
    pub fn MXC_TFT_SetBackGroundColor(index_color: ::core::ffi::c_uint);
}
extern "C" {
    pub fn MXC_TFT_SetForeGroundColor(color: ::core::ffi::c_uint);
}
extern "C" {
    #[doc = " @brief      Set palette\n\n @param      img_id  Image number to get palette info"]
    pub fn MXC_TFT_SetPalette(img_id: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Set bounds of printf\n\n @param      area   Location of printf outputs"]
    pub fn MXC_TFT_ConfigPrintf(area: *mut area_t);
}
extern "C" {
    #[doc = " @brief       Change font\n\n @param       font_id         Font id"]
    pub fn MXC_TFT_SetFont(font_id: ::core::ffi::c_int);
}
extern "C" {
    #[doc = " @brief      Printf out to display\n\n @param      format  Char array formatted like printf\n             NOTE: up to 3 additional arguments are supported"]
    pub fn MXC_TFT_Printf(format: *const ::core::ffi::c_char, ...);
}
extern "C" {
    #[doc = " @brief      Reset cursor to top left corner of printf bounds\n"]
    pub fn MXC_TFT_ResetCursor();
}
extern "C" {
    #[doc = " @brief      Print string with selected font\n\n @param       x0              x location on screen\n @param       y0              y location on screen\n @param       fon_id          Font number\n @param       str             String which will be display\n @param       area            Location of printf outputs"]
    pub fn MXC_TFT_PrintFont(
        x0: ::core::ffi::c_int,
        y0: ::core::ffi::c_int,
        font_id: ::core::ffi::c_int,
        str_: *mut text_t,
        area: *mut area_t,
    );
}
extern "C" {
    #[doc = " @brief      Print string with current font\n\n @param       x0              x location on screen\n @param       y0              y location on screen\n @param       fon_id          Font number\n @param       str             String which will be display\n @param       area            Location of printf outputs"]
    pub fn MXC_TFT_Print(
        x0: ::core::ffi::c_int,
        y0: ::core::ffi::c_int,
        str_: *mut text_t,
        area: *mut area_t,
    );
}
extern "C" {
    #[doc = " @brief       Clear area on display\n\n @param       area            Location on display\n @param       color           Palette index of rectangle color"]
    pub fn MXC_TFT_ClearArea(area: *mut area_t, color: ::core::ffi::c_int);
}
extern "C" {
    #[doc = " @brief       Set TFT screen rotation\n\n @param       rotation        Rotation of the screen"]
    pub fn MXC_TFT_SetRotation(rotation: tft_rotation_t);
}
extern "C" {
    #[doc = " @brief       Write Screen Register\n\n @param       command        command or register address\n @param       data           data for the command or register"]
    pub fn MXC_TFT_WriteReg(command: ::core::ffi::c_uchar, data: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " @brief      Draw a circle with specified color\n\n @param       x0              x location on screen\n @param       y0              y location on screen\n @param       r               circle radius\n @param       color           circle color"]
    pub fn MXC_TFT_Circle(
        x0: ::core::ffi::c_int,
        y0: ::core::ffi::c_int,
        r: ::core::ffi::c_int,
        color: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " @brief      Fill a circle with specified color\n\n @param       x0              x location on screen\n @param       y0              y location on screen\n @param       r               circle radius\n @param       color           circle color"]
    pub fn MXC_TFT_FillCircle(
        x0: ::core::ffi::c_int,
        y0: ::core::ffi::c_int,
        r: ::core::ffi::c_int,
        color: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " @brief      Draw a line with specified color\n\n @param       x0              x start location on screen\n @param       y0              y start location on screen\n @param       x1              x end location on screen\n @param       y1              y end location on screen\n @param       color           line color"]
    pub fn MXC_TFT_Line(
        x0: ::core::ffi::c_int,
        y0: ::core::ffi::c_int,
        x1: ::core::ffi::c_int,
        y1: ::core::ffi::c_int,
        color: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " @brief      Draw a rectangle with specified color\n\n @param       x0              x start location on screen\n @param       y0              y start location on screen\n @param       x1              x end location on screen\n @param       y1              y end location on screen\n @param       color           rectangle color"]
    pub fn MXC_TFT_Rectangle(
        x0: ::core::ffi::c_int,
        y0: ::core::ffi::c_int,
        x1: ::core::ffi::c_int,
        y1: ::core::ffi::c_int,
        color: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " @brief      Stream camera to TFT (feather only)\n\n @param      x0           x location of image\n @param      y0           y location of image\n @param      width        image width\n @param      height       image height"]
    pub fn MXC_TFT_Stream(
        x0: ::core::ffi::c_int,
        y0: ::core::ffi::c_int,
        width: ::core::ffi::c_int,
        height: ::core::ffi::c_int,
    );
}
pub const mxc_ts_touch_cmd_t_TSC_TEMP0: mxc_ts_touch_cmd_t = 131;
pub const mxc_ts_touch_cmd_t_TSC_Y: mxc_ts_touch_cmd_t = 151;
pub const mxc_ts_touch_cmd_t_TSC_VBAT: mxc_ts_touch_cmd_t = 163;
pub const mxc_ts_touch_cmd_t_TSC_Z1: mxc_ts_touch_cmd_t = 183;
pub const mxc_ts_touch_cmd_t_TSC_Z2: mxc_ts_touch_cmd_t = 199;
pub const mxc_ts_touch_cmd_t_TSC_X: mxc_ts_touch_cmd_t = 215;
pub const mxc_ts_touch_cmd_t_TSC_AUX: mxc_ts_touch_cmd_t = 227;
pub const mxc_ts_touch_cmd_t_TSC_TEMP1: mxc_ts_touch_cmd_t = 243;
pub const mxc_ts_touch_cmd_t_TSC_DIFFX: mxc_ts_touch_cmd_t = 209;
pub const mxc_ts_touch_cmd_t_TSC_DIFFY: mxc_ts_touch_cmd_t = 145;
pub const mxc_ts_touch_cmd_t_TSC_DIFFZ1: mxc_ts_touch_cmd_t = 177;
pub const mxc_ts_touch_cmd_t_TSC_DIFFZ2: mxc_ts_touch_cmd_t = 193;
pub const mxc_ts_touch_cmd_t_TSC_START: mxc_ts_touch_cmd_t = 130;
pub const mxc_ts_touch_cmd_t_TSC_STOP: mxc_ts_touch_cmd_t = 129;
pub type mxc_ts_touch_cmd_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mxc_ts_spi_config {
    pub regs: *mut mxc_spi_regs_t,
    pub gpio: mxc_gpio_cfg_t,
    pub freq: ::core::ffi::c_uint,
    pub ss_idx: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_mxc_ts_spi_config() {
    const UNINIT: ::core::mem::MaybeUninit<mxc_ts_spi_config> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mxc_ts_spi_config>(),
        32usize,
        concat!("Size of: ", stringify!(mxc_ts_spi_config))
    );
    assert_eq!(
        ::core::mem::align_of::<mxc_ts_spi_config>(),
        4usize,
        concat!("Alignment of ", stringify!(mxc_ts_spi_config))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).regs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_ts_spi_config),
            "::",
            stringify!(regs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gpio) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_ts_spi_config),
            "::",
            stringify!(gpio)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).freq) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_ts_spi_config),
            "::",
            stringify!(freq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ss_idx) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_ts_spi_config),
            "::",
            stringify!(ss_idx)
        )
    );
}
extern "C" {
    #[doc = " @brief       Initialize the SPI instance connected to the TouchScreen driver.\n              Board files must implement this."]
    pub fn TS_SPI_Init();
}
extern "C" {
    #[doc = " @brief       Send a byte of data to the TouchScreen driver over SPI.\n              Board files must implement this.\n\n @param       datain      Input value to write\n @param[out]  dataout     Output pointer.  This function will decode and save\n                          the SPI response to this pointer."]
    pub fn TS_SPI_Transmit(datain: u8, dataout: *mut u16);
}
extern "C" {
    pub fn MXC_TS_AssignInterruptPin(pin: mxc_gpio_cfg_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Used to register hw related configuration, need to be called before MXC_TS_Init()\n\n @param      spi_config   Touch screen SPI configuration, SPI instance, freq, pins slave slect id\n @param      int_pin      The GPIO pin configuration for the touchscreen controller's interrupt pin\n @param      busy_pin     The GPIO pin configuration for the touchscreen controller's busy pin\n\n @return     See \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_TS_PreInit(
        spi_config: *mut mxc_ts_spi_config,
        int_pin: *mut mxc_gpio_cfg_t,
        busy_pin: *mut mxc_gpio_cfg_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Initialize the touchscreen controller\n\n @return     See \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_TS_Init() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Enables touch interrupts\n"]
    pub fn MXC_TS_Start();
}
extern "C" {
    #[doc = " @brief      Disables touch interrupts\n"]
    pub fn MXC_TS_Stop();
}
extern "C" {
    #[doc = " @brief      Get the x,y coordinates of the last touchscreen press\n\n @param[out] x    (Output) Where to save the x coordinate\n @param[out] y    (Output) Where to save the y coordinate"]
    pub fn MXC_TS_GetXY(x: *mut ::core::ffi::c_uint, y: *mut ::core::ffi::c_uint);
}
extern "C" {
    #[doc = " @brief       Returns true if there is a touchscreen event pending,\n              otherwise returns false."]
    pub fn MXC_TS_GetTSEvent() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Clears the pending touchscreen event flag."]
    pub fn MXC_TS_ClearTSEvent();
}
extern "C" {
    #[doc = " @brief      Register a button\n\n @param      x0, y0, x1, y1 location of button\n @param      on_press_expected_code  expected keycode when touch related point area"]
    pub fn MXC_TS_AddButton(
        x0: ::core::ffi::c_int,
        y0: ::core::ffi::c_int,
        x1: ::core::ffi::c_int,
        y1: ::core::ffi::c_int,
        on_press_expected_code: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Remove a button\n\n @param      x0, y0, x1, y1 location of button"]
    pub fn MXC_TS_RemoveButton(
        x0: ::core::ffi::c_int,
        y0: ::core::ffi::c_int,
        x1: ::core::ffi::c_int,
        y1: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " @brief      Remove all registered keys\n"]
    pub fn MXC_TS_RemoveAllButton();
}
extern "C" {
    #[doc = " @brief      Read pressed key\n"]
    pub fn MXC_TS_GetKey() -> ::core::ffi::c_int;
}
extern "C" {
    pub static led_pin: [mxc_gpio_cfg_t; 0usize];
}
extern "C" {
    pub static num_leds: ::core::ffi::c_uint;
}
extern "C" {
    #[doc = " @brief      Initialize all LED pins.\n @retval     #E_NO_ERROR   Push buttons intialized successfully.\n @retval     \"Error Code\"  @ref MXC_Error_Codes \"Error Code\" if unsuccessful."]
    pub fn LED_Init() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Turn the specified LED on\n @param      idx   LED index\n\n @note Some board files have defines for 'idx' that match the silk screen on the board (e.g., LED1, LED2, etc.)."]
    pub fn LED_On(idx: ::core::ffi::c_uint);
}
extern "C" {
    #[doc = " @brief      Turn the specified LED off.\n @param      idx   LED index\n\n @note Some board files have defines for 'idx' that match the silk screen on the board (e.g., LED1, LED2, etc.)."]
    pub fn LED_Off(idx: ::core::ffi::c_uint);
}
extern "C" {
    #[doc = " @brief      Toggle the state of the specified LED.\n @param      idx   LED index\n\n @note Some board files have defines for 'idx' that match the silk screen on the board (e.g., LED1, LED2, etc.)."]
    pub fn LED_Toggle(idx: ::core::ffi::c_uint);
}
extern "C" {
    #[doc = " @ingroup bsp\n @defgroup pushbutton_evkit Push button driver board support\n @{"]
    pub static pb_pin: [mxc_gpio_cfg_t; 0usize];
}
extern "C" {
    pub static num_pbs: ::core::ffi::c_uint;
}
extern "C" {
    #[doc = " @brief      Initialize all push buttons.\n @retval     #E_NO_ERROR  Push buttons intialized successfully.\n @retval     \"Error Code\" @ref MXC_Error_Codes \"Error Code\" if unsuccessful.\n"]
    pub fn PB_Init() -> ::core::ffi::c_int;
}
#[doc = " Type alias @c pb_callback for the push button callback.\n @details The function is of type:\n @code\n  void pb_callback(void * pb)\n @endcode\n To recieve notification of a push button event, define a callback\n function and pass it as a pointer to the PB_RegisterCallback(unsigned int pb, pb_callback callback) function.\n @param      pb    Pointer to the push button index that triggered the\n                   callback."]
pub type pb_callback = ::core::option::Option<unsafe extern "C" fn(pb: *mut ::core::ffi::c_void)>;
extern "C" {
    #[doc = " @brief      Register or Unregister a callback handler for falling edge events on the @p pb push button.\n @details\n - Calling this function with a pointer to a function @p callback, configures the pushbutton @p pb and enables the\n interrupt to handle the push button events.\n - Calling this function with a <tt>NULL</tt> pointer will disable the interrupt and unregister the\n callback function.\n @p pb must be a value between 0 and #num_pbs.\n\n @param      pb        push button index to receive event callbacks.\n @param      callback  Callback function pointer of type @c pb_callback\n @retval     #E_NO_ERROR if configured and callback registered successfully.\n @retval     \"Error Code\" @ref MXC_Error_Codes \"Error Code\" if unsuccessful."]
    pub fn PB_RegisterCallback(
        pb: ::core::ffi::c_uint,
        callback: pb_callback,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Register or Unregister a callback handler for BOTH RISING AND FALLING edges events on the @p pb push button.\n @details\n - Calling this function with a pointer to a function @p callback, configures the pushbutton @p pb and enables the\n interrupt to handle the push button events.\n - Calling this function with a <tt>NULL</tt> pointer will disable the interrupt and unregister the\n callback function.\n @p pb must be a value between 0 and #num_pbs.\n\n @param      pb        push button index to receive event callbacks.\n @param      callback  Callback function pointer of type @c pb_callback\n @retval     #E_NO_ERROR if configured and callback registered successfully.\n @retval     \"Error Code\" @ref MXC_Error_Codes \"Error Code\" if unsuccessful."]
    pub fn PB_RegisterCallbackRiseFall(
        pb: ::core::ffi::c_uint,
        callback: pb_callback,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Enable a callback interrupt.\n @note    PB_RegisterCallback must be called prior to enabling the callback interrupt.\n @param   pb          push button index value between 0 and #num_pbs."]
    pub fn PB_IntEnable(pb: ::core::ffi::c_uint);
}
extern "C" {
    #[doc = " @brief   Disable a callback interrupt.\n @param   pb          push button index"]
    pub fn PB_IntDisable(pb: ::core::ffi::c_uint);
}
extern "C" {
    #[doc = " @brief   Clear a callback interrupt.\n @param   pb          push button index value between 0 and #num_pbs."]
    pub fn PB_IntClear(pb: ::core::ffi::c_uint);
}
extern "C" {
    #[doc = " @brief      Get the current state of the push button.\n @param      pb     push button index value between 0 and #num_pbs.\n @retval     TRUE   The button is pressed.\n @retval     FALSE  The button is not pressed."]
    pub fn PB_Get(pb: ::core::ffi::c_uint) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Check if any buttons are pressed\n @retval     TRUE   At least one of the buttons on the board is pressed.\n @retval     FALSE  None of the buttons on the board are pressed."]
    pub fn PB_IsPressedAny() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief   Initialize the BSP and board interfaces.\n \\returns #E_NO_ERROR if everything is successful"]
    pub fn Board_Init() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief   Initialize or reinitialize the console. This may be necessary if the\n          system clock rate is changed.\n \\returns #E_NO_ERROR if everything is successful"]
    pub fn Console_Init() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief   Shutdown the console.\n \\returns #E_NO_ERROR if everything is successful"]
    pub fn Console_Shutdown() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief   Attempt to prepare the console for sleep.\n \\returns #E_NO_ERROR if ready to sleep, #E_BUSY if not ready for sleep."]
    pub fn Console_PrepForSleep() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn Microphone_Power(on: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief   Camera power control.\n\n \\param   on          1 for ON, 0 for OFF\n\n \\return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn Camera_Power(on: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief   SD card power control.\n\n \\param   on          1 for ON, 0 for OFF\n\n \\return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn SD_Power(on: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief   Informs the caller which SPI connections are used for SD card communication\n\n \\param   spi \t\tThe SPI instance used\n \\param   ssPort      The GPIO port used for the SD card's SSEL pin\n \\param   ssPin       The GPIO pin number used for the SD card's SSEL pin\n\n \\return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn SD_Get_Connections(
        spi: *mut *mut mxc_spi_regs_t,
        ssPort: *mut *mut mxc_gpio_regs_t,
        ssPin: *mut ::core::ffi::c_int,
    );
}
#[doc = " @ingroup flc_registers\n Structure type to access the FLC Registers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mxc_flc_regs_t {
    #[doc = "< <tt>\\b 0x00:</tt> FLC ADDR Register"]
    pub addr: u32,
    #[doc = "< <tt>\\b 0x04:</tt> FLC CLKDIV Register"]
    pub clkdiv: u32,
    #[doc = "< <tt>\\b 0x08:</tt> FLC CTRL Register"]
    pub ctrl: u32,
    pub rsv_0xc_0x23: [u32; 6usize],
    #[doc = "< <tt>\\b 0x024:</tt> FLC INTR Register"]
    pub intr: u32,
    #[doc = "< <tt>\\b 0x28:</tt> FLC ECCDATA Register"]
    pub eccdata: u32,
    pub rsv_0x2c: u32,
    #[doc = "< <tt>\\b 0x30:</tt> FLC DATA Register"]
    pub data: [u32; 4usize],
    #[doc = "< <tt>\\b 0x40:</tt> FLC ACTRL Register"]
    pub actrl: u32,
    pub rsv_0x44_0x7f: [u32; 15usize],
    #[doc = "< <tt>\\b 0x80:</tt> FLC WELR0 Register"]
    pub welr0: u32,
    pub rsv_0x84: u32,
    #[doc = "< <tt>\\b 0x88:</tt> FLC WELR1 Register"]
    pub welr1: u32,
    pub rsv_0x8c: u32,
    #[doc = "< <tt>\\b 0x90:</tt> FLC RLR0 Register"]
    pub rlr0: u32,
    pub rsv_0x94: u32,
    #[doc = "< <tt>\\b 0x98:</tt> FLC RLR1 Register"]
    pub rlr1: u32,
}
#[test]
fn bindgen_test_layout_mxc_flc_regs_t() {
    const UNINIT: ::core::mem::MaybeUninit<mxc_flc_regs_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mxc_flc_regs_t>(),
        156usize,
        concat!("Size of: ", stringify!(mxc_flc_regs_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mxc_flc_regs_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mxc_flc_regs_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_flc_regs_t),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clkdiv) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_flc_regs_t),
            "::",
            stringify!(clkdiv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctrl) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_flc_regs_t),
            "::",
            stringify!(ctrl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsv_0xc_0x23) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_flc_regs_t),
            "::",
            stringify!(rsv_0xc_0x23)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).intr) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_flc_regs_t),
            "::",
            stringify!(intr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eccdata) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_flc_regs_t),
            "::",
            stringify!(eccdata)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsv_0x2c) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_flc_regs_t),
            "::",
            stringify!(rsv_0x2c)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_flc_regs_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).actrl) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_flc_regs_t),
            "::",
            stringify!(actrl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsv_0x44_0x7f) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_flc_regs_t),
            "::",
            stringify!(rsv_0x44_0x7f)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).welr0) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_flc_regs_t),
            "::",
            stringify!(welr0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsv_0x84) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_flc_regs_t),
            "::",
            stringify!(rsv_0x84)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).welr1) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_flc_regs_t),
            "::",
            stringify!(welr1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsv_0x8c) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_flc_regs_t),
            "::",
            stringify!(rsv_0x8c)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rlr0) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_flc_regs_t),
            "::",
            stringify!(rlr0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsv_0x94) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_flc_regs_t),
            "::",
            stringify!(rsv_0x94)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rlr1) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_flc_regs_t),
            "::",
            stringify!(rlr1)
        )
    );
}
extern "C" {
    #[doc = " @brief      Initializes the Flash Controller for erase/write operations\n @return     #E_NO_ERROR if successful."]
    pub fn MXC_FLC_Init() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Checks if Flash Controller is busy.\n @details    Reading or executing from flash is not possible if flash is busy\n             with an erase or write operation.\n @return     If non-zero, flash operation is in progress"]
    pub fn MXC_FLC_Busy() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Erases the entire flash array.\n @note       This function must be executed from RAM.\n @return     #E_NO_ERROR If function is successful."]
    pub fn MXC_FLC_MassErase() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Erases the page of flash at the specified address.\n @note       This function must be executed from RAM.\n @param      address  The address of the page in flash to erase.  If the address falls in the middle of a page, the entire page will be erased.\n @return     #E_NO_ERROR If function is successful."]
    pub fn MXC_FLC_PageErase(address: u32) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Read bytes from a flash address.\n @details This function is essentially a wrapper around memcpy.  'buffer' can be a\n pointer to any type, and the data bytes read from this function will attempt\n to be typecast to match 'buffer'.\n\n @param[in]  address  The address to read from\n @param      buffer   The buffer to read the data into\n @param[in]  len      The number of bytes to read from 'address' into 'buffer'.\n"]
    pub fn MXC_FLC_Read(
        address: ::core::ffi::c_int,
        buffer: *mut ::core::ffi::c_void,
        len: ::core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " @brief      Writes data to flash.\n @note       This function must be executed from RAM.\n @param      address  Address in flash to start writing from.\n @param      length   Number of bytes to be written.\n @param      buffer     Pointer to data to be written to flash.\n @return     #E_NO_ERROR If function is successful.\n @note       make sure to disable ICC with ICC_Disable(); before Running this function"]
    pub fn MXC_FLC_Write(address: u32, length: u32, buffer: *mut u32) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Writes 32 bits of data to flash.\n @note       This function must be executed from RAM.\n @param      address  Address in flash to start writing from.\n @param      data     Pointer to data to be written to flash.\n @return     #E_NO_ERROR If function is successful.\n @note       make sure to disable ICC with ICC_Disable(); before Running this function"]
    pub fn MXC_FLC_Write32(address: u32, data: u32) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Writes 128 bits of data to flash.\n @note       This function must be executed from RAM.\n @param      address  Address in flash to start writing from.\n @param      data     Pointer to data to be written to flash.\n @return     #E_NO_ERROR If function is successful.\n @note       make sure to disable ICC with ICC_Disable(); before Running this function"]
    pub fn MXC_FLC_Write128(address: u32, data: *mut u32) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Enable flash interrupts\n @param      flags   Interrupts to enable\n @return     #E_NO_ERROR If function is successful."]
    pub fn MXC_FLC_EnableInt(flags: u32) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Disable flash interrupts\n @param      flags   Interrupts to disable\n @return     #E_NO_ERROR If function is successful."]
    pub fn MXC_FLC_DisableInt(flags: u32) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Retrieve flash interrupt flags\n @return     Interrupt flags registers"]
    pub fn MXC_FLC_GetFlags() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Clear flash interrupt flags\n @note       Provide the bit position to clear, even if the flag is write-0-to-clear\n @param      flags Flag bit(s) to clear\n @return     #E_NO_ERROR If function is successful."]
    pub fn MXC_FLC_ClearFlags(flags: u32) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Unlock info block\n\n @param[in]  address  The address in the info block needing written to\n\n @return     #E_NO_ERROR If function is successful."]
    pub fn MXC_FLC_UnlockInfoBlock(address: u32) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Lock info block\n\n @param[in]  address  The address in the info block that was written to\n @return     #E_NO_ERROR If function is successful."]
    pub fn MXC_FLC_LockInfoBlock(address: u32) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief       Blocks write operations to the flash page associated with the 'address' argument\n @note        Flash pages cannot be unblocked except for on POR and external resets\n\n @param       address     Absolute address located anywhere in the flash page to be locked (does not need to be word-aligned)\n\n @return      #E_NO_ERROR If function is successful."]
    pub fn MXC_FLC_BlockPageWrite(address: u32) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief       Blocks read operations from the flash page associated with the 'address' argument\n @note        Flash pages cannot be unblocked except for on POR and external resets\n\n @param       address     Absolute address located anywhere in the flash page to be locked (does not need to be word-aligned)\n\n @return      #E_NO_ERROR If function is successful."]
    pub fn MXC_FLC_BlockPageRead(address: u32) -> ::core::ffi::c_int;
}
#[doc = " @ingroup i2c_registers\n Structure type to access the I2C Registers."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mxc_i2c_regs_t {
    #[doc = "< <tt>\\b 0x00:</tt> I2C CTRL Register"]
    pub ctrl: u32,
    #[doc = "< <tt>\\b 0x04:</tt> I2C STATUS Register"]
    pub status: u32,
    #[doc = "< <tt>\\b 0x08:</tt> I2C INTFL0 Register"]
    pub intfl0: u32,
    #[doc = "< <tt>\\b 0x0C:</tt> I2C INTEN0 Register"]
    pub inten0: u32,
    #[doc = "< <tt>\\b 0x10:</tt> I2C INTFL1 Register"]
    pub intfl1: u32,
    #[doc = "< <tt>\\b 0x14:</tt> I2C INTEN1 Register"]
    pub inten1: u32,
    #[doc = "< <tt>\\b 0x18:</tt> I2C FIFOLEN Register"]
    pub fifolen: u32,
    #[doc = "< <tt>\\b 0x1C:</tt> I2C RXCTRL0 Register"]
    pub rxctrl0: u32,
    #[doc = "< <tt>\\b 0x20:</tt> I2C RXCTRL1 Register"]
    pub rxctrl1: u32,
    #[doc = "< <tt>\\b 0x24:</tt> I2C TXCTRL0 Register"]
    pub txctrl0: u32,
    #[doc = "< <tt>\\b 0x28:</tt> I2C TXCTRL1 Register"]
    pub txctrl1: u32,
    #[doc = "< <tt>\\b 0x2C:</tt> I2C FIFO Register"]
    pub fifo: u32,
    #[doc = "< <tt>\\b 0x30:</tt> I2C MSTCTRL Register"]
    pub mstctrl: u32,
    #[doc = "< <tt>\\b 0x34:</tt> I2C CLKLO Register"]
    pub clklo: u32,
    #[doc = "< <tt>\\b 0x38:</tt> I2C CLKHI Register"]
    pub clkhi: u32,
    #[doc = "< <tt>\\b 0x3C:</tt> I2C HSCLK Register"]
    pub hsclk: u32,
    #[doc = "< <tt>\\b 0x40:</tt> I2C TIMEOUT Register"]
    pub timeout: u32,
    pub rsv_0x44: u32,
    #[doc = "< <tt>\\b 0x48:</tt> I2C DMA Register"]
    pub dma: u32,
    pub __bindgen_anon_1: mxc_i2c_regs_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mxc_i2c_regs_t__bindgen_ty_1 {
    #[doc = "< <tt>\\b 0x4C:</tt> I2C SLAVE_MULTI Register"]
    pub slave_multi: [u32; 4usize],
    pub __bindgen_anon_1: mxc_i2c_regs_t__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mxc_i2c_regs_t__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< <tt>\\b 0x4C:</tt> I2C SLAVE0 Register"]
    pub slave0: u32,
    #[doc = "< <tt>\\b 0x50:</tt> I2C SLAVE1 Register"]
    pub slave1: u32,
    #[doc = "< <tt>\\b 0x54:</tt> I2C SLAVE2 Register"]
    pub slave2: u32,
    #[doc = "< <tt>\\b 0x58:</tt> I2C SLAVE3 Register"]
    pub slave3: u32,
}
#[test]
fn bindgen_test_layout_mxc_i2c_regs_t__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<mxc_i2c_regs_t__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mxc_i2c_regs_t__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(mxc_i2c_regs_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<mxc_i2c_regs_t__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(mxc_i2c_regs_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slave0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_i2c_regs_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(slave0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slave1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_i2c_regs_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(slave1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slave2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_i2c_regs_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(slave2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slave3) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_i2c_regs_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(slave3)
        )
    );
}
#[test]
fn bindgen_test_layout_mxc_i2c_regs_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<mxc_i2c_regs_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mxc_i2c_regs_t__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(mxc_i2c_regs_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<mxc_i2c_regs_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(mxc_i2c_regs_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slave_multi) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_i2c_regs_t__bindgen_ty_1),
            "::",
            stringify!(slave_multi)
        )
    );
}
#[test]
fn bindgen_test_layout_mxc_i2c_regs_t() {
    const UNINIT: ::core::mem::MaybeUninit<mxc_i2c_regs_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mxc_i2c_regs_t>(),
        92usize,
        concat!("Size of: ", stringify!(mxc_i2c_regs_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mxc_i2c_regs_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mxc_i2c_regs_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctrl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_i2c_regs_t),
            "::",
            stringify!(ctrl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_i2c_regs_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).intfl0) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_i2c_regs_t),
            "::",
            stringify!(intfl0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inten0) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_i2c_regs_t),
            "::",
            stringify!(inten0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).intfl1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_i2c_regs_t),
            "::",
            stringify!(intfl1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inten1) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_i2c_regs_t),
            "::",
            stringify!(inten1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fifolen) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_i2c_regs_t),
            "::",
            stringify!(fifolen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rxctrl0) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_i2c_regs_t),
            "::",
            stringify!(rxctrl0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rxctrl1) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_i2c_regs_t),
            "::",
            stringify!(rxctrl1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).txctrl0) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_i2c_regs_t),
            "::",
            stringify!(txctrl0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).txctrl1) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_i2c_regs_t),
            "::",
            stringify!(txctrl1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fifo) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_i2c_regs_t),
            "::",
            stringify!(fifo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mstctrl) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_i2c_regs_t),
            "::",
            stringify!(mstctrl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clklo) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_i2c_regs_t),
            "::",
            stringify!(clklo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clkhi) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_i2c_regs_t),
            "::",
            stringify!(clkhi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hsclk) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_i2c_regs_t),
            "::",
            stringify!(hsclk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_i2c_regs_t),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsv_0x44) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_i2c_regs_t),
            "::",
            stringify!(rsv_0x44)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dma) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_i2c_regs_t),
            "::",
            stringify!(dma)
        )
    );
}
#[doc = " @defgroup i2c I2C\n @ingroup periphlibs\n @{"]
pub type mxc_i2c_req_t = _i2c_req_t;
#[doc = " @brief   The callback used by the MXC_I2C_ReadByteInteractive() function.\n\n The callback routine used by the MXC_I2C_ReadByteInteractive() function. This\n function allows the application to determine whether the byte received\n should be acknowledged or not.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n @param   byte        The byte received.\n\n @return  0 if the byte should not be acknowledged (NACK), non-zero to\n          acknowledge the byte."]
pub type mxc_i2c_getAck_t = ::core::option::Option<
    unsafe extern "C" fn(
        i2c: *mut mxc_i2c_regs_t,
        byte: ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int,
>;
#[doc = " @brief   The callback routine used by the MXC_I2C_MasterTransactionAsync()\n          function to indicate the transaction has completed.\n\n @param   req         The details of the transaction.\n @param   result      0 if all bytes are acknowledged, 1 if any byte\n                      transmitted is not acknowledged, negative if error.\n                      See \\ref MXC_Error_Codes for the list of error codes."]
pub type mxc_i2c_complete_cb_t = ::core::option::Option<
    unsafe extern "C" fn(req: *mut mxc_i2c_req_t, result: ::core::ffi::c_int),
>;
#[doc = " @brief   The callback routine used by the I2C Read/Write FIFO DMA\n          functions to indicate the transaction has completed.\n\n @param   len         The length of data actually read/written\n @param   result      See \\ref MXC_Error_Codes for the list of error codes."]
pub type mxc_i2c_dma_complete_cb_t = ::core::option::Option<
    unsafe extern "C" fn(len: ::core::ffi::c_int, result: ::core::ffi::c_int),
>;
#[doc = " @brief   The information required to perform a complete I2C transaction as\n          the bus master.\n\n The information required to perform a complete I2C transaction as the bus\n master. This structure is used by the MXC_I2C_MasterTransaction() and\n MXC_I2C_MasterTransactionAsync() functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _i2c_req_t {
    #[doc = "< Pointer to I2C registers (selects the\n< I2C block used.)"]
    pub i2c: *mut mxc_i2c_regs_t,
    #[doc = "< The 7-bit or 10-bit address of the slave."]
    pub addr: ::core::ffi::c_uint,
    #[doc = "< The buffer containing the bytes to write."]
    pub tx_buf: *mut ::core::ffi::c_uchar,
    #[doc = "< The number of bytes to write. On return\n< from the function, this will be set to\n< the number of bytes actually transmitted."]
    pub tx_len: ::core::ffi::c_uint,
    #[doc = "< The buffer to read the data into."]
    pub rx_buf: *mut ::core::ffi::c_uchar,
    #[doc = "< The number of bytes to read.  On return\n< from the function, this will be set to\n< the number of bytes actually received."]
    pub rx_len: ::core::ffi::c_uint,
    #[doc = "< Controls whether the transaction is\n< terminated with a stop or repeated start\n< condition.  Use 0 for a stop, non-zero\n< for repeated start."]
    pub restart: ::core::ffi::c_int,
    #[doc = "< The callback used to indicate the\n< transaction is complete or an error has\n< occurred. This field may be set to NULL\n< if no indication is necessary. This\n< field is only used by the\n< MXC_I2C_MasterTransactionAsync() function.\n< MXC_I2C_MasterTransaction() ignores the\n< callback field."]
    pub callback: mxc_i2c_complete_cb_t,
}
#[test]
fn bindgen_test_layout__i2c_req_t() {
    const UNINIT: ::core::mem::MaybeUninit<_i2c_req_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_i2c_req_t>(),
        32usize,
        concat!("Size of: ", stringify!(_i2c_req_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_i2c_req_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_i2c_req_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i2c) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_i2c_req_t),
            "::",
            stringify!(i2c)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_i2c_req_t),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_buf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_i2c_req_t),
            "::",
            stringify!(tx_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_len) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_i2c_req_t),
            "::",
            stringify!(tx_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_buf) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_i2c_req_t),
            "::",
            stringify!(rx_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_len) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_i2c_req_t),
            "::",
            stringify!(rx_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).restart) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_i2c_req_t),
            "::",
            stringify!(restart)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_i2c_req_t),
            "::",
            stringify!(callback)
        )
    );
}
#[doc = "< A slave address match occurred with the master\n< requesting a write to the slave."]
pub const mxc_i2c_slave_event_t_MXC_I2C_EVT_MASTER_WR: mxc_i2c_slave_event_t = 0;
#[doc = "< A slave address match occurred with the master\n< requesting a read from the slave."]
pub const mxc_i2c_slave_event_t_MXC_I2C_EVT_MASTER_RD: mxc_i2c_slave_event_t = 1;
#[doc = "< The receive FIFO contains more bytes than its\n< threshold level."]
pub const mxc_i2c_slave_event_t_MXC_I2C_EVT_RX_THRESH: mxc_i2c_slave_event_t = 2;
#[doc = "< The transmit FIFO contains fewer bytes than its\n< threshold level."]
pub const mxc_i2c_slave_event_t_MXC_I2C_EVT_TX_THRESH: mxc_i2c_slave_event_t = 3;
#[doc = "< The transaction has ended."]
pub const mxc_i2c_slave_event_t_MXC_I2C_EVT_TRANS_COMP: mxc_i2c_slave_event_t = 4;
#[doc = "< The master has attempted a read when the\n< transmit FIFO was empty."]
pub const mxc_i2c_slave_event_t_MXC_I2C_EVT_UNDERFLOW: mxc_i2c_slave_event_t = 5;
#[doc = "< The master has written data when the receive\n< FIFO was already full."]
pub const mxc_i2c_slave_event_t_MXC_I2C_EVT_OVERFLOW: mxc_i2c_slave_event_t = 6;
#[doc = " @brief   The list of events reported by the MXC_I2C_SlaveTransaction() and\n          MXC_I2C_SlaveTransactionAsync() functions.\n\n The list of events reported by the MXC_I2C_SlaveTransaction() and\n MXC_I2C_SlaveTransactionAsync() functions.  It is up to the calling\n application to handle these events."]
pub type mxc_i2c_slave_event_t = ::core::ffi::c_uint;
#[doc = " @brief   The callback routine used by the MXC_I2C_SlaveTransaction() and\n          MXC_I2C_SlaveTransactionAsync functions to handle the various I2C\n          slave events.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n @param   event       The event that occurred to trigger this callback.\n @param   data        This field is used to pass Success/Fail for the\n                      MXC_I2C_EVT_TRANS_COMP event.\n\n @return  The return value is only used in the case of an MXC_I2C_EVT_RX_THRESH\n          event. In this case, the return specifies if the last byte\n          received should be acknowledged or not. Return 0 to acknowledge,\n          non-zero to not acknowledge.  The return value is ignored for all\n          other event types."]
pub type mxc_i2c_slave_handler_t = ::core::option::Option<
    unsafe extern "C" fn(
        i2c: *mut mxc_i2c_regs_t,
        event: mxc_i2c_slave_event_t,
        data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int,
>;
extern "C" {
    #[doc = " @brief   Initialize and enable I2C peripheral.\n @note    This function sets the I2C Speed to 100kHz,  if another speed is\n          desired use the MXC_I2C_SetFrequency() function to set it.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n @param   masterMode  Whether to put the device in master or slave mode. Use\n                      non-zero\n                      for master mode, and zero for slave mode.\n @param   slaveAddr   7-bit or 10-bit address to use when in slave mode.\n                      This parameter is ignored when masterMode is non-zero.\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_I2C_Init(
        i2c: *mut mxc_i2c_regs_t,
        masterMode: ::core::ffi::c_int,
        slaveAddr: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Set slave address for I2C instances acting as slaves on the bus.\n @note    Set idx to zero, multiple I2C instances acting as slaves on the\n          bus is not yet supported.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n @param   slaveAddr   7-bit or 10-bit address to use when in slave mode.\n                      This parameter is ignored when masterMode is non-zero.\n @param   idx         Index of the I2C slave.\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_I2C_SetSlaveAddr(
        i2c: *mut mxc_i2c_regs_t,
        slaveAddr: ::core::ffi::c_uint,
        idx: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Disable and shutdown I2C peripheral.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_I2C_Shutdown(i2c: *mut mxc_i2c_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Reset the I2C peripheral.\n @note    The peripheral will need to be initialized with MXC_I2C_Init() before use\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_I2C_Reset(i2c: *mut mxc_i2c_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Set the frequency of the I2C interface.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n @param   hz          The desired frequency in Hertz.\n\n @return  Negative if error, otherwise actual speed set. See \\ref\n          MXC_Error_Codes for the list of error return codes."]
    pub fn MXC_I2C_SetFrequency(
        i2c: *mut mxc_i2c_regs_t,
        hz: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Get the frequency of the I2C interface.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n\n @return  The I2C bus frequency in Hertz"]
    pub fn MXC_I2C_GetFrequency(i2c: *mut mxc_i2c_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Checks if the given I2C bus can be placed in sleep more.\n\n This functions checks to see if there are any on-going I2C transactions in\n progress. If there are transactions in progress, the application should\n wait until the I2C bus is free before entering a low-power state.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n\n @return  #E_NO_ERROR if ready, and non-zero if busy or error. See \\ref\n          MXC_Error_Codes for the list of error return codes."]
    pub fn MXC_I2C_ReadyForSleep(i2c: *mut mxc_i2c_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Enables or disables clock stretching by the slave.\n\n Enables or disables clock stretching by the slave. This function has no\n affect when operating as the master.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n @param   enable      Enables clock stretching if non-zero, disables if zero.\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_I2C_SetClockStretching(
        i2c: *mut mxc_i2c_regs_t,
        enable: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Determines if clock stretching has been enabled.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n\n @return  Zero if clock stretching is disabled, non-zero otherwise"]
    pub fn MXC_I2C_GetClockStretching(i2c: *mut mxc_i2c_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Generate a start (or repeated start) condition on the I2C bus.\n\n Generate a start (or repeated start) condition on the I2C bus. This\n function may opt to delay the actual generation of the start condition\n until data is actually transferred.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_I2C_Start(i2c: *mut mxc_i2c_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Generate a stop condition on the I2C bus.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_I2C_Stop(i2c: *mut mxc_i2c_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Write a single byte to the I2C bus.\n\n Write a single byte to the I2C bus. This function assumes the I2C bus is\n already in the proper state (i.e. a start condition has already been\n generated and the bus is in the write phase of an I2C transaction). If any\n bytes are pending in the FIFO (i.e. in the case of clock stretching), this\n function will return E_OVERFLOW.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n @param   byte        The byte to transmit.\n\n @return  0 if byte is acknowledged, 1 if not acknowledged, negative if\n          error. See \\ref MXC_Error_Codes for the list of error return codes."]
    pub fn MXC_I2C_WriteByte(
        i2c: *mut mxc_i2c_regs_t,
        byte: ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Read a single byte from the I2C bus.\n\n Read a single byte from the I2C bus. This function assumes the I2C bus is\n already in the proper state (i.e. a start condition has already been\n generated and the bus is in the read phase of an I2C transaction). If the FIFO\n is empty, this function will return E_UNDERFLOW.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n @param   byte        Pointer to the byte to read into.\n @param   ack         Whether or not to acknowledge the byte once received.\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_I2C_ReadByte(
        i2c: *mut mxc_i2c_regs_t,
        byte: *mut ::core::ffi::c_uchar,
        ack: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Read a single byte from the I2C bus.\n\n Read a single byte from the I2C bus. After the byte is received, the\n provided callback will be used to determine if the byte should be\n acknowledged or not before continuing with the rest of the transaction.\n This function assumes the I2C bus is already in the proper state (i.e. a\n start condition has already been generated and the bus is in the read\n phase of an I2C transaction). This function must be called with clock\n stretching enabled.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n @param   byte        Pointer to the byte to read into.\n @param   getAck      A function to be called to determine whether or not\n                      to acknowledge the byte once received.  A non-zero\n                      return value will acknowledge the byte.  If this\n                      parameter is set to NULL or its return value is 0,\n                      the byte received will not be acknowledged (i.e., it\n                      will be NACKed).\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_I2C_ReadByteInteractive(
        i2c: *mut mxc_i2c_regs_t,
        byte: *mut ::core::ffi::c_uchar,
        getAck: mxc_i2c_getAck_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Write multiple bytes to the I2C bus.\n\n Write multiple bytes to the I2C bus.  This function assumes the I2C bus is\n already in the proper state (i.e. a start condition has already been\n generated and the bus is in the write phase of an I2C transaction).\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n @param   bytes       The buffer containing the bytes to transmit.\n @param   len         The number of bytes to write. On return from the\n                      function, this will be set to the number of bytes\n                      actually transmitted.\n\n @return  0 if all bytes are acknowledged, 1 if any byte transmitted is not\n          acknowledged, negative if error. See \\ref MXC_Error_Codes for the\n          list of error return codes."]
    pub fn MXC_I2C_Write(
        i2c: *mut mxc_i2c_regs_t,
        bytes: *mut ::core::ffi::c_uchar,
        len: *mut ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Read multiple bytes from the I2C bus.\n\n Read multiple byte from the I2C bus.  This function assumes the I2C bus is\n already in the proper state (i.e. a start condition has already been\n generated and the bus is in the read phase of an I2C transaction).\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n @param   bytes       The buffer to read the data into.\n @param   len         The number of bytes to read. On return from the\n                      function, this will be set to the number of bytes\n                      actually received.\n @param   ack         Whether or not to acknowledge the last byte once it is\n                      received.  All previous bytes will be acknowledged.\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_I2C_Read(
        i2c: *mut mxc_i2c_regs_t,
        bytes: *mut ::core::ffi::c_uchar,
        len: *mut ::core::ffi::c_uint,
        ack: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Unloads bytes from the receive FIFO.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n @param   bytes       The buffer to read the data into.\n @param   len         The number of bytes to read.\n\n @return  The number of bytes actually read."]
    pub fn MXC_I2C_ReadRXFIFO(
        i2c: *mut mxc_i2c_regs_t,
        bytes: *mut ::core::ffi::c_uchar,
        len: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Unloads bytes from the receive FIFO using DMA for longer reads.\n\n @note    The operation is not complete until the callback has been called\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n @param   bytes       The buffer to read the data into.\n @param   len         The number of bytes to read.\n @param   callback    The function to call when the read is complete\n\n @return  See \\ref MXC_Error_Codes for a list of return values."]
    pub fn MXC_I2C_ReadRXFIFODMA(
        i2c: *mut mxc_i2c_regs_t,
        bytes: *mut ::core::ffi::c_uchar,
        len: ::core::ffi::c_uint,
        callback: mxc_i2c_dma_complete_cb_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Get the number of bytes currently available in the receive FIFO.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n\n @return  The number of bytes available."]
    pub fn MXC_I2C_GetRXFIFOAvailable(i2c: *mut mxc_i2c_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Loads bytes into the transmit FIFO.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n @param   bytes       The buffer containing the bytes to write\n @param   len         The number of bytes to write.\n\n @return  The number of bytes actually written."]
    pub fn MXC_I2C_WriteTXFIFO(
        i2c: *mut mxc_i2c_regs_t,
        bytes: *mut ::core::ffi::c_uchar,
        len: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Loads bytes into the transmit FIFO using DMA for longer writes.\n\n @note    The operation is not complete until the callback has been called\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n @param   bytes       The buffer containing the bytes to write\n @param   len         The number of bytes to write.\n @param   callback    The function to call when the read is complete\n\n @return  See \\ref MXC_Error_Codes for a list of return values"]
    pub fn MXC_I2C_WriteTXFIFODMA(
        i2c: *mut mxc_i2c_regs_t,
        bytes: *mut ::core::ffi::c_uchar,
        len: ::core::ffi::c_uint,
        callback: mxc_i2c_dma_complete_cb_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Get the amount of free space available in the transmit FIFO.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n\n @return  The number of bytes available."]
    pub fn MXC_I2C_GetTXFIFOAvailable(i2c: *mut mxc_i2c_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Removes and discards all bytes currently in the receive FIFO.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)"]
    pub fn MXC_I2C_ClearRXFIFO(i2c: *mut mxc_i2c_regs_t);
}
extern "C" {
    #[doc = " @brief   Removes and discards all bytes currently in the transmit FIFO.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)"]
    pub fn MXC_I2C_ClearTXFIFO(i2c: *mut mxc_i2c_regs_t);
}
extern "C" {
    #[doc = " @brief   Get the presently set interrupt flags.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n @param   flags0      Pointer to the variable to store status of the interrupt flags in intfl0.\n @param   flags1      Pointer to the variable to store status of the interrupt flags in intfl1."]
    pub fn MXC_I2C_GetFlags(
        i2c: *mut mxc_i2c_regs_t,
        flags0: *mut ::core::ffi::c_uint,
        flags1: *mut ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Clears the Interrupt Flags.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n @param   flags0      Flags to clear in interrupt register intfl0.\n @param   flags1      Flags to clear in interrupt register intfl1."]
    pub fn MXC_I2C_ClearFlags(
        i2c: *mut mxc_i2c_regs_t,
        flags0: ::core::ffi::c_uint,
        flags1: ::core::ffi::c_uint,
    );
}
extern "C" {
    #[doc = " @brief   Enable Interrupts.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n @param   flags0      Interrupts to be enabled in int->en0\n @param   flags1      Interrupts to be enabled in int->en1"]
    pub fn MXC_I2C_EnableInt(
        i2c: *mut mxc_i2c_regs_t,
        flags0: ::core::ffi::c_uint,
        flags1: ::core::ffi::c_uint,
    );
}
extern "C" {
    #[doc = " @brief   Disable Interrupts.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n @param   flags0      Interrupts to be disabled in int->en0\n @param   flags1      Interrupts to be disabled in int->en1"]
    pub fn MXC_I2C_DisableInt(
        i2c: *mut mxc_i2c_regs_t,
        flags0: ::core::ffi::c_uint,
        flags1: ::core::ffi::c_uint,
    );
}
extern "C" {
    #[doc = " @brief   Enables the slave preload mode\n\n Use this mode to preload the slave TX FIFO with data that can be sent when\n the slave is addressed for a read operation without software intervention.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)"]
    pub fn MXC_I2C_EnablePreload(i2c: *mut mxc_i2c_regs_t);
}
extern "C" {
    #[doc = " @brief   Disable the slave preload mode\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)"]
    pub fn MXC_I2C_DisablePreload(i2c: *mut mxc_i2c_regs_t);
}
extern "C" {
    #[doc = " @brief   Enables the slave to respond to the general call address\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)"]
    pub fn MXC_I2C_EnableGeneralCall(i2c: *mut mxc_i2c_regs_t);
}
extern "C" {
    #[doc = " @brief   Prevents the slave from responding to the general call address\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)"]
    pub fn MXC_I2C_DisableGeneralCall(i2c: *mut mxc_i2c_regs_t);
}
extern "C" {
    #[doc = " @brief   Set the I2C Timeout\n\n The I2C timeout determines the amount of time the master will wait while the\n slave is stretching the clock, and the amount of time the slave will stretch\n the clock while waiting for software to unload the fifo.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n @param   timeout     Timeout in uS"]
    pub fn MXC_I2C_SetTimeout(i2c: *mut mxc_i2c_regs_t, timeout: ::core::ffi::c_uint);
}
extern "C" {
    #[doc = " @brief   Get the current I2C timeout\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n\n @return  The current timeout in uS"]
    pub fn MXC_I2C_GetTimeout(i2c: *mut mxc_i2c_regs_t) -> ::core::ffi::c_uint;
}
extern "C" {
    #[doc = " @brief   Attempts to recover the I2C bus, ensuring the I2C lines are idle.\n\n Attempts to recover and reset an I2C bus by sending I2C clocks. During\n each clock cycle, the SDA line is cycled to determine if the master has\n control of the line. The following steps are performed to create one SCL\n clock cycle:\n   1. Drive SCL low\n   2. Verify SCL is low\n   3. Drive SDA low\n   4. Verify SDA is low\n   5. Release SDA allowing it to return high\n   6. Verify SDA is high\n   7. Release SCL allowing it to return high.\n   8. Verify SCL is high\n If any of the steps fail, the bus is considered to still be busy and the\n sequence is repeated up to the requested number of times. If all steps\n succeed, a final stop condition is generated on the I2C bus.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n @param   retries     Number of times to attempt the clock cycle sequence.\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_I2C_Recover(
        i2c: *mut mxc_i2c_regs_t,
        retries: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Performs a blocking I2C master transaction.\n\n Performs a blocking I2C master transaction.  These actions will be performed:\n   1. If necessary, generate a start condition on the bus.\n   2. Send the slave address with the low bit set to 0 (indicating a write).\n   3. Transmit req->tx_len bytes of req->tx_buff.\n   4. Generate a repeated start condition on the bus.\n   5. Send the slave address with the low bit set to 1 (indicating a read).\n   6. Receive req->rx_len bytes into req->rx_buf, acknowledging each byte.\n   7. Generate a stop (or repeated start) condition on the bus.\n   Steps 3-6 will be skipped if req->tx_len and req->rx_len are both 0.\n   Steps 2-4 will be skipped if req->tx_len equals 0.\n   Steps 4-6 will be skipped if req->rx_len equals 0.\n\n @param   req         Pointer to details of the transaction\n\n @return  0 if all bytes are acknowledged, 1 if any byte transmitted is not\n          acknowledged, negative if error. See \\ref MXC_Error_Codes for the\n          list of error return codes."]
    pub fn MXC_I2C_MasterTransaction(req: *mut mxc_i2c_req_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Performs a non-blocking I2C master transaction.\n\n Performs a non-blocking I2C master transaction.  These actions will be performed:\n   1. If necessary, generate a start condition on the bus.\n   2. Send the slave address with the low bit set to 0 (indicating a write).\n   3. Transmit req->tx_len bytes of req->tx_buff.\n   4. Generate a repeated start condition on the bus.\n   5. Send the slave address with the low bit set to 1 (indicating a read).\n   6. Receive req->rx_len bytes into req->rx_buf, acknowledging each byte.\n   7. Generate a stop (or repeated start) condition on the bus.\n   8. Execute req->callback to indicate the transaction is complete.\n   Steps 3-6 will be skipped if tx_len and rx_len are both 0.\n   Steps 2-4 will be skipped if tx_len equals 0.\n   Steps 4-6 will be skipped if rx_len equals 0.\n\n @note    MXC_I2C_AsyncHandler() must be called periodically for this function\n          to operate properly. Ideally from the I2C ISR.\n\n @param   req         Pointer to details of the transaction.  The memory\n                      used by this parameter must remain available until\n                      the callback is executed.\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_I2C_MasterTransactionAsync(req: *mut mxc_i2c_req_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Performs a non-blocking I2C transaction using DMA for reduced time\n          in the ISR.\n\n Performs a non-blocking I2C transaction.  These actions will be performed:\n   1. If necessary, generate a start condition on the bus.\n   2. Send the slave address with the low bit set to 0 (indicating a write).\n   3. Transmit req->tx_len bytes of req->tx_buff.\n   4. Generate a repeated start condition on the bus.\n   5. Send the slave address with the low bit set to 1 (indicating a read).\n   6. Receive req->rx_len bytes into req->rx_buf, acknowledging each byte.\n   7. Generate a stop (or repeated start) condition on the bus.\n   8. Execute req->callback to indicate the transaction is complete.\n   Steps 3-6 will be skipped if tx_len and rx_len are both 0.\n   Steps 2-4 will be skipped if tx_len equals 0.\n   Steps 4-6 will be skipped if rx_len equals 0.\n\n @note    MXC_I2C_AsyncHandler() must be called periodically for this function\n          to operate properly. Ideally from the I2C ISR.\n\n @param   req         Pointer to details of the transaction.  The memory\n                      used by this parameter must remain available until\n                      the callback is executed.\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_I2C_MasterTransactionDMA(req: *mut mxc_i2c_req_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Performs a blocking I2C slave transaction.\n\n Performs a blocking I2C slave transaction. This function will block until a\n complete transaction with this slave has been performed. A transaction\n begins with the master addressing the slave and ends with a repeated start\n condition, a stop condition, or a bus error. The provided callback\n function will be called for these events:\n      - A slave address match occurs with the master requesting a write to\n        the slave.\n      - A slave address match occurs with the master requesting a read from\n        the slave.\n      - The receive FIFO crosses the set threshold (see\n        MXC_I2C_SetRXThreshold()). The callback code should unload the receive\n        FIFO (see MXC_I2C_ReadFIFO()) to allow the master to send more data.\n        The return value of the callback function will determine if the\n        last byte received should be acknowledged or not. Return 0 to\n        acknowledge, non-zero to not acknowledge.\n      - The transmit FIFO crosses the set threshold (see\n        MXC_I2C_SetTXThreshold()). If the master is expected to read more\n        data from this slave, the callback code should add data to the\n        transmit FIFO (see MXC_I2C_WriteFIFO()).\n      - The transaction ends.  If the master was writing to the slave, the\n        receive FIFO may still contain valid data that needs to be\n        retreived (see MXC_I2C_ReadFIFO()).\n      - The transmit FIFO underflows because the master requests data when\n        the transmit FIFO is empty.\n      - The receive FIFO overflows because the master writes data while the\n        receive FIFO was full.\n\n If clock stretching is disabled, careful attention must be paid to the timing\n of the callback to avoid losing data on write or unintentionally nacking a read.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n @param   callback    The function to be called when an I2C event occurs.\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_I2C_SlaveTransaction(
        i2c: *mut mxc_i2c_regs_t,
        callback: mxc_i2c_slave_handler_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Performs a non-blocking I2C slave transaction.\n\n Performs a non-blocking I2C slave transaction. This request will remain active\n until a complete transaction with this slave has been performed.  A\n transaction begins with the master  begins with the master addressing the\n slave and ends with a repeated start condition, a stop condition, or a bus\n error. The provided callback function will be called for these events:\n      - A slave address match occurs with the master requesting a write to\n        the slave.\n      - A slave address match occurs with the master requesting a read from\n        the slave.\n      - The receive FIFO crosses the set threshold (see\n        MXC_I2C_SetRXThreshold()). The callback code should unload the receive\n        FIFO (see MXC_I2C_ReadFIFO()) to allow the master to send more data.\n        The return value of the callback function will determine if the\n        last byte received should be acknowledged or not. Return 0 to\n        acknowledge, non-zero to not acknowledge.\n      - The transmit FIFO crosses the set threshold (see\n        MXC_I2C_SetTXThreshold()). If the master is expected to read more\n        data from this slave, the callback code should add data to the\n        transmit FIFO (see MXC_I2C_WriteFIFO()).\n      - The transaction ends.  If the master was writing to the slave, the\n        receive FIFO may still contain valid data that needs to be\n        retreived (see MXC_I2C_ReadFIFO()).\n      - The transmit FIFO underflows because the master requests data when\n        the transmit FIFO is empty.\n      - The receive FIFO overflows because the master writes data while the\n        receive FIFO was full.\n\n If clock stretching is disabled, careful attention must be paid to the timing\n of the callback to avoid losing data on write or unintentionally nacking a read.\n\n @note    MXC_I2C_AsyncHandler() must be called peridocally for this function\n          to operate properly.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n @param   callback    The function to be called when an I2C event occurs.\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_I2C_SlaveTransactionAsync(
        i2c: *mut mxc_i2c_regs_t,
        callback: mxc_i2c_slave_handler_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Set the receive threshold level.\n\n When operating as a master, the function sets the receive threshold level\n for when the master should unload the receive FIFO. Smaller values may\n consume more CPU cycles, but decrease the chances of the master delaying\n the generation of I2C bus clocks because it has no room in the FIFO to\n receive data. Larger values may consume fewer CPU cycles, but risk delays\n of the I2C clock. When operating as a slave, this function sets the number\n of bytes the slave transaction  functions should receive before issuing a\n call to their callback function. Smaller values may consume more CPU\n cycles, but reduce the risk of missing data from the master due to the\n recieve FIFO being full. Larger values may reduce the number of CPU\n cycles, but may cause bytes sent from the master to be missed.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n @param   numBytes    The threshold level to set. This value must be\n                      between 0 and 8 inclusive.\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_I2C_SetRXThreshold(
        i2c: *mut mxc_i2c_regs_t,
        numBytes: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Get the current receive threshold level.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n\n @return  The receive threshold value (in bytes)."]
    pub fn MXC_I2C_GetRXThreshold(i2c: *mut mxc_i2c_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Set the transmit threshold level.\n\n When operating as a master, the function sets the transmit threshold level\n for when the master should add additional bytes to the transmit FIFO.\n Larger values may consume more CPU cycles, but decrease the chances of the\n master delaying the generation of I2C bus clocks because it has no data in\n the FIFO to transmit. Smaller values may consume fewer CPU cycles, but\n risk delays of the I2C clock. When operating as a slave, this function\n sets the number of bytes the slave transaction functions should transmit\n before issuing a call to their callback function. Larger values may\n consume more CPU cycles, but reduce the risk of not having data ready when\n the master requests it.  Smaller values may reduce the number of CPU\n cycles, but may cause the master to read from an empty FIFO.  (The master\n will read 0xFF in this case.)\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n @param   numBytes    The threshold level to set.  This value must be\n                      between 0 and 8 inclusive.\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_I2C_SetTXThreshold(
        i2c: *mut mxc_i2c_regs_t,
        numBytes: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Get the current transmit threshold level.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)\n\n @return  The transmit threshold value (in bytes)."]
    pub fn MXC_I2C_GetTXThreshold(i2c: *mut mxc_i2c_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Stop any asynchronous requests in progress.\n\n Stop any asynchronous requests in progress. Any callbacks associated with\n the active transaction will be NOT executed.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)"]
    pub fn MXC_I2C_AsyncStop(i2c: *mut mxc_i2c_regs_t);
}
extern "C" {
    #[doc = " @brief   Abort any asynchronous requests in progress.\n\n Abort any asynchronous requests in progress. Any callbacks associated with\n the active transaction will be executed to indicate when the transaction\n has been terminated.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)"]
    pub fn MXC_I2C_AbortAsync(i2c: *mut mxc_i2c_regs_t);
}
extern "C" {
    #[doc = " @brief   The processing function for asynchronous transactions.\n\n When using the asynchronous functions, the application must call this\n function periodically. This can be done from within the I2C interrupt\n handler or periodically by the application if I2C interrupts are disabled.\n\n @param   i2c         Pointer to I2C registers (selects the I2C block used.)"]
    pub fn MXC_I2C_AsyncHandler(i2c: *mut mxc_i2c_regs_t);
}
extern "C" {
    #[doc = " @brief   The processing function for DMA transactions.\n\n When using the DMA functions, the application must call this\n function periodically. This can be done from within the DMA Interrupt Handler.\n\n @param   ch          DMA channel\n @param   error       Error status"]
    pub fn MXC_I2C_DMACallback(ch: ::core::ffi::c_int, error: ::core::ffi::c_int);
}
#[doc = " @ingroup icc_registers\n Structure type to access the ICC Registers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mxc_icc_regs_t {
    #[doc = "< <tt>\\b 0x0000:</tt> ICC INFO Register"]
    pub info: u32,
    #[doc = "< <tt>\\b 0x0004:</tt> ICC SZ Register"]
    pub sz: u32,
    pub rsv_0x8_0xff: [u32; 62usize],
    #[doc = "< <tt>\\b 0x0100:</tt> ICC CTRL Register"]
    pub ctrl: u32,
    pub rsv_0x104_0x6ff: [u32; 383usize],
    #[doc = "< <tt>\\b 0x0700:</tt> ICC INVALIDATE Register"]
    pub invalidate: u32,
}
#[test]
fn bindgen_test_layout_mxc_icc_regs_t() {
    const UNINIT: ::core::mem::MaybeUninit<mxc_icc_regs_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mxc_icc_regs_t>(),
        1796usize,
        concat!("Size of: ", stringify!(mxc_icc_regs_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mxc_icc_regs_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mxc_icc_regs_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_icc_regs_t),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sz) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_icc_regs_t),
            "::",
            stringify!(sz)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsv_0x8_0xff) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_icc_regs_t),
            "::",
            stringify!(rsv_0x8_0xff)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctrl) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_icc_regs_t),
            "::",
            stringify!(ctrl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsv_0x104_0x6ff) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_icc_regs_t),
            "::",
            stringify!(rsv_0x104_0x6ff)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).invalidate) as usize - ptr as usize },
        1792usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_icc_regs_t),
            "::",
            stringify!(invalidate)
        )
    );
}
pub const mxc_icc_info_t_ICC_INFO_RELNUM: mxc_icc_info_t = 0;
pub const mxc_icc_info_t_ICC_INFO_PARTNUM: mxc_icc_info_t = 1;
pub const mxc_icc_info_t_ICC_INFO_ID: mxc_icc_info_t = 2;
#[doc = " @brief Enumeration type for the Cache ID Register"]
pub type mxc_icc_info_t = ::core::ffi::c_uint;
extern "C" {
    #[doc = " @brief   Reads the data from the Cache Id Register.\n @param   icc  Pointer to the Instuction Cache Controller registers.\n @param   cid  Enumeration type for Cache Id Register.\n @retval  Returns the contents of Cache Id Register."]
    pub fn MXC_ICC_ID(icc: *mut mxc_icc_regs_t, cid: mxc_icc_info_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Enable the instruction cache controller.\n\n @param icc  Pointer to the Instuction Cache Controller registers."]
    pub fn MXC_ICC_Enable(icc: *mut mxc_icc_regs_t);
}
extern "C" {
    #[doc = " @brief   Disable the instruction cache controller.\n\n @param icc  Pointer to the Instuction Cache Controller registers."]
    pub fn MXC_ICC_Disable(icc: *mut mxc_icc_regs_t);
}
extern "C" {
    #[doc = " @brief   Flush the instruction cache controller.\n\n @param icc  Pointer to the Instuction Cache Controller registers."]
    pub fn MXC_ICC_Flush(icc: *mut mxc_icc_regs_t);
}
#[doc = " @brief   The callback routine used by MXC_DelayAsync() when the delay is complete\n          or aborted early.\n\n @param   result      See \\ref MXC_Error_Codes for the list of error codes."]
pub type mxc_delay_complete_t =
    ::core::option::Option<unsafe extern "C" fn(result: ::core::ffi::c_int)>;
extern "C" {
    #[doc = " @brief      Blocks and delays for the specified number of microseconds.\n @details    Uses the SysTick to create the requested delay. If the SysTick is\n             running, the current settings will be used. If the SysTick is not\n             running, it will be started.\n @param      us    microseconds to delay\n @return     #E_NO_ERROR if no errors, @ref MXC_Error_Codes \"error\" if unsuccessful."]
    pub fn MXC_Delay(us: u32) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Starts a non-blocking delay for the specified number of\n             microseconds.\n @details    Uses the SysTick to time the requested delay. If the SysTick is\n             running, the current settings will be used. If the SysTick is not\n             running, it will be started.\n @note       MXC_Delay_handler() must be called from the SysTick interrupt service\n             routine or at a rate greater than the SysTick overflow rate.\n @param      us    microseconds to delay\n @param      callback Function pointer to the function to call after the delay has expired.\n @return     #E_NO_ERROR if no errors, #E_BUSY if currently servicing another\n             delay request."]
    pub fn MXC_DelayAsync(us: u32, callback: mxc_delay_complete_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Returns the status of a non-blocking delay request\n @pre        Start the asynchronous delay by calling MXC_Delay_start().\n @return     #E_BUSY until the requested delay time has expired."]
    pub fn MXC_DelayCheck() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief      Stops an asynchronous delay previously started.\n @pre        Start the asynchronous delay by calling MXC_Delay_start()."]
    pub fn MXC_DelayAbort();
}
extern "C" {
    #[doc = " @brief      Processes the delay interrupt.\n @details    This function must be called from the SysTick IRQ or polled at a\n             rate greater than the SysTick overflow rate."]
    pub fn MXC_DelayHandler();
}
extern "C" {
    #[doc = " @brief Set an IRQ hander callback function.  If the IRQ table is in\n flash, this will copy it to RAM and set NVIC to RAM based table.\n\n @param irqn          ARM external IRQ number\n @param irq_callback  Function to be called at IRQ context\n"]
    pub fn MXC_NVIC_SetVector(
        irqn: IRQn_Type,
        irq_callback: ::core::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " @brief Copy NVIC vector table to RAM and set NVIC to RAM based table.\n"]
    pub fn NVIC_SetRAM();
}
extern "C" {
    #[doc = " @brief      Get Interrupt Vector\n @details    Reads an interrupt vector from interrupt vector table. The\n             interrupt number can be positive to specify a device specific\n             interrupt, or negative to specify a processor exception.\n @param[in]  IRQn  Interrupt number.\n @return     Address of interrupt handler function"]
    pub fn MXC_NVIC_GetVector(IRQn: IRQn_Type) -> u32;
}
#[doc = " @ingroup trng_registers\n Structure type to access the TRNG Registers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mxc_trng_regs_t {
    #[doc = "< <tt>\\b 0x00:</tt> TRNG CTRL Register"]
    pub ctrl: u32,
    #[doc = "< <tt>\\b 0x04:</tt> TRNG STATUS Register"]
    pub status: u32,
    #[doc = "< <tt>\\b 0x08:</tt> TRNG DATA Register"]
    pub data: u32,
}
#[test]
fn bindgen_test_layout_mxc_trng_regs_t() {
    const UNINIT: ::core::mem::MaybeUninit<mxc_trng_regs_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mxc_trng_regs_t>(),
        12usize,
        concat!("Size of: ", stringify!(mxc_trng_regs_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mxc_trng_regs_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mxc_trng_regs_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctrl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_trng_regs_t),
            "::",
            stringify!(ctrl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_trng_regs_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_trng_regs_t),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Function Prototypes"]
pub type mxc_trng_complete_t = ::core::option::Option<
    unsafe extern "C" fn(req: *mut ::core::ffi::c_void, result: ::core::ffi::c_int),
>;
extern "C" {
    #[doc = " @brief   Enable portions of the TRNG\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_TRNG_Init() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Enable TRNG Interrupts\n"]
    pub fn MXC_TRNG_EnableInt();
}
extern "C" {
    #[doc = " @brief   Disable TRNG Interrupts\n"]
    pub fn MXC_TRNG_DisableInt();
}
extern "C" {
    #[doc = " @brief   Disable and reset portions of the TRNG\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_TRNG_Shutdown() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   This function should be called from the TRNG ISR Handler\n          when using Async functions"]
    pub fn MXC_TRNG_Handler();
}
extern "C" {
    #[doc = " @brief   Get a random number\n\n @return  A random 32-bit number"]
    pub fn MXC_TRNG_RandomInt() -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Get a random number of length len\n\n @param   data    Pointer to a location to store the number\n @param   len     Length of random number in bytes\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_TRNG_Random(data: *mut u8, len: u32) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Get a random number of length len, do not block while generating data\n @note    The user must call MXC_TRNG_Handler() in the ISR\n\n @param   data      Pointer to a location to store the number\n @param   len       Length of random number in bytes\n @param   callback  Function that will be called when all data has been generated\n"]
    pub fn MXC_TRNG_RandomAsync(data: *mut u8, len: u32, callback: mxc_trng_complete_t);
}
extern "C" {
    #[doc = " @brief   Generate an AES key and transfer to the AES block"]
    pub fn MXC_TRNG_GenerateKey();
}
extern "C" {
    #[doc = " @brief   Perform health test of the TRNG entropy source\n\n @return  E_NOT_SUPPORTED (-17)"]
    pub fn MXC_TRNG_HealthTest() -> ::core::ffi::c_int;
}
#[doc = " @ingroup uart_registers\n Structure type to access the UART Registers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mxc_uart_regs_t {
    #[doc = "< <tt>\\b 0x0000:</tt> UART CTRL Register"]
    pub ctrl: u32,
    #[doc = "< <tt>\\b 0x0004:</tt> UART STATUS Register"]
    pub status: u32,
    #[doc = "< <tt>\\b 0x0008:</tt> UART INT_EN Register"]
    pub int_en: u32,
    #[doc = "< <tt>\\b 0x000C:</tt> UART INT_FL Register"]
    pub int_fl: u32,
    #[doc = "< <tt>\\b 0x0010:</tt> UART CLKDIV Register"]
    pub clkdiv: u32,
    #[doc = "< <tt>\\b 0x0014:</tt> UART OSR Register"]
    pub osr: u32,
    #[doc = "< <tt>\\b 0x0018:</tt> UART TXPEEK Register"]
    pub txpeek: u32,
    #[doc = "< <tt>\\b 0x001C:</tt> UART PNR Register"]
    pub pnr: u32,
    #[doc = "< <tt>\\b 0x0020:</tt> UART FIFO Register"]
    pub fifo: u32,
    pub rsv_0x24_0x2f: [u32; 3usize],
    #[doc = "< <tt>\\b 0x0030:</tt> UART DMA Register"]
    pub dma: u32,
    #[doc = "< <tt>\\b 0x0034:</tt> UART WKEN Register"]
    pub wken: u32,
    #[doc = "< <tt>\\b 0x0038:</tt> UART WKFL Register"]
    pub wkfl: u32,
}
#[test]
fn bindgen_test_layout_mxc_uart_regs_t() {
    const UNINIT: ::core::mem::MaybeUninit<mxc_uart_regs_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mxc_uart_regs_t>(),
        60usize,
        concat!("Size of: ", stringify!(mxc_uart_regs_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mxc_uart_regs_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mxc_uart_regs_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctrl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_uart_regs_t),
            "::",
            stringify!(ctrl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_uart_regs_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).int_en) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_uart_regs_t),
            "::",
            stringify!(int_en)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).int_fl) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_uart_regs_t),
            "::",
            stringify!(int_fl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clkdiv) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_uart_regs_t),
            "::",
            stringify!(clkdiv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).osr) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_uart_regs_t),
            "::",
            stringify!(osr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).txpeek) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_uart_regs_t),
            "::",
            stringify!(txpeek)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pnr) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_uart_regs_t),
            "::",
            stringify!(pnr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fifo) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_uart_regs_t),
            "::",
            stringify!(fifo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rsv_0x24_0x2f) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_uart_regs_t),
            "::",
            stringify!(rsv_0x24_0x2f)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dma) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_uart_regs_t),
            "::",
            stringify!(dma)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wken) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_uart_regs_t),
            "::",
            stringify!(wken)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wkfl) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_uart_regs_t),
            "::",
            stringify!(wkfl)
        )
    );
}
#[doc = " @defgroup uart UART\n @ingroup periphlibs\n @{"]
pub type mxc_uart_req_t = _mxc_uart_req_t;
#[doc = "< UART Stop 1 clock cycle"]
pub const mxc_uart_stop_t_MXC_UART_STOP_1: mxc_uart_stop_t = 0;
#[doc = "< UART Stop 2 clock cycle (1.5 clocks for 5 bit characters)"]
pub const mxc_uart_stop_t_MXC_UART_STOP_2: mxc_uart_stop_t = 1;
#[doc = " @brief   The list of UART stop bit lengths supported\n"]
pub type mxc_uart_stop_t = ::core::ffi::c_uint;
#[doc = "< UART Parity Disabled"]
pub const mxc_uart_parity_t_MXC_UART_PARITY_DISABLE: mxc_uart_parity_t = 0;
#[doc = "< UART Parity Even, 0 based"]
pub const mxc_uart_parity_t_MXC_UART_PARITY_EVEN_0: mxc_uart_parity_t = 1;
#[doc = "< UART Parity Even, 1 based"]
pub const mxc_uart_parity_t_MXC_UART_PARITY_EVEN_1: mxc_uart_parity_t = 2;
#[doc = "< UART Parity Odd, 0 based"]
pub const mxc_uart_parity_t_MXC_UART_PARITY_ODD_0: mxc_uart_parity_t = 3;
#[doc = "< UART Parity Odd, 1 based"]
pub const mxc_uart_parity_t_MXC_UART_PARITY_ODD_1: mxc_uart_parity_t = 4;
#[doc = " @brief   The list of UART Parity options supported\n"]
pub type mxc_uart_parity_t = ::core::ffi::c_uint;
#[doc = "< UART Flow Control Disabled"]
pub const mxc_uart_flow_t_MXC_UART_FLOW_DIS: mxc_uart_flow_t = 0;
#[doc = "< UART Flow Control Enabled"]
pub const mxc_uart_flow_t_MXC_UART_FLOW_EN: mxc_uart_flow_t = 1;
#[doc = " @brief   The list of UART flow control options supported\n"]
pub type mxc_uart_flow_t = ::core::ffi::c_uint;
pub const mxc_uart_clock_t_MXC_UART_APB_CLK: mxc_uart_clock_t = 0;
pub const mxc_uart_clock_t_MXC_UART_IBRO_CLK: mxc_uart_clock_t = 2;
pub const mxc_uart_clock_t_MXC_UART_ERTCO_CLK: mxc_uart_clock_t = 4;
#[doc = " @brief      Clock settings"]
pub type mxc_uart_clock_t = ::core::ffi::c_uint;
#[doc = " @brief   The callback routine used to indicate the transaction has terminated.\n\n @param   req          The details of the transaction.\n @param   result       See \\ref MXC_Error_Codes for the list of error codes."]
pub type mxc_uart_complete_cb_t = ::core::option::Option<
    unsafe extern "C" fn(req: *mut mxc_uart_req_t, result: ::core::ffi::c_int),
>;
#[doc = " @brief   The callback routine used to indicate the transaction has terminated.\n\n @param   req          The details of the transaction.\n @param   num          The number of characters actually copied\n @param   result       See \\ref MXC_Error_Codes for the list of error codes."]
pub type mxc_uart_dma_complete_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        req: *mut mxc_uart_req_t,
        num: ::core::ffi::c_int,
        result: ::core::ffi::c_int,
    ),
>;
#[doc = " @brief   The information required to perform a complete UART transaction\n\n @note    This structure is used by blocking, async, and DMA based transactions.\n @note    \"callback\" only needs to be initialized for interrupt driven (Async) or DMA transactions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _mxc_uart_req_t {
    #[doc = "<Point to UART registers"]
    pub uart: *mut mxc_uart_regs_t,
    #[doc = "< Buffer containing transmit data. For character sizes\n< < 8 bits, pad the MSB of each byte with zeros. For\n< character sizes > 8 bits, use two bytes per character\n< and pad the MSB of the upper byte with zeros"]
    pub txData: *const u8,
    #[doc = "< Buffer to store received data For character sizes\n< < 8 bits, pad the MSB of each byte with zeros. For\n< character sizes > 8 bits, use two bytes per character\n< and pad the MSB of the upper byte with zeros"]
    pub rxData: *mut u8,
    #[doc = "< Number of bytes to be sent from txData"]
    pub txLen: u32,
    #[doc = "< Number of bytes to be stored in rxData"]
    pub rxLen: u32,
    #[doc = "< Number of bytes actually transmitted from txData"]
    pub txCnt: u32,
    #[doc = "< Number of bytes stored in rxData"]
    pub rxCnt: u32,
    #[doc = "< Pointer to function called when transaction is complete"]
    pub callback: mxc_uart_complete_cb_t,
}
#[test]
fn bindgen_test_layout__mxc_uart_req_t() {
    const UNINIT: ::core::mem::MaybeUninit<_mxc_uart_req_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_mxc_uart_req_t>(),
        32usize,
        concat!("Size of: ", stringify!(_mxc_uart_req_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_mxc_uart_req_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_mxc_uart_req_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mxc_uart_req_t),
            "::",
            stringify!(uart)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).txData) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_mxc_uart_req_t),
            "::",
            stringify!(txData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rxData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_mxc_uart_req_t),
            "::",
            stringify!(rxData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).txLen) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_mxc_uart_req_t),
            "::",
            stringify!(txLen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rxLen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_mxc_uart_req_t),
            "::",
            stringify!(rxLen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).txCnt) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_mxc_uart_req_t),
            "::",
            stringify!(txCnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rxCnt) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_mxc_uart_req_t),
            "::",
            stringify!(rxCnt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_mxc_uart_req_t),
            "::",
            stringify!(callback)
        )
    );
}
extern "C" {
    #[doc = " @brief   Initialize and enable UART peripheral.\n\n This function initializes everything necessary to call a UART transaction function.\n Some parameters are set to defaults as follows:\n UART Data Size    - 8 bits\n UART Stop Bits    - 1 bit\n UART Parity       - None\n UART Flow Control - None\n\n These parameters can be modified after initialization using low level functions\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n @param   baud         The requested clock frequency. The actual clock frequency\n                       will be returned by the function if successful.\n @param   clock        Clock source\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_UART_Init(
        uart: *mut mxc_uart_regs_t,
        baud: ::core::ffi::c_uint,
        clock: mxc_uart_clock_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Disable and shutdown UART peripheral.\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_UART_Shutdown(uart: *mut mxc_uart_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Checks if the given UART bus can be placed in sleep more.\n\n @note    This functions checks to see if there are any on-going UART transactions in\n          progress. If there are transactions in progress, the application should\n          wait until the UART bus is free before entering a low-power state.\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n\n @return  #E_NO_ERROR if ready, and non-zero if busy or error. See \\ref\n          MXC_Error_Codes for the list of error return codes."]
    pub fn MXC_UART_ReadyForSleep(uart: *mut mxc_uart_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Set the frequency of the UART interface.\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n @param   baud         The desired baud rate\n @param   clock        Clock source\n\n @return  Negative if error, otherwise actual speed set. See \\ref\n          MXC_Error_Codes for the list of error return codes."]
    pub fn MXC_UART_SetFrequency(
        uart: *mut mxc_uart_regs_t,
        baud: ::core::ffi::c_uint,
        clock: mxc_uart_clock_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Get the frequency of the UART interface.\n\n @note    This function is applicable in Master mode only\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n\n @return  The UART baud rate"]
    pub fn MXC_UART_GetFrequency(uart: *mut mxc_uart_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Sets the number of bits per character\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n @param   dataSize     The number of bits per character (5-8 bits/character are valid)\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_UART_SetDataSize(
        uart: *mut mxc_uart_regs_t,
        dataSize: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Sets the number of stop bits sent at the end of a character\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n @param   stopBits     The number of stop bits used\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_UART_SetStopBits(
        uart: *mut mxc_uart_regs_t,
        stopBits: mxc_uart_stop_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Sets the type of parity generation used\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n @param   parity       see \\ref UART Parity Types for details\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_UART_SetParity(
        uart: *mut mxc_uart_regs_t,
        parity: mxc_uart_parity_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Sets the flow control used\n\n @param   uart            Pointer to UART registers (selects the UART block used.)\n @param   flowCtrl        see \\ref UART Flow Control Types for details\n @param   rtsThreshold    Number of bytes remaining in the RX FIFO when RTS is asserted\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_UART_SetFlowCtrl(
        uart: *mut mxc_uart_regs_t,
        flowCtrl: mxc_uart_flow_t,
        rtsThreshold: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Sets the clock source for the baud rate generator\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n @param   clock        Clock source\n\n @return  Actual baud rate if successful, otherwise see \\ref MXC_Error_Codes\n          for a list of return codes."]
    pub fn MXC_UART_SetClockSource(
        uart: *mut mxc_uart_regs_t,
        clock: mxc_uart_clock_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Checks the UART Peripheral for an ongoing transmission\n\n @note    This function is applicable in Master mode only\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n\n @return  Active/Inactive, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_UART_GetActive(uart: *mut mxc_uart_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Aborts an ongoing UART Transmission\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_UART_AbortTransmission(uart: *mut mxc_uart_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Reads the next available character. If no character is available, this function\n          will return an error.\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n\n @return  The character read, otherwise see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_UART_ReadCharacterRaw(uart: *mut mxc_uart_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Writes a character on the UART. If the character cannot be written because the\n          transmit FIFO is currently full, this function returns an error.\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n @param   character         The character to write\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_UART_WriteCharacterRaw(
        uart: *mut mxc_uart_regs_t,
        character: u8,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Reads the next available character\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n\n @return  The character read, otherwise see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_UART_ReadCharacter(uart: *mut mxc_uart_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Writes a character on the UART\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n @param   character    The character to write\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_UART_WriteCharacter(uart: *mut mxc_uart_regs_t, character: u8)
        -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Reads the next available character\n @note    This function blocks until len characters are received\n          See MXC_UART_TransactionAsync() for a non-blocking version\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n @param   buffer       Buffer to store data in\n @param   len          Number of characters\n\n @return  The character read, otherwise see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_UART_Read(
        uart: *mut mxc_uart_regs_t,
        buffer: *mut u8,
        len: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Writes a byte on the UART\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n @param   byte         The buffer of characters to write\n @param   len          The number of characters to write\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_UART_Write(
        uart: *mut mxc_uart_regs_t,
        byte: *const u8,
        len: *mut ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Unloads bytes from the receive FIFO.\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n @param   bytes        The buffer to read the data into.\n @param   len          The number of bytes to read.\n\n @return  The number of bytes actually read."]
    pub fn MXC_UART_ReadRXFIFO(
        uart: *mut mxc_uart_regs_t,
        bytes: *mut ::core::ffi::c_uchar,
        len: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    #[doc = " @brief   Unloads bytes from the receive FIFO user DMA for longer reads.\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n @param   bytes        The buffer to read the data into.\n @param   len          The number of bytes to read.\n @param   callback     The function to call when the read is complete\n\n @return  See \\ref MXC_ERROR_CODES for a list of return values"]
    pub fn MXC_UART_ReadRXFIFODMA(
        uart: *mut mxc_uart_regs_t,
        bytes: *mut ::core::ffi::c_uchar,
        len: ::core::ffi::c_uint,
        callback: mxc_uart_dma_complete_cb_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Get the number of bytes currently available in the receive FIFO.\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n\n @return  The number of bytes available."]
    pub fn MXC_UART_GetRXFIFOAvailable(uart: *mut mxc_uart_regs_t) -> ::core::ffi::c_uint;
}
extern "C" {
    #[doc = " @brief   Loads bytes into the transmit FIFO.\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n @param   bytes        The buffer containing the bytes to write\n @param   len          The number of bytes to write.\n\n @return  The number of bytes actually written."]
    pub fn MXC_UART_WriteTXFIFO(
        uart: *mut mxc_uart_regs_t,
        bytes: *const ::core::ffi::c_uchar,
        len: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_uint;
}
extern "C" {
    #[doc = " @brief   Loads bytes into the transmit FIFO using DMA for longer writes\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n @param   bytes        The buffer containing the bytes to write\n @param   len          The number of bytes to write.\n @param   callback     The function to call when the write is complete\n\n @return  See \\ref MXC_ERROR_CODES for a list of return values"]
    pub fn MXC_UART_WriteTXFIFODMA(
        uart: *mut mxc_uart_regs_t,
        bytes: *const ::core::ffi::c_uchar,
        len: ::core::ffi::c_uint,
        callback: mxc_uart_dma_complete_cb_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Get the amount of free space available in the transmit FIFO.\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n\n @return  The number of bytes available."]
    pub fn MXC_UART_GetTXFIFOAvailable(uart: *mut mxc_uart_regs_t) -> ::core::ffi::c_uint;
}
extern "C" {
    #[doc = " @brief   Removes and discards all bytes currently in the receive FIFO.\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n\n @return  See \\ref MXC_Error_Codes for the list of error return codes."]
    pub fn MXC_UART_ClearRXFIFO(uart: *mut mxc_uart_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Removes and discards all bytes currently in the transmit FIFO.\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n\n @return  See \\ref MXC_Error_Codes for the list of error return codes."]
    pub fn MXC_UART_ClearTXFIFO(uart: *mut mxc_uart_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Set the receive threshold level.\n\n @note    RX FIFO Receive threshold. Smaller values will cause\n          interrupts to occur more often, but reduce the possibility\n          of losing data because of a FIFO overflow. Larger values\n          will reduce the time required by the ISR, but increase the\n          possibility of data loss. Passing an invalid value will\n          cause the driver to use the value already set in the\n          appropriate register.\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n @param   numBytes     The threshold level to set. This value must be\n                       between 0 and 8 inclusive.\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_UART_SetRXThreshold(
        uart: *mut mxc_uart_regs_t,
        numBytes: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Get the current receive threshold level.\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n\n @return  The receive threshold value (in bytes)."]
    pub fn MXC_UART_GetRXThreshold(uart: *mut mxc_uart_regs_t) -> ::core::ffi::c_uint;
}
extern "C" {
    #[doc = " @brief   Set the transmit threshold level.\n\n @note    TX FIFO threshold. Smaller values will cause interrupts\n          to occur more often, but reduce the possibility of terminating\n          a transaction early in master mode, or transmitting invalid data\n          in slave mode. Larger values will reduce the time required by\n          the ISR, but increase the possibility errors occurring. Passing\n          an invalid value will cause the driver to use the value already\n          set in the appropriate register.\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n @param   numBytes     The threshold level to set.  This value must be\n                       between 0 and 8 inclusive.\n\n @return  Success/Fail, see \\ref MXC_Error_Codes for a list of return codes."]
    pub fn MXC_UART_SetTXThreshold(
        uart: *mut mxc_uart_regs_t,
        numBytes: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Get the current transmit threshold level.\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n\n @return  The transmit threshold value (in bytes)."]
    pub fn MXC_UART_GetTXThreshold(uart: *mut mxc_uart_regs_t) -> ::core::ffi::c_uint;
}
extern "C" {
    #[doc = " @brief   Gets the interrupt flags that are currently set\n\n @note    These functions should not be used while using non-blocking Transaction Level\n          functions (Async or DMA)\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n\n @return The interrupt flags"]
    pub fn MXC_UART_GetFlags(uart: *mut mxc_uart_regs_t) -> ::core::ffi::c_uint;
}
extern "C" {
    #[doc = " @brief   Clears the interrupt flags that are currently set\n\n @note    These functions should not be used while using non-blocking Transaction Level\n          functions (Async or DMA)\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n @param   flags        mask of flags to clear\n\n @return  See \\ref MXC_Error_Codes for the list of error return codes."]
    pub fn MXC_UART_ClearFlags(
        uart: *mut mxc_uart_regs_t,
        flags: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Enables specific interrupts\n\n @note    These functions should not be used while using non-blocking Transaction Level\n          functions (Async or DMA)\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n @param   mask         The interrupts to be enabled\n\n @return  See \\ref MXC_Error_Codes for the list of error return codes."]
    pub fn MXC_UART_EnableInt(
        uart: *mut mxc_uart_regs_t,
        mask: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Disables specific interrupts\n\n @note    These functions should not be used while using non-blocking Transaction Level\n          functions (Async or DMA)\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n @param   mask         The interrupts to be disabled\n\n @return  See \\ref MXC_Error_Codes for the list of error return codes."]
    pub fn MXC_UART_DisableInt(
        uart: *mut mxc_uart_regs_t,
        mask: ::core::ffi::c_uint,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Gets the status flags that are currently set\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n\n @return  The status flags"]
    pub fn MXC_UART_GetStatus(uart: *mut mxc_uart_regs_t) -> ::core::ffi::c_uint;
}
extern "C" {
    #[doc = " @brief   Performs a blocking UART transaction.\n\n @note    Performs a blocking UART transaction as follows.\n          If tx_len is non-zero, transmit TX data\n          Once tx_len has been sent, if rx_len is non-zero, receive data\n\n @param   req          Pointer to details of the transaction\n\n @return  See \\ref MXC_Error_Codes for the list of error return codes."]
    pub fn MXC_UART_Transaction(req: *mut mxc_uart_req_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Setup an interrupt-driven UART transaction\n\n @note    The TX FIFO will be filled with txData if necessary\n          Relevant interrupts will be enabled\n\n @param   req          Pointer to details of the transaction\n\n @return  See \\ref MXC_Error_Codes for the list of error return codes."]
    pub fn MXC_UART_TransactionAsync(req: *mut mxc_uart_req_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Setup a DMA driven UART transaction\n\n @note    The TX FIFO will be filled with txData if necessary\n          Relevant interrupts will be enabled\n          The DMA channel indicated by the request will be set up to load/unload the FIFOs\n          with as few interrupt-based events as possible. The channel will be reset and\n          returned to the system at the end of the transaction.\n\n @param   req          Pointer to details of the transaction\n\n @return  See \\ref MXC_Error_Codes for the list of error return codes."]
    pub fn MXC_UART_TransactionDMA(req: *mut mxc_uart_req_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   The processing function for DMA transactions.\n\n When using the DMA functions, the application must call this\n function periodically. This can be done from within the DMA Interrupt Handler.\n\n @param   ch          DMA channel\n @param   error       Error status"]
    pub fn MXC_UART_DMACallback(ch: ::core::ffi::c_int, error: ::core::ffi::c_int);
}
extern "C" {
    #[doc = " @brief   Async callback\n\n @param   uart      The uart\n @param   retVal    The ret value\n\n @return  See \\ref MXC_Error_Codes for the list of error return codes."]
    pub fn MXC_UART_AsyncCallback(
        uart: *mut mxc_uart_regs_t,
        retVal: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   stop any async callbacks\n\n @param   uart      The uart\n\n @return  See \\ref MXC_Error_Codes for the list of error return codes."]
    pub fn MXC_UART_AsyncStop(uart: *mut mxc_uart_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Abort any asynchronous requests in progress.\n\n @note    Abort any asynchronous requests in progress. Any callbacks associated with\n          the active transaction will be executed to indicate when the transaction\n          has been terminated.\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n\n @return  See \\ref MXC_Error_Codes for the list of error return codes."]
    pub fn MXC_UART_AbortAsync(uart: *mut mxc_uart_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   The processing function for asynchronous transactions.\n\n @note    When using the asynchronous functions, the application must call this\n          function periodically. This can be done from within the UART interrupt\n          handler or periodically by the application if UART interrupts are disabled.\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n\n @return  See \\ref MXC_Error_Codes for the list of error return codes."]
    pub fn MXC_UART_AsyncHandler(uart: *mut mxc_uart_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief   Provide TXCount for asynchronous transactions..\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n\n @return  Returns transmit bytes (in FIFO)."]
    pub fn MXC_UART_GetAsyncTXCount(req: *mut mxc_uart_req_t) -> u32;
}
extern "C" {
    #[doc = " @brief   Provide RXCount for asynchronous transactions..\n\n @param   uart         Pointer to UART registers (selects the UART block used.)\n\n @return  Returns receive bytes (in FIFO)."]
    pub fn MXC_UART_GetAsyncRXCount(req: *mut mxc_uart_req_t) -> u32;
}
#[doc = " @ingroup wdt_registers\n Structure type to access the WDT Registers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mxc_wdt_regs_t {
    #[doc = "< <tt>\\b 0x00:</tt> WDT CTRL Register"]
    pub ctrl: u32,
    #[doc = "< <tt>\\b 0x04:</tt> WDT RST Register"]
    pub rst: u32,
    #[doc = "< <tt>\\b 0x08:</tt> WDT CLKSEL Register"]
    pub clksel: u32,
    #[doc = "< <tt>\\b 0x0C:</tt> WDT CNT Register"]
    pub cnt: u32,
}
#[test]
fn bindgen_test_layout_mxc_wdt_regs_t() {
    const UNINIT: ::core::mem::MaybeUninit<mxc_wdt_regs_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mxc_wdt_regs_t>(),
        16usize,
        concat!("Size of: ", stringify!(mxc_wdt_regs_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mxc_wdt_regs_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mxc_wdt_regs_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctrl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_wdt_regs_t),
            "::",
            stringify!(ctrl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rst) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_wdt_regs_t),
            "::",
            stringify!(rst)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clksel) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_wdt_regs_t),
            "::",
            stringify!(clksel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cnt) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_wdt_regs_t),
            "::",
            stringify!(cnt)
        )
    );
}
#[doc = "< Period 2^31"]
pub const mxc_wdt_period_t_MXC_WDT_PERIOD_2_31: mxc_wdt_period_t = 0;
#[doc = "< Period 2^30"]
pub const mxc_wdt_period_t_MXC_WDT_PERIOD_2_30: mxc_wdt_period_t = 1;
#[doc = "< Period 2^29"]
pub const mxc_wdt_period_t_MXC_WDT_PERIOD_2_29: mxc_wdt_period_t = 2;
#[doc = "< Period 2^28"]
pub const mxc_wdt_period_t_MXC_WDT_PERIOD_2_28: mxc_wdt_period_t = 3;
#[doc = "< Period 2^27"]
pub const mxc_wdt_period_t_MXC_WDT_PERIOD_2_27: mxc_wdt_period_t = 4;
#[doc = "< Period 2^26"]
pub const mxc_wdt_period_t_MXC_WDT_PERIOD_2_26: mxc_wdt_period_t = 5;
#[doc = "< Period 2^25"]
pub const mxc_wdt_period_t_MXC_WDT_PERIOD_2_25: mxc_wdt_period_t = 6;
#[doc = "< Period 2^24"]
pub const mxc_wdt_period_t_MXC_WDT_PERIOD_2_24: mxc_wdt_period_t = 7;
#[doc = "< Period 2^23"]
pub const mxc_wdt_period_t_MXC_WDT_PERIOD_2_23: mxc_wdt_period_t = 8;
#[doc = "< Period 2^22"]
pub const mxc_wdt_period_t_MXC_WDT_PERIOD_2_22: mxc_wdt_period_t = 9;
#[doc = "< Period 2^21"]
pub const mxc_wdt_period_t_MXC_WDT_PERIOD_2_21: mxc_wdt_period_t = 10;
#[doc = "< Period 2^20"]
pub const mxc_wdt_period_t_MXC_WDT_PERIOD_2_20: mxc_wdt_period_t = 11;
#[doc = "< Period 2^19"]
pub const mxc_wdt_period_t_MXC_WDT_PERIOD_2_19: mxc_wdt_period_t = 12;
#[doc = "< Period 2^18"]
pub const mxc_wdt_period_t_MXC_WDT_PERIOD_2_18: mxc_wdt_period_t = 13;
#[doc = "< Period 2^17"]
pub const mxc_wdt_period_t_MXC_WDT_PERIOD_2_17: mxc_wdt_period_t = 14;
#[doc = "< Period 2^16"]
pub const mxc_wdt_period_t_MXC_WDT_PERIOD_2_16: mxc_wdt_period_t = 15;
#[doc = " @brief Watchdog upper limit period enumeration.\nUsed to configure the period of the watchdog interrupt"]
pub type mxc_wdt_period_t = ::core::ffi::c_uint;
pub const mxc_wdt_int_t_MXC_WDT_INT_TOO_LATE: mxc_wdt_int_t = 512;
pub const mxc_wdt_int_t_MXC_WDT_INT_TOO_SOON: mxc_wdt_int_t = 4096;
#[doc = " @brief Watchdog interrupt flag enumeration"]
pub type mxc_wdt_int_t = ::core::ffi::c_uint;
pub const mxc_wdt_rst_t_MXC_WDT_RST_TOO_LATE: mxc_wdt_rst_t = 2147483648;
pub const mxc_wdt_rst_t_MXC_WDT_RST_TOO_SOON: mxc_wdt_rst_t = 1073741824;
#[doc = " @brief Watchdog reset flag enumeration"]
pub type mxc_wdt_rst_t = ::core::ffi::c_uint;
pub const mxc_wdt_mode_t_MXC_WDT_COMPATIBILITY: mxc_wdt_mode_t = 0;
pub const mxc_wdt_mode_t_MXC_WDT_WINDOWED: mxc_wdt_mode_t = 1;
#[doc = " @brief Watchdog mode enumeration"]
pub type mxc_wdt_mode_t = ::core::ffi::c_uint;
#[doc = " @brief Timer Configuration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mxc_wdt_cfg_t {
    #[doc = "< WDT mode"]
    pub mode: mxc_wdt_mode_t,
    #[doc = "< Reset upper limit"]
    pub upperResetPeriod: mxc_wdt_period_t,
    #[doc = "< Reset lower limit"]
    pub lowerResetPeriod: mxc_wdt_period_t,
    #[doc = "< Interrupt upper limit"]
    pub upperIntPeriod: mxc_wdt_period_t,
    #[doc = "< Interrupt lower limit"]
    pub lowerIntPeriod: mxc_wdt_period_t,
}
#[test]
fn bindgen_test_layout_mxc_wdt_cfg_t() {
    const UNINIT: ::core::mem::MaybeUninit<mxc_wdt_cfg_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mxc_wdt_cfg_t>(),
        20usize,
        concat!("Size of: ", stringify!(mxc_wdt_cfg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mxc_wdt_cfg_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mxc_wdt_cfg_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_wdt_cfg_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).upperResetPeriod) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_wdt_cfg_t),
            "::",
            stringify!(upperResetPeriod)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lowerResetPeriod) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_wdt_cfg_t),
            "::",
            stringify!(lowerResetPeriod)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).upperIntPeriod) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_wdt_cfg_t),
            "::",
            stringify!(upperIntPeriod)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lowerIntPeriod) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mxc_wdt_cfg_t),
            "::",
            stringify!(lowerIntPeriod)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialize the Watchdog Timer\n @param       wdt     Pointer to the watchdog registers\n @param       cfg     watchdog configuration\n @return      See \\ref MXC_Error_Codes for the list of error codes."]
    pub fn MXC_WDT_Init(wdt: *mut mxc_wdt_regs_t, cfg: *mut mxc_wdt_cfg_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Shutdown the Watchdog Timer\n @param       wdt     Pointer to the watchdog registers\n @return      See \\ref MXC_Error_Codes for the list of error codes."]
    pub fn MXC_WDT_Shutdown(wdt: *mut mxc_wdt_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief       Set the period of the watchdog interrupt.\n @param       wdt     Pointer to watchdog registers.\n @param       cfg     watchdog configuration."]
    pub fn MXC_WDT_SetIntPeriod(wdt: *mut mxc_wdt_regs_t, cfg: *mut mxc_wdt_cfg_t);
}
extern "C" {
    #[doc = " @brief       Set the period of the watchdog reset.\n @param       wdt     Pointer to watchdog registers.\n @param       cfg     watchdog configuration."]
    pub fn MXC_WDT_SetResetPeriod(wdt: *mut mxc_wdt_regs_t, cfg: *mut mxc_wdt_cfg_t);
}
extern "C" {
    #[doc = " @brief       Enable the watchdog timer.\n @param       wdt     Pointer to watchdog registers."]
    pub fn MXC_WDT_Enable(wdt: *mut mxc_wdt_regs_t);
}
extern "C" {
    #[doc = " @brief       Disable the watchdog timer.\n @param       wdt     Pointer to watchdog registers."]
    pub fn MXC_WDT_Disable(wdt: *mut mxc_wdt_regs_t);
}
extern "C" {
    #[doc = " @brief       Enable the watchdog interrupt.\n @param       wdt     Pointer to watchdog registers."]
    pub fn MXC_WDT_EnableInt(wdt: *mut mxc_wdt_regs_t);
}
extern "C" {
    #[doc = " @brief       Disable the watchdog interrupt.\n @param       wdt     Pointer to watchdog registers."]
    pub fn MXC_WDT_DisableInt(wdt: *mut mxc_wdt_regs_t);
}
extern "C" {
    #[doc = " @brief       Enable the watchdog reset.\n @param       wdt     Pointer to watchdog registers."]
    pub fn MXC_WDT_EnableReset(wdt: *mut mxc_wdt_regs_t);
}
extern "C" {
    #[doc = " @brief       Disable the watchdog reset.\n @param       wdt     Pointer to watchdog registers."]
    pub fn MXC_WDT_DisableReset(wdt: *mut mxc_wdt_regs_t);
}
extern "C" {
    #[doc = " @brief       Reset the watchdog timer.\n @param       wdt     Pointer to watchdog registers."]
    pub fn MXC_WDT_ResetTimer(wdt: *mut mxc_wdt_regs_t);
}
extern "C" {
    #[doc = " @brief       Get the status of the reset flag.\n @param       wdt     Pointer to watchdog registers.\n @returns     1 if the previous reset was caused by the watchdog, 0 otherwise."]
    pub fn MXC_WDT_GetResetFlag(wdt: *mut mxc_wdt_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief       Clears the reset flag.\n @param       wdt     Pointer to watchdog registers."]
    pub fn MXC_WDT_ClearResetFlag(wdt: *mut mxc_wdt_regs_t);
}
extern "C" {
    #[doc = " @brief       Get the status of the interrupt flag.\n @param       wdt     Pointer to watchdog registers.\n @returns     1 if the interrupt is pending, 0 otherwise."]
    pub fn MXC_WDT_GetIntFlag(wdt: *mut mxc_wdt_regs_t) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief       Clears the interrupt flag.\n @param       wdt     Pointer to watchdog registers."]
    pub fn MXC_WDT_ClearIntFlag(wdt: *mut mxc_wdt_regs_t);
}
