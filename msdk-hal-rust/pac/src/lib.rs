# ! [doc = "Peripheral access API for MAX78000 microcontrollers (generated using svd2rust v0.31.5 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.31.5/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"] # ! [allow (non_camel_case_types)] # ! [allow (non_snake_case)] # ! [no_std] use core :: marker :: PhantomData ; use core :: ops :: Deref ; # [doc = r"Number available in the NVIC for configuring priority"] pub const NVIC_PRIO_BITS : u8 = 3 ; # [allow (unused_imports)] use generic :: * ; # [doc = r"Common register and bit access and modify traits"] pub mod generic ; # [cfg (feature = "rt")] extern "C" { fn TMR0 () ; } # [doc (hidden)] # [repr (C)] pub union Vector { _handler : unsafe extern "C" fn () , _reserved : u32 , } # [cfg (feature = "rt")] # [doc (hidden)] # [link_section = ".vector_table.interrupts"] # [no_mangle] pub static __INTERRUPTS : [Vector ; 2] = [Vector { _reserved : 0 } , Vector { _handler : TMR0 }] ; # [doc = r"Enumeration of all the interrupts."] # [derive (Copy , Clone , Debug , PartialEq , Eq)] # [repr (u16)] pub enum Interrupt { # [doc = "1 - TMR0"] TMR0 = 1 , } unsafe impl cortex_m :: interrupt :: InterruptNumber for Interrupt { # [inline (always)] fn number (self) -> u16 { self as u16 } } # [doc = "Low-Power Configurable Timer"] pub struct TMR0 { _marker : PhantomData < * const () > , } unsafe impl Send for TMR0 { } impl TMR0 { # [doc = r"Pointer to the register block"] pub const PTR : * const tmr0 :: RegisterBlock = 0x4001_0000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const tmr0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData , } } } impl Deref for TMR0 { type Target = tmr0 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for TMR0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TMR0") . finish () } } # [doc = "Low-Power Configurable Timer"] pub mod tmr0 ; # [doc = "UART Low Power Registers"] pub struct UART0 { _marker : PhantomData < * const () > , } unsafe impl Send for UART0 { } impl UART0 { # [doc = r"Pointer to the register block"] pub const PTR : * const uart0 :: RegisterBlock = 0x4004_2000 as * const _ ; # [doc = r"Return the pointer to the register block"] # [inline (always)] pub const fn ptr () -> * const uart0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"] # [doc = r" that may race with any existing instances, for example by only"] # [doc = r" accessing read-only or write-only registers, or by consuming the"] # [doc = r" original peripheral and using critical sections to coordinate"] # [doc = r" access between multiple new instances."] # [doc = r""] # [doc = r" Additionally, other software such as HALs may rely on only one"] # [doc = r" peripheral instance existing to ensure memory safety; ensure"] # [doc = r" no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : PhantomData , } } } impl Deref for UART0 { type Target = uart0 :: RegisterBlock ; # [inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for UART0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("UART0") . finish () } } # [doc = "UART Low Power Registers"] pub mod uart0 ; # [no_mangle] static mut DEVICE_PERIPHERALS : bool = false ; # [doc = r" All the peripherals."] # [allow (non_snake_case)] pub struct Peripherals { # [doc = "TMR0"] pub TMR0 : TMR0 , # [doc = "UART0"] pub UART0 : UART0 , } impl Peripherals { # [doc = r" Returns all the peripherals *once*."] # [cfg (feature = "critical-section")] # [inline] pub fn take () -> Option < Self > { critical_section :: with (| _ | { if unsafe { DEVICE_PERIPHERALS } { return None ; } Some (unsafe { Peripherals :: steal () }) }) } # [doc = r" Unchecked version of `Peripherals::take`."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Each of the returned peripherals must be used at most once."] # [inline] pub unsafe fn steal () -> Self { DEVICE_PERIPHERALS = true ; Peripherals { TMR0 : TMR0 { _marker : PhantomData , } , UART0 : UART0 { _marker : PhantomData , } , } } }