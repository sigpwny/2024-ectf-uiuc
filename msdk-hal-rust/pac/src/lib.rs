#![doc = "Peripheral access API for MAX78000 microcontrollers (generated using svd2rust v0.31.5 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.31.5/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 3;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic {
    use core::marker;
    #[doc = " Raw register type (`u8`, `u16`, `u32`, ...)"]
    pub trait RawReg:
        Copy
        + Default
        + From<bool>
        + core::ops::BitOr<Output = Self>
        + core::ops::BitAnd<Output = Self>
        + core::ops::BitOrAssign
        + core::ops::BitAndAssign
        + core::ops::Not<Output = Self>
        + core::ops::Shl<u8, Output = Self>
    {
        #[doc = " Mask for bits of width `WI`"]
        fn mask<const WI: u8>() -> Self;
        #[doc = " Mask for bits of width 1"]
        fn one() -> Self;
    }
    macro_rules! raw_reg {
        ($ U : ty , $ size : literal , $ mask : ident) => {
            impl RawReg for $U {
                #[inline(always)]
                fn mask<const WI: u8>() -> Self {
                    $mask::<WI>()
                }
                #[inline(always)]
                fn one() -> Self {
                    1
                }
            }
            const fn $mask<const WI: u8>() -> $U {
                <$U>::MAX >> ($size - WI)
            }
            impl FieldSpec for $U {
                type Ux = $U;
            }
        };
    }
    raw_reg!(u8, 8, mask_u8);
    raw_reg!(u16, 16, mask_u16);
    raw_reg!(u32, 32, mask_u32);
    raw_reg!(u64, 64, mask_u64);
    #[doc = " Raw register type"]
    pub trait RegisterSpec {
        #[doc = " Raw register type (`u8`, `u16`, `u32`, ...)."]
        type Ux: RawReg;
    }
    #[doc = " Raw field type"]
    pub trait FieldSpec: Sized {
        #[doc = " Raw field type (`u8`, `u16`, `u32`, ...)."]
        type Ux: Copy + PartialEq + From<Self>;
    }
    #[doc = " Trait implemented by readable registers to enable the `read` method."]
    #[doc = ""]
    #[doc = " Registers marked with `Writable` can be also be `modify`'ed."]
    pub trait Readable: RegisterSpec {}
    #[doc = " Trait implemented by writeable registers."]
    #[doc = ""]
    #[doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
    #[doc = ""]
    #[doc = " Registers marked with `Readable` can be also be `modify`'ed."]
    pub trait Writable: RegisterSpec {
        #[doc = " Specifies the register bits that are not changed if you pass `1` and are changed if you pass `0`"]
        const ZERO_TO_MODIFY_FIELDS_BITMAP: Self::Ux;
        #[doc = " Specifies the register bits that are not changed if you pass `0` and are changed if you pass `1`"]
        const ONE_TO_MODIFY_FIELDS_BITMAP: Self::Ux;
    }
    #[doc = " Reset value of the register."]
    #[doc = ""]
    #[doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
    #[doc = " register by using the `reset` method."]
    pub trait Resettable: RegisterSpec {
        #[doc = " Reset value of the register."]
        const RESET_VALUE: Self::Ux;
        #[doc = " Reset value of the register."]
        #[inline(always)]
        fn reset_value() -> Self::Ux {
            Self::RESET_VALUE
        }
    }
    #[doc = " This structure provides volatile access to registers."]
    #[repr(transparent)]
    pub struct Reg<REG: RegisterSpec> {
        register: vcell::VolatileCell<REG::Ux>,
        _marker: marker::PhantomData<REG>,
    }
    unsafe impl<REG: RegisterSpec> Send for Reg<REG> where REG::Ux: Send {}
    impl<REG: RegisterSpec> Reg<REG> {
        #[doc = " Returns the underlying memory address of register."]
        #[doc = ""]
        #[doc = " ```ignore"]
        #[doc = " let reg_ptr = periph.reg.as_ptr();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn as_ptr(&self) -> *mut REG::Ux {
            self.register.as_ptr()
        }
    }
    impl<REG: Readable> Reg<REG> {
        #[doc = " Reads the contents of a `Readable` register."]
        #[doc = ""]
        #[doc = " You can read the raw contents of a register by using `bits`:"]
        #[doc = " ```ignore"]
        #[doc = " let bits = periph.reg.read().bits();"]
        #[doc = " ```"]
        #[doc = " or get the content of a particular field of a register:"]
        #[doc = " ```ignore"]
        #[doc = " let reader = periph.reg.read();"]
        #[doc = " let bits = reader.field1().bits();"]
        #[doc = " let flag = reader.field2().bit_is_set();"]
        #[doc = " ```"]
        #[inline(always)]
        pub fn read(&self) -> R<REG> {
            R {
                bits: self.register.get(),
                _reg: marker::PhantomData,
            }
        }
    }
    impl<REG: Resettable + Writable> Reg<REG> {
        #[doc = " Writes the reset value to `Writable` register."]
        #[doc = ""]
        #[doc = " Resets the register to its initial state."]
        #[inline(always)]
        pub fn reset(&self) {
            self.register.set(REG::RESET_VALUE)
        }
        #[doc = " Writes bits to a `Writable` register."]
        #[doc = ""]
        #[doc = " You can write raw bits into a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
        #[doc = " ```"]
        #[doc = " or write only the fields you need:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.write(|w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT)"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " In the latter case, other fields will be set to their reset value."]
        #[inline(always)]
        pub fn write<F>(&self, f: F)
        where
            F: FnOnce(&mut W<REG>) -> &mut W<REG>,
        {
            self.register.set(
                f(&mut W {
                    bits: REG::RESET_VALUE & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                        | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                    _reg: marker::PhantomData,
                })
                .bits,
            );
        }
    }
    impl<REG: Writable> Reg<REG> {
        #[doc = " Writes 0 to a `Writable` register."]
        #[doc = ""]
        #[doc = " Similar to `write`, but unused bits will contain 0."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Unsafe to use with registers which don't allow to write 0."]
        #[inline(always)]
        pub unsafe fn write_with_zero<F>(&self, f: F)
        where
            F: FnOnce(&mut W<REG>) -> &mut W<REG>,
        {
            self.register.set(
                f(&mut W {
                    bits: REG::Ux::default(),
                    _reg: marker::PhantomData,
                })
                .bits,
            );
        }
    }
    impl<REG: Readable + Writable> Reg<REG> {
        #[doc = " Modifies the contents of the register by reading and then writing it."]
        #[doc = ""]
        #[doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
        #[doc = "    r.bits() | 3"]
        #[doc = " ) });"]
        #[doc = " ```"]
        #[doc = " or"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| w"]
        #[doc = "     .field1().bits(newfield1bits)"]
        #[doc = "     .field2().set_bit()"]
        #[doc = "     .field3().variant(VARIANT)"]
        #[doc = " );"]
        #[doc = " ```"]
        #[doc = " or an alternative way of saying the same:"]
        #[doc = " ```ignore"]
        #[doc = " periph.reg.modify(|_, w| {"]
        #[doc = "     w.field1().bits(newfield1bits);"]
        #[doc = "     w.field2().set_bit();"]
        #[doc = "     w.field3().variant(VARIANT)"]
        #[doc = " });"]
        #[doc = " ```"]
        #[doc = " Other fields will have the value they had before the call to `modify`."]
        #[inline(always)]
        pub fn modify<F>(&self, f: F)
        where
            for<'w> F: FnOnce(&R<REG>, &'w mut W<REG>) -> &'w mut W<REG>,
        {
            let bits = self.register.get();
            self.register.set(
                f(
                    &R {
                        bits,
                        _reg: marker::PhantomData,
                    },
                    &mut W {
                        bits: bits & !REG::ONE_TO_MODIFY_FIELDS_BITMAP
                            | REG::ZERO_TO_MODIFY_FIELDS_BITMAP,
                        _reg: marker::PhantomData,
                    },
                )
                .bits,
            );
        }
    }
    #[doc(hidden)]
    pub mod raw {
        use super::{marker, BitM, FieldSpec, RegisterSpec, Unsafe, Writable};
        pub struct R<REG: RegisterSpec> {
            pub(crate) bits: REG::Ux,
            pub(super) _reg: marker::PhantomData<REG>,
        }
        pub struct W<REG: RegisterSpec> {
            #[doc = "Writable bits"]
            pub(crate) bits: REG::Ux,
            pub(super) _reg: marker::PhantomData<REG>,
        }
        pub struct FieldReader<FI = u8>
        where
            FI: FieldSpec,
        {
            pub(crate) bits: FI::Ux,
            _reg: marker::PhantomData<FI>,
        }
        impl<FI: FieldSpec> FieldReader<FI> {
            #[doc = " Creates a new instance of the reader."]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) const fn new(bits: FI::Ux) -> Self {
                Self {
                    bits,
                    _reg: marker::PhantomData,
                }
            }
        }
        pub struct BitReader<FI = bool> {
            pub(crate) bits: bool,
            _reg: marker::PhantomData<FI>,
        }
        impl<FI> BitReader<FI> {
            #[doc = " Creates a new instance of the reader."]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) const fn new(bits: bool) -> Self {
                Self {
                    bits,
                    _reg: marker::PhantomData,
                }
            }
        }
        pub struct FieldWriter<'a, REG, const WI: u8, FI = u8, Safety = Unsafe>
        where
            REG: Writable + RegisterSpec,
            FI: FieldSpec,
        {
            pub(crate) w: &'a mut W<REG>,
            pub(crate) o: u8,
            _field: marker::PhantomData<(FI, Safety)>,
        }
        impl<'a, REG, const WI: u8, FI, Safety> FieldWriter<'a, REG, WI, FI, Safety>
        where
            REG: Writable + RegisterSpec,
            FI: FieldSpec,
        {
            #[doc = " Creates a new instance of the writer"]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) fn new(w: &'a mut W<REG>, o: u8) -> Self {
                Self {
                    w,
                    o,
                    _field: marker::PhantomData,
                }
            }
        }
        pub struct BitWriter<'a, REG, FI = bool, M = BitM>
        where
            REG: Writable + RegisterSpec,
            bool: From<FI>,
        {
            pub(crate) w: &'a mut W<REG>,
            pub(crate) o: u8,
            _field: marker::PhantomData<(FI, M)>,
        }
        impl<'a, REG, FI, M> BitWriter<'a, REG, FI, M>
        where
            REG: Writable + RegisterSpec,
            bool: From<FI>,
        {
            #[doc = " Creates a new instance of the writer"]
            #[allow(unused)]
            #[inline(always)]
            pub(crate) fn new(w: &'a mut W<REG>, o: u8) -> Self {
                Self {
                    w,
                    o,
                    _field: marker::PhantomData,
                }
            }
        }
    }
    #[doc = " Register reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
    #[doc = " method."]
    pub type R<REG> = raw::R<REG>;
    impl<REG: RegisterSpec> R<REG> {
        #[doc = " Reads raw bits from register."]
        #[inline(always)]
        pub const fn bits(&self) -> REG::Ux {
            self.bits
        }
    }
    impl<REG: RegisterSpec, FI> PartialEq<FI> for R<REG>
    where
        REG::Ux: PartialEq,
        FI: Copy,
        REG::Ux: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&REG::Ux::from(*other))
        }
    }
    #[doc = " Register writer."]
    #[doc = ""]
    #[doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."]
    pub type W<REG> = raw::W<REG>;
    #[doc = " Field reader."]
    #[doc = ""]
    #[doc = " Result of the `read` methods of fields."]
    pub type FieldReader<FI = u8> = raw::FieldReader<FI>;
    #[doc = " Bit-wise field reader"]
    pub type BitReader<FI = bool> = raw::BitReader<FI>;
    impl<FI: FieldSpec> FieldReader<FI> {
        #[doc = " Reads raw bits from field."]
        #[inline(always)]
        pub const fn bits(&self) -> FI::Ux {
            self.bits
        }
    }
    impl<FI> PartialEq<FI> for FieldReader<FI>
    where
        FI: FieldSpec + Copy,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&FI::Ux::from(*other))
        }
    }
    impl<FI> PartialEq<FI> for BitReader<FI>
    where
        FI: Copy,
        bool: From<FI>,
    {
        #[inline(always)]
        fn eq(&self, other: &FI) -> bool {
            self.bits.eq(&bool::from(*other))
        }
    }
    impl<FI> BitReader<FI> {
        #[doc = " Value of the field as raw bits."]
        #[inline(always)]
        pub const fn bit(&self) -> bool {
            self.bits
        }
        #[doc = " Returns `true` if the bit is clear (0)."]
        #[inline(always)]
        pub const fn bit_is_clear(&self) -> bool {
            !self.bit()
        }
        #[doc = " Returns `true` if the bit is set (1)."]
        #[inline(always)]
        pub const fn bit_is_set(&self) -> bool {
            self.bit()
        }
    }
    #[doc(hidden)]
    pub struct Safe;
    #[doc(hidden)]
    pub struct Unsafe;
    #[doc = " Write field Proxy with unsafe `bits`"]
    pub type FieldWriter<'a, REG, const WI: u8, FI = u8> =
        raw::FieldWriter<'a, REG, WI, FI, Unsafe>;
    #[doc = " Write field Proxy with safe `bits`"]
    pub type FieldWriterSafe<'a, REG, const WI: u8, FI = u8> =
        raw::FieldWriter<'a, REG, WI, FI, Safe>;
    impl<'a, REG, const WI: u8, FI> FieldWriter<'a, REG, WI, FI>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
    {
        #[doc = " Field width"]
        pub const WIDTH: u8 = WI;
        #[doc = " Field width"]
        #[inline(always)]
        pub const fn width(&self) -> u8 {
            WI
        }
        #[doc = " Field offset"]
        #[inline(always)]
        pub const fn offset(&self) -> u8 {
            self.o
        }
        #[doc = " Writes raw bits to the field"]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
        #[inline(always)]
        pub unsafe fn bits(self, value: FI::Ux) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::mask::<WI>() << self.o);
            self.w.bits |= (REG::Ux::from(value) & REG::Ux::mask::<WI>()) << self.o;
            self.w
        }
        #[doc = " Writes `variant` to the field"]
        #[inline(always)]
        pub fn variant(self, variant: FI) -> &'a mut W<REG> {
            unsafe { self.bits(FI::Ux::from(variant)) }
        }
    }
    impl<'a, REG, const WI: u8, FI> FieldWriterSafe<'a, REG, WI, FI>
    where
        REG: Writable + RegisterSpec,
        FI: FieldSpec,
        REG::Ux: From<FI::Ux>,
    {
        #[doc = " Field width"]
        pub const WIDTH: u8 = WI;
        #[doc = " Field width"]
        #[inline(always)]
        pub const fn width(&self) -> u8 {
            WI
        }
        #[doc = " Field offset"]
        #[inline(always)]
        pub const fn offset(&self) -> u8 {
            self.o
        }
        #[doc = " Writes raw bits to the field"]
        #[inline(always)]
        pub fn bits(self, value: FI::Ux) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::mask::<WI>() << self.o);
            self.w.bits |= (REG::Ux::from(value) & REG::Ux::mask::<WI>()) << self.o;
            self.w
        }
        #[doc = " Writes `variant` to the field"]
        #[inline(always)]
        pub fn variant(self, variant: FI) -> &'a mut W<REG> {
            self.bits(FI::Ux::from(variant))
        }
    }
    macro_rules! bit_proxy {
        ($ writer : ident , $ mwv : ident) => {
            #[doc(hidden)]
            pub struct $mwv;
            #[doc = " Bit-wise write field proxy"]
            pub type $writer<'a, REG, FI = bool> = raw::BitWriter<'a, REG, FI, $mwv>;
            impl<'a, REG, FI> $writer<'a, REG, FI>
            where
                REG: Writable + RegisterSpec,
                bool: From<FI>,
            {
                #[doc = " Field width"]
                pub const WIDTH: u8 = 1;
                #[doc = " Field width"]
                #[inline(always)]
                pub const fn width(&self) -> u8 {
                    Self::WIDTH
                }
                #[doc = " Field offset"]
                #[inline(always)]
                pub const fn offset(&self) -> u8 {
                    self.o
                }
                #[doc = " Writes bit to the field"]
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W<REG> {
                    self.w.bits &= !(REG::Ux::one() << self.o);
                    self.w.bits |= (REG::Ux::from(value) & REG::Ux::one()) << self.o;
                    self.w
                }
                #[doc = " Writes `variant` to the field"]
                #[inline(always)]
                pub fn variant(self, variant: FI) -> &'a mut W<REG> {
                    self.bit(bool::from(variant))
                }
            }
        };
    }
    bit_proxy!(BitWriter, BitM);
    bit_proxy!(BitWriter1S, Bit1S);
    bit_proxy!(BitWriter0C, Bit0C);
    bit_proxy!(BitWriter1C, Bit1C);
    bit_proxy!(BitWriter0S, Bit0S);
    bit_proxy!(BitWriter1T, Bit1T);
    bit_proxy!(BitWriter0T, Bit0T);
    impl<'a, REG, FI> BitWriter<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Sets the field bit"]
        #[inline(always)]
        pub fn set_bit(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::one() << self.o;
            self.w
        }
        #[doc = " Clears the field bit"]
        #[inline(always)]
        pub fn clear_bit(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::one() << self.o);
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter1S<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Sets the field bit"]
        #[inline(always)]
        pub fn set_bit(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::one() << self.o;
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter0C<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = " Clears the field bit"]
        #[inline(always)]
        pub fn clear_bit(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::one() << self.o);
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter1C<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Clears the field bit by passing one"]
        #[inline(always)]
        pub fn clear_bit_by_one(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::one() << self.o;
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter0S<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Sets the field bit by passing zero"]
        #[inline(always)]
        pub fn set_bit_by_zero(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::one() << self.o);
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter1T<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Toggle the field bit by passing one"]
        #[inline(always)]
        pub fn toggle_bit(self) -> &'a mut W<REG> {
            self.w.bits |= REG::Ux::one() << self.o;
            self.w
        }
    }
    impl<'a, REG, FI> BitWriter0T<'a, REG, FI>
    where
        REG: Writable + RegisterSpec,
        bool: From<FI>,
    {
        #[doc = "Toggle the field bit by passing zero"]
        #[inline(always)]
        pub fn toggle_bit(self) -> &'a mut W<REG> {
            self.w.bits &= !(REG::Ux::one() << self.o);
            self.w
        }
    }
}
#[cfg(feature = "rt")]
extern "C" {
    fn TMR0();
}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 2] = [Vector { _reserved: 0 }, Vector { _handler: TMR0 }];
#[doc = r"Enumeration of all the interrupts."]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum Interrupt {
    #[doc = "1 - TMR0"]
    TMR0 = 1,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[doc = "Low-Power Configurable Timer"]
pub struct TMR0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TMR0 {}
impl TMR0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tmr0::RegisterBlock = 0x4001_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tmr0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for TMR0 {
    type Target = tmr0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TMR0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TMR0").finish()
    }
}
#[doc = "Low-Power Configurable Timer"]
pub mod tmr0 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        cnt: CNT,
        cmp: CMP,
        pwm: PWM,
        intfl: INTFL,
        ctrl0: CTRL0,
        nolcmp: NOLCMP,
        ctrl1: CTRL1,
        wkfl: WKFL,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Timer Counter Register."]
        #[inline(always)]
        pub const fn cnt(&self) -> &CNT {
            &self.cnt
        }
        #[doc = "0x04 - Timer Compare Register."]
        #[inline(always)]
        pub const fn cmp(&self) -> &CMP {
            &self.cmp
        }
        #[doc = "0x08 - Timer PWM Register."]
        #[inline(always)]
        pub const fn pwm(&self) -> &PWM {
            &self.pwm
        }
        #[doc = "0x0c - Timer Interrupt Status Register."]
        #[inline(always)]
        pub const fn intfl(&self) -> &INTFL {
            &self.intfl
        }
        #[doc = "0x10 - Timer Control Register."]
        #[inline(always)]
        pub const fn ctrl0(&self) -> &CTRL0 {
            &self.ctrl0
        }
        #[doc = "0x14 - Timer Non-Overlapping Compare Register."]
        #[inline(always)]
        pub const fn nolcmp(&self) -> &NOLCMP {
            &self.nolcmp
        }
        #[doc = "0x18 - Timer Configuration Register."]
        #[inline(always)]
        pub const fn ctrl1(&self) -> &CTRL1 {
            &self.ctrl1
        }
        #[doc = "0x1c - Timer Wakeup Status Register."]
        #[inline(always)]
        pub const fn wkfl(&self) -> &WKFL {
            &self.wkfl
        }
    }
    #[doc = "CNT (rw) register accessor: Timer Counter Register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cnt::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt`]
module"]
    pub type CNT = crate::Reg<cnt::CNT_SPEC>;
    #[doc = "Timer Counter Register."]
    pub mod cnt {
        #[doc = "Register `CNT` reader"]
        pub type R = crate::R<CNT_SPEC>;
        #[doc = "Register `CNT` writer"]
        pub type W = crate::W<CNT_SPEC>;
        #[doc = "Field `COUNT` reader - The current count value for the timer. This field increments as the timer counts."]
        pub type COUNT_R = crate::FieldReader<u32>;
        #[doc = "Field `COUNT` writer - The current count value for the timer. This field increments as the timer counts."]
        pub type COUNT_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - The current count value for the timer. This field increments as the timer counts."]
            #[inline(always)]
            pub fn count(&self) -> COUNT_R {
                COUNT_R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - The current count value for the timer. This field increments as the timer counts."]
            #[inline(always)]
            #[must_use]
            pub fn count(&mut self) -> COUNT_W<CNT_SPEC> {
                COUNT_W::new(self, 0)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Timer Counter Register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cnt::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cnt::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CNT_SPEC;
        impl crate::RegisterSpec for CNT_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cnt::R`](R) reader structure"]
        impl crate::Readable for CNT_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`cnt::W`](W) writer structure"]
        impl crate::Writable for CNT_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets CNT to value 0"]
        impl crate::Resettable for CNT_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "CMP (rw) register accessor: Timer Compare Register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cmp::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cmp::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmp`]
module"]
    pub type CMP = crate::Reg<cmp::CMP_SPEC>;
    #[doc = "Timer Compare Register."]
    pub mod cmp {
        #[doc = "Register `CMP` reader"]
        pub type R = crate::R<CMP_SPEC>;
        #[doc = "Register `CMP` writer"]
        pub type W = crate::W<CMP_SPEC>;
        #[doc = "Field `COMPARE` reader - The value in this register is used as the compare value for the timer's count value. The compare field meaning is determined by the specific mode of the timer."]
        pub type COMPARE_R = crate::FieldReader<u32>;
        #[doc = "Field `COMPARE` writer - The value in this register is used as the compare value for the timer's count value. The compare field meaning is determined by the specific mode of the timer."]
        pub type COMPARE_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - The value in this register is used as the compare value for the timer's count value. The compare field meaning is determined by the specific mode of the timer."]
            #[inline(always)]
            pub fn compare(&self) -> COMPARE_R {
                COMPARE_R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - The value in this register is used as the compare value for the timer's count value. The compare field meaning is determined by the specific mode of the timer."]
            #[inline(always)]
            #[must_use]
            pub fn compare(&mut self) -> COMPARE_W<CMP_SPEC> {
                COMPARE_W::new(self, 0)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Timer Compare Register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`cmp::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`cmp::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CMP_SPEC;
        impl crate::RegisterSpec for CMP_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cmp::R`](R) reader structure"]
        impl crate::Readable for CMP_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`cmp::W`](W) writer structure"]
        impl crate::Writable for CMP_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets CMP to value 0"]
        impl crate::Resettable for CMP_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PWM (rw) register accessor: Timer PWM Register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`pwm::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pwm`]
module"]
    pub type PWM = crate::Reg<pwm::PWM_SPEC>;
    #[doc = "Timer PWM Register."]
    pub mod pwm {
        #[doc = "Register `PWM` reader"]
        pub type R = crate::R<PWM_SPEC>;
        #[doc = "Register `PWM` writer"]
        pub type W = crate::W<PWM_SPEC>;
        #[doc = "Field `PWM` reader - Timer PWM Match: In PWM Mode, this field sets the count value for the first transition period of the PWM cycle. At the end of the cycle where CNT equals PWM, the PWM output transitions to the second period of the PWM cycle. The second PWM period count is stored in the CMP register. The value set for PWM must me less than the value set in CMP for PWM mode operation. Timer Capture Value: In Capture, Compare, and Capture/Compare modes, this field is used to store the CNT value when a Capture, Compare, or Capture/Compare event occurs."]
        pub type PWM_R = crate::FieldReader<u32>;
        #[doc = "Field `PWM` writer - Timer PWM Match: In PWM Mode, this field sets the count value for the first transition period of the PWM cycle. At the end of the cycle where CNT equals PWM, the PWM output transitions to the second period of the PWM cycle. The second PWM period count is stored in the CMP register. The value set for PWM must me less than the value set in CMP for PWM mode operation. Timer Capture Value: In Capture, Compare, and Capture/Compare modes, this field is used to store the CNT value when a Capture, Compare, or Capture/Compare event occurs."]
        pub type PWM_W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - Timer PWM Match: In PWM Mode, this field sets the count value for the first transition period of the PWM cycle. At the end of the cycle where CNT equals PWM, the PWM output transitions to the second period of the PWM cycle. The second PWM period count is stored in the CMP register. The value set for PWM must me less than the value set in CMP for PWM mode operation. Timer Capture Value: In Capture, Compare, and Capture/Compare modes, this field is used to store the CNT value when a Capture, Compare, or Capture/Compare event occurs."]
            #[inline(always)]
            pub fn pwm(&self) -> PWM_R {
                PWM_R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - Timer PWM Match: In PWM Mode, this field sets the count value for the first transition period of the PWM cycle. At the end of the cycle where CNT equals PWM, the PWM output transitions to the second period of the PWM cycle. The second PWM period count is stored in the CMP register. The value set for PWM must me less than the value set in CMP for PWM mode operation. Timer Capture Value: In Capture, Compare, and Capture/Compare modes, this field is used to store the CNT value when a Capture, Compare, or Capture/Compare event occurs."]
            #[inline(always)]
            #[must_use]
            pub fn pwm(&mut self) -> PWM_W<PWM_SPEC> {
                PWM_W::new(self, 0)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Timer PWM Register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`pwm::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pwm::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PWM_SPEC;
        impl crate::RegisterSpec for PWM_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pwm::R`](R) reader structure"]
        impl crate::Readable for PWM_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`pwm::W`](W) writer structure"]
        impl crate::Writable for PWM_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PWM to value 0"]
        impl crate::Resettable for PWM_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "INTFL (rw) register accessor: Timer Interrupt Status Register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`intfl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`intfl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@intfl`]
module"]
    pub type INTFL = crate::Reg<intfl::INTFL_SPEC>;
    #[doc = "Timer Interrupt Status Register."]
    pub mod intfl {
        #[doc = "Register `INTFL` reader"]
        pub type R = crate::R<INTFL_SPEC>;
        #[doc = "Register `INTFL` writer"]
        pub type W = crate::W<INTFL_SPEC>;
        #[doc = "Field `IRQ_A` reader - Interrupt Flag for Timer A."]
        pub type IRQ_A_R = crate::BitReader;
        #[doc = "Field `IRQ_A` writer - Interrupt Flag for Timer A."]
        pub type IRQ_A_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WRDONE_A` reader - Write Done Flag for Timer A indicating the write is complete from APB to CLK_TMR domain."]
        pub type WRDONE_A_R = crate::BitReader;
        #[doc = "Field `WRDONE_A` writer - Write Done Flag for Timer A indicating the write is complete from APB to CLK_TMR domain."]
        pub type WRDONE_A_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WR_DIS_A` reader - Write Disable to CNT/PWM for Timer A in the non-cascaded dual timer configuration."]
        pub type WR_DIS_A_R = crate::BitReader;
        #[doc = "Field `WR_DIS_A` writer - Write Disable to CNT/PWM for Timer A in the non-cascaded dual timer configuration."]
        pub type WR_DIS_A_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IRQ_B` reader - Interrupt Flag for Timer B."]
        pub type IRQ_B_R = crate::BitReader;
        #[doc = "Field `IRQ_B` writer - Interrupt Flag for Timer B."]
        pub type IRQ_B_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WRDONE_B` reader - Write Done Flag for Timer B indicating the write is complete from APB to CLK_TMR domain."]
        pub type WRDONE_B_R = crate::BitReader;
        #[doc = "Field `WRDONE_B` writer - Write Done Flag for Timer B indicating the write is complete from APB to CLK_TMR domain."]
        pub type WRDONE_B_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WR_DIS_B` reader - Write Disable to CNT/PWM for Timer B in the non-cascaded dual timer configuration."]
        pub type WR_DIS_B_R = crate::BitReader;
        #[doc = "Field `WR_DIS_B` writer - Write Disable to CNT/PWM for Timer B in the non-cascaded dual timer configuration."]
        pub type WR_DIS_B_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Interrupt Flag for Timer A."]
            #[inline(always)]
            pub fn irq_a(&self) -> IRQ_A_R {
                IRQ_A_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 8 - Write Done Flag for Timer A indicating the write is complete from APB to CLK_TMR domain."]
            #[inline(always)]
            pub fn wrdone_a(&self) -> WRDONE_A_R {
                WRDONE_A_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Write Disable to CNT/PWM for Timer A in the non-cascaded dual timer configuration."]
            #[inline(always)]
            pub fn wr_dis_a(&self) -> WR_DIS_A_R {
                WR_DIS_A_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 16 - Interrupt Flag for Timer B."]
            #[inline(always)]
            pub fn irq_b(&self) -> IRQ_B_R {
                IRQ_B_R::new(((self.bits >> 16) & 1) != 0)
            }
            #[doc = "Bit 24 - Write Done Flag for Timer B indicating the write is complete from APB to CLK_TMR domain."]
            #[inline(always)]
            pub fn wrdone_b(&self) -> WRDONE_B_R {
                WRDONE_B_R::new(((self.bits >> 24) & 1) != 0)
            }
            #[doc = "Bit 25 - Write Disable to CNT/PWM for Timer B in the non-cascaded dual timer configuration."]
            #[inline(always)]
            pub fn wr_dis_b(&self) -> WR_DIS_B_R {
                WR_DIS_B_R::new(((self.bits >> 25) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Interrupt Flag for Timer A."]
            #[inline(always)]
            #[must_use]
            pub fn irq_a(&mut self) -> IRQ_A_W<INTFL_SPEC> {
                IRQ_A_W::new(self, 0)
            }
            #[doc = "Bit 8 - Write Done Flag for Timer A indicating the write is complete from APB to CLK_TMR domain."]
            #[inline(always)]
            #[must_use]
            pub fn wrdone_a(&mut self) -> WRDONE_A_W<INTFL_SPEC> {
                WRDONE_A_W::new(self, 8)
            }
            #[doc = "Bit 9 - Write Disable to CNT/PWM for Timer A in the non-cascaded dual timer configuration."]
            #[inline(always)]
            #[must_use]
            pub fn wr_dis_a(&mut self) -> WR_DIS_A_W<INTFL_SPEC> {
                WR_DIS_A_W::new(self, 9)
            }
            #[doc = "Bit 16 - Interrupt Flag for Timer B."]
            #[inline(always)]
            #[must_use]
            pub fn irq_b(&mut self) -> IRQ_B_W<INTFL_SPEC> {
                IRQ_B_W::new(self, 16)
            }
            #[doc = "Bit 24 - Write Done Flag for Timer B indicating the write is complete from APB to CLK_TMR domain."]
            #[inline(always)]
            #[must_use]
            pub fn wrdone_b(&mut self) -> WRDONE_B_W<INTFL_SPEC> {
                WRDONE_B_W::new(self, 24)
            }
            #[doc = "Bit 25 - Write Disable to CNT/PWM for Timer B in the non-cascaded dual timer configuration."]
            #[inline(always)]
            #[must_use]
            pub fn wr_dis_b(&mut self) -> WR_DIS_B_W<INTFL_SPEC> {
                WR_DIS_B_W::new(self, 25)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Timer Interrupt Status Register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`intfl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`intfl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct INTFL_SPEC;
        impl crate::RegisterSpec for INTFL_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`intfl::R`](R) reader structure"]
        impl crate::Readable for INTFL_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`intfl::W`](W) writer structure"]
        impl crate::Writable for INTFL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets INTFL to value 0"]
        impl crate::Resettable for INTFL_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "CTRL0 (rw) register accessor: Timer Control Register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ctrl0::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl0::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl0`]
module"]
    pub type CTRL0 = crate::Reg<ctrl0::CTRL0_SPEC>;
    #[doc = "Timer Control Register."]
    pub mod ctrl0 {
        #[doc = "Register `CTRL0` reader"]
        pub type R = crate::R<CTRL0_SPEC>;
        #[doc = "Register `CTRL0` writer"]
        pub type W = crate::W<CTRL0_SPEC>;
        #[doc = "Field `MODE_A` reader - Mode Select for Timer A"]
        pub type MODE_A_R = crate::FieldReader<MODE_A_A>;
        #[doc = "Mode Select for Timer A\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum MODE_A_A {
            #[doc = "0: One-Shot Mode"]
            ONE_SHOT = 0,
            #[doc = "1: Continuous Mode"]
            CONTINUOUS = 1,
            #[doc = "2: Counter Mode"]
            COUNTER = 2,
            #[doc = "3: PWM Mode"]
            PWM = 3,
            #[doc = "4: Capture Mode"]
            CAPTURE = 4,
            #[doc = "5: Compare Mode"]
            COMPARE = 5,
            #[doc = "6: Gated Mode"]
            GATED = 6,
            #[doc = "7: Capture/Compare Mode"]
            CAPCOMP = 7,
            #[doc = "8: Dual Edge Capture Mode"]
            DUAL_EDGE = 8,
            #[doc = "14: Inactive Gated Mode"]
            IGATED = 14,
        }
        impl From<MODE_A_A> for u8 {
            #[inline(always)]
            fn from(variant: MODE_A_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for MODE_A_A {
            type Ux = u8;
        }
        impl MODE_A_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<MODE_A_A> {
                match self.bits {
                    0 => Some(MODE_A_A::ONE_SHOT),
                    1 => Some(MODE_A_A::CONTINUOUS),
                    2 => Some(MODE_A_A::COUNTER),
                    3 => Some(MODE_A_A::PWM),
                    4 => Some(MODE_A_A::CAPTURE),
                    5 => Some(MODE_A_A::COMPARE),
                    6 => Some(MODE_A_A::GATED),
                    7 => Some(MODE_A_A::CAPCOMP),
                    8 => Some(MODE_A_A::DUAL_EDGE),
                    14 => Some(MODE_A_A::IGATED),
                    _ => None,
                }
            }
            #[doc = "One-Shot Mode"]
            #[inline(always)]
            pub fn is_one_shot(&self) -> bool {
                *self == MODE_A_A::ONE_SHOT
            }
            #[doc = "Continuous Mode"]
            #[inline(always)]
            pub fn is_continuous(&self) -> bool {
                *self == MODE_A_A::CONTINUOUS
            }
            #[doc = "Counter Mode"]
            #[inline(always)]
            pub fn is_counter(&self) -> bool {
                *self == MODE_A_A::COUNTER
            }
            #[doc = "PWM Mode"]
            #[inline(always)]
            pub fn is_pwm(&self) -> bool {
                *self == MODE_A_A::PWM
            }
            #[doc = "Capture Mode"]
            #[inline(always)]
            pub fn is_capture(&self) -> bool {
                *self == MODE_A_A::CAPTURE
            }
            #[doc = "Compare Mode"]
            #[inline(always)]
            pub fn is_compare(&self) -> bool {
                *self == MODE_A_A::COMPARE
            }
            #[doc = "Gated Mode"]
            #[inline(always)]
            pub fn is_gated(&self) -> bool {
                *self == MODE_A_A::GATED
            }
            #[doc = "Capture/Compare Mode"]
            #[inline(always)]
            pub fn is_capcomp(&self) -> bool {
                *self == MODE_A_A::CAPCOMP
            }
            #[doc = "Dual Edge Capture Mode"]
            #[inline(always)]
            pub fn is_dual_edge(&self) -> bool {
                *self == MODE_A_A::DUAL_EDGE
            }
            #[doc = "Inactive Gated Mode"]
            #[inline(always)]
            pub fn is_igated(&self) -> bool {
                *self == MODE_A_A::IGATED
            }
        }
        #[doc = "Field `MODE_A` writer - Mode Select for Timer A"]
        pub type MODE_A_W<'a, REG> = crate::FieldWriter<'a, REG, 4, MODE_A_A>;
        impl<'a, REG> MODE_A_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "One-Shot Mode"]
            #[inline(always)]
            pub fn one_shot(self) -> &'a mut crate::W<REG> {
                self.variant(MODE_A_A::ONE_SHOT)
            }
            #[doc = "Continuous Mode"]
            #[inline(always)]
            pub fn continuous(self) -> &'a mut crate::W<REG> {
                self.variant(MODE_A_A::CONTINUOUS)
            }
            #[doc = "Counter Mode"]
            #[inline(always)]
            pub fn counter(self) -> &'a mut crate::W<REG> {
                self.variant(MODE_A_A::COUNTER)
            }
            #[doc = "PWM Mode"]
            #[inline(always)]
            pub fn pwm(self) -> &'a mut crate::W<REG> {
                self.variant(MODE_A_A::PWM)
            }
            #[doc = "Capture Mode"]
            #[inline(always)]
            pub fn capture(self) -> &'a mut crate::W<REG> {
                self.variant(MODE_A_A::CAPTURE)
            }
            #[doc = "Compare Mode"]
            #[inline(always)]
            pub fn compare(self) -> &'a mut crate::W<REG> {
                self.variant(MODE_A_A::COMPARE)
            }
            #[doc = "Gated Mode"]
            #[inline(always)]
            pub fn gated(self) -> &'a mut crate::W<REG> {
                self.variant(MODE_A_A::GATED)
            }
            #[doc = "Capture/Compare Mode"]
            #[inline(always)]
            pub fn capcomp(self) -> &'a mut crate::W<REG> {
                self.variant(MODE_A_A::CAPCOMP)
            }
            #[doc = "Dual Edge Capture Mode"]
            #[inline(always)]
            pub fn dual_edge(self) -> &'a mut crate::W<REG> {
                self.variant(MODE_A_A::DUAL_EDGE)
            }
            #[doc = "Inactive Gated Mode"]
            #[inline(always)]
            pub fn igated(self) -> &'a mut crate::W<REG> {
                self.variant(MODE_A_A::IGATED)
            }
        }
        #[doc = "Field `CLKDIV_A` reader - Clock Divider Select for Timer A"]
        pub type CLKDIV_A_R = crate::FieldReader<CLKDIV_A_A>;
        #[doc = "Clock Divider Select for Timer A\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CLKDIV_A_A {
            #[doc = "0: Prescaler Divide-By-1"]
            DIV_BY_1 = 0,
            #[doc = "1: Prescaler Divide-By-2"]
            DIV_BY_2 = 1,
            #[doc = "2: Prescaler Divide-By-4"]
            DIV_BY_4 = 2,
            #[doc = "3: Prescaler Divide-By-8"]
            DIV_BY_8 = 3,
            #[doc = "4: Prescaler Divide-By-16"]
            DIV_BY_16 = 4,
            #[doc = "5: Prescaler Divide-By-32"]
            DIV_BY_32 = 5,
            #[doc = "6: Prescaler Divide-By-64"]
            DIV_BY_64 = 6,
            #[doc = "7: Prescaler Divide-By-128"]
            DIV_BY_128 = 7,
            #[doc = "8: Prescaler Divide-By-256"]
            DIV_BY_256 = 8,
            #[doc = "9: Prescaler Divide-By-512"]
            DIV_BY_512 = 9,
            #[doc = "10: Prescaler Divide-By-1024"]
            DIV_BY_1024 = 10,
            #[doc = "11: Prescaler Divide-By-2048"]
            DIV_BY_2048 = 11,
            #[doc = "12: TBD"]
            DIV_BY_4096 = 12,
        }
        impl From<CLKDIV_A_A> for u8 {
            #[inline(always)]
            fn from(variant: CLKDIV_A_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CLKDIV_A_A {
            type Ux = u8;
        }
        impl CLKDIV_A_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<CLKDIV_A_A> {
                match self.bits {
                    0 => Some(CLKDIV_A_A::DIV_BY_1),
                    1 => Some(CLKDIV_A_A::DIV_BY_2),
                    2 => Some(CLKDIV_A_A::DIV_BY_4),
                    3 => Some(CLKDIV_A_A::DIV_BY_8),
                    4 => Some(CLKDIV_A_A::DIV_BY_16),
                    5 => Some(CLKDIV_A_A::DIV_BY_32),
                    6 => Some(CLKDIV_A_A::DIV_BY_64),
                    7 => Some(CLKDIV_A_A::DIV_BY_128),
                    8 => Some(CLKDIV_A_A::DIV_BY_256),
                    9 => Some(CLKDIV_A_A::DIV_BY_512),
                    10 => Some(CLKDIV_A_A::DIV_BY_1024),
                    11 => Some(CLKDIV_A_A::DIV_BY_2048),
                    12 => Some(CLKDIV_A_A::DIV_BY_4096),
                    _ => None,
                }
            }
            #[doc = "Prescaler Divide-By-1"]
            #[inline(always)]
            pub fn is_div_by_1(&self) -> bool {
                *self == CLKDIV_A_A::DIV_BY_1
            }
            #[doc = "Prescaler Divide-By-2"]
            #[inline(always)]
            pub fn is_div_by_2(&self) -> bool {
                *self == CLKDIV_A_A::DIV_BY_2
            }
            #[doc = "Prescaler Divide-By-4"]
            #[inline(always)]
            pub fn is_div_by_4(&self) -> bool {
                *self == CLKDIV_A_A::DIV_BY_4
            }
            #[doc = "Prescaler Divide-By-8"]
            #[inline(always)]
            pub fn is_div_by_8(&self) -> bool {
                *self == CLKDIV_A_A::DIV_BY_8
            }
            #[doc = "Prescaler Divide-By-16"]
            #[inline(always)]
            pub fn is_div_by_16(&self) -> bool {
                *self == CLKDIV_A_A::DIV_BY_16
            }
            #[doc = "Prescaler Divide-By-32"]
            #[inline(always)]
            pub fn is_div_by_32(&self) -> bool {
                *self == CLKDIV_A_A::DIV_BY_32
            }
            #[doc = "Prescaler Divide-By-64"]
            #[inline(always)]
            pub fn is_div_by_64(&self) -> bool {
                *self == CLKDIV_A_A::DIV_BY_64
            }
            #[doc = "Prescaler Divide-By-128"]
            #[inline(always)]
            pub fn is_div_by_128(&self) -> bool {
                *self == CLKDIV_A_A::DIV_BY_128
            }
            #[doc = "Prescaler Divide-By-256"]
            #[inline(always)]
            pub fn is_div_by_256(&self) -> bool {
                *self == CLKDIV_A_A::DIV_BY_256
            }
            #[doc = "Prescaler Divide-By-512"]
            #[inline(always)]
            pub fn is_div_by_512(&self) -> bool {
                *self == CLKDIV_A_A::DIV_BY_512
            }
            #[doc = "Prescaler Divide-By-1024"]
            #[inline(always)]
            pub fn is_div_by_1024(&self) -> bool {
                *self == CLKDIV_A_A::DIV_BY_1024
            }
            #[doc = "Prescaler Divide-By-2048"]
            #[inline(always)]
            pub fn is_div_by_2048(&self) -> bool {
                *self == CLKDIV_A_A::DIV_BY_2048
            }
            #[doc = "TBD"]
            #[inline(always)]
            pub fn is_div_by_4096(&self) -> bool {
                *self == CLKDIV_A_A::DIV_BY_4096
            }
        }
        #[doc = "Field `CLKDIV_A` writer - Clock Divider Select for Timer A"]
        pub type CLKDIV_A_W<'a, REG> = crate::FieldWriter<'a, REG, 4, CLKDIV_A_A>;
        impl<'a, REG> CLKDIV_A_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Prescaler Divide-By-1"]
            #[inline(always)]
            pub fn div_by_1(self) -> &'a mut crate::W<REG> {
                self.variant(CLKDIV_A_A::DIV_BY_1)
            }
            #[doc = "Prescaler Divide-By-2"]
            #[inline(always)]
            pub fn div_by_2(self) -> &'a mut crate::W<REG> {
                self.variant(CLKDIV_A_A::DIV_BY_2)
            }
            #[doc = "Prescaler Divide-By-4"]
            #[inline(always)]
            pub fn div_by_4(self) -> &'a mut crate::W<REG> {
                self.variant(CLKDIV_A_A::DIV_BY_4)
            }
            #[doc = "Prescaler Divide-By-8"]
            #[inline(always)]
            pub fn div_by_8(self) -> &'a mut crate::W<REG> {
                self.variant(CLKDIV_A_A::DIV_BY_8)
            }
            #[doc = "Prescaler Divide-By-16"]
            #[inline(always)]
            pub fn div_by_16(self) -> &'a mut crate::W<REG> {
                self.variant(CLKDIV_A_A::DIV_BY_16)
            }
            #[doc = "Prescaler Divide-By-32"]
            #[inline(always)]
            pub fn div_by_32(self) -> &'a mut crate::W<REG> {
                self.variant(CLKDIV_A_A::DIV_BY_32)
            }
            #[doc = "Prescaler Divide-By-64"]
            #[inline(always)]
            pub fn div_by_64(self) -> &'a mut crate::W<REG> {
                self.variant(CLKDIV_A_A::DIV_BY_64)
            }
            #[doc = "Prescaler Divide-By-128"]
            #[inline(always)]
            pub fn div_by_128(self) -> &'a mut crate::W<REG> {
                self.variant(CLKDIV_A_A::DIV_BY_128)
            }
            #[doc = "Prescaler Divide-By-256"]
            #[inline(always)]
            pub fn div_by_256(self) -> &'a mut crate::W<REG> {
                self.variant(CLKDIV_A_A::DIV_BY_256)
            }
            #[doc = "Prescaler Divide-By-512"]
            #[inline(always)]
            pub fn div_by_512(self) -> &'a mut crate::W<REG> {
                self.variant(CLKDIV_A_A::DIV_BY_512)
            }
            #[doc = "Prescaler Divide-By-1024"]
            #[inline(always)]
            pub fn div_by_1024(self) -> &'a mut crate::W<REG> {
                self.variant(CLKDIV_A_A::DIV_BY_1024)
            }
            #[doc = "Prescaler Divide-By-2048"]
            #[inline(always)]
            pub fn div_by_2048(self) -> &'a mut crate::W<REG> {
                self.variant(CLKDIV_A_A::DIV_BY_2048)
            }
            #[doc = "TBD"]
            #[inline(always)]
            pub fn div_by_4096(self) -> &'a mut crate::W<REG> {
                self.variant(CLKDIV_A_A::DIV_BY_4096)
            }
        }
        #[doc = "Field `POL_A` reader - Timer Polarity for Timer A"]
        pub type POL_A_R = crate::BitReader;
        #[doc = "Field `POL_A` writer - Timer Polarity for Timer A"]
        pub type POL_A_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWMSYNC_A` reader - PWM Synchronization Mode for Timer A"]
        pub type PWMSYNC_A_R = crate::BitReader;
        #[doc = "Field `PWMSYNC_A` writer - PWM Synchronization Mode for Timer A"]
        pub type PWMSYNC_A_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `NOLHPOL_A` reader - PWM Phase A (Non-Overlapping High) Polarity for Timer A"]
        pub type NOLHPOL_A_R = crate::BitReader;
        #[doc = "Field `NOLHPOL_A` writer - PWM Phase A (Non-Overlapping High) Polarity for Timer A"]
        pub type NOLHPOL_A_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `NOLLPOL_A` reader - PWM Phase A-Prime (Non-Overlapping Low) Polarity for Timer A"]
        pub type NOLLPOL_A_R = crate::BitReader;
        #[doc = "Field `NOLLPOL_A` writer - PWM Phase A-Prime (Non-Overlapping Low) Polarity for Timer A"]
        pub type NOLLPOL_A_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWMCKBD_A` reader - PWM Phase A-Prime Output Disable for Timer A"]
        pub type PWMCKBD_A_R = crate::BitReader;
        #[doc = "Field `PWMCKBD_A` writer - PWM Phase A-Prime Output Disable for Timer A"]
        pub type PWMCKBD_A_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RST_A` reader - Resets all flip flops in the CLK_TMR domain for Timer A. Self-clears."]
        pub type RST_A_R = crate::BitReader;
        #[doc = "Field `RST_A` writer - Resets all flip flops in the CLK_TMR domain for Timer A. Self-clears."]
        pub type RST_A_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CLKEN_A` reader - Write 1 to Enable CLK_TMR for Timer A"]
        pub type CLKEN_A_R = crate::BitReader;
        #[doc = "Field `CLKEN_A` writer - Write 1 to Enable CLK_TMR for Timer A"]
        pub type CLKEN_A_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `EN_A` reader - Enable for Timer A"]
        pub type EN_A_R = crate::BitReader;
        #[doc = "Field `EN_A` writer - Enable for Timer A"]
        pub type EN_A_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MODE_B` reader - Mode Select for Timer B"]
        pub type MODE_B_R = crate::FieldReader<MODE_B_A>;
        #[doc = "Mode Select for Timer B\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum MODE_B_A {
            #[doc = "0: One-Shot Mode"]
            ONE_SHOT = 0,
            #[doc = "1: Continuous Mode"]
            CONTINUOUS = 1,
            #[doc = "2: Counter Mode"]
            COUNTER = 2,
            #[doc = "3: PWM Mode"]
            PWM = 3,
            #[doc = "4: Capture Mode"]
            CAPTURE = 4,
            #[doc = "5: Compare Mode"]
            COMPARE = 5,
            #[doc = "6: Gated Mode"]
            GATED = 6,
            #[doc = "7: Capture/Compare Mode"]
            CAPCOMP = 7,
            #[doc = "8: Dual Edge Capture Mode"]
            DUAL_EDGE = 8,
            #[doc = "14: Inactive Gated Mode"]
            IGATED = 14,
        }
        impl From<MODE_B_A> for u8 {
            #[inline(always)]
            fn from(variant: MODE_B_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for MODE_B_A {
            type Ux = u8;
        }
        impl MODE_B_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<MODE_B_A> {
                match self.bits {
                    0 => Some(MODE_B_A::ONE_SHOT),
                    1 => Some(MODE_B_A::CONTINUOUS),
                    2 => Some(MODE_B_A::COUNTER),
                    3 => Some(MODE_B_A::PWM),
                    4 => Some(MODE_B_A::CAPTURE),
                    5 => Some(MODE_B_A::COMPARE),
                    6 => Some(MODE_B_A::GATED),
                    7 => Some(MODE_B_A::CAPCOMP),
                    8 => Some(MODE_B_A::DUAL_EDGE),
                    14 => Some(MODE_B_A::IGATED),
                    _ => None,
                }
            }
            #[doc = "One-Shot Mode"]
            #[inline(always)]
            pub fn is_one_shot(&self) -> bool {
                *self == MODE_B_A::ONE_SHOT
            }
            #[doc = "Continuous Mode"]
            #[inline(always)]
            pub fn is_continuous(&self) -> bool {
                *self == MODE_B_A::CONTINUOUS
            }
            #[doc = "Counter Mode"]
            #[inline(always)]
            pub fn is_counter(&self) -> bool {
                *self == MODE_B_A::COUNTER
            }
            #[doc = "PWM Mode"]
            #[inline(always)]
            pub fn is_pwm(&self) -> bool {
                *self == MODE_B_A::PWM
            }
            #[doc = "Capture Mode"]
            #[inline(always)]
            pub fn is_capture(&self) -> bool {
                *self == MODE_B_A::CAPTURE
            }
            #[doc = "Compare Mode"]
            #[inline(always)]
            pub fn is_compare(&self) -> bool {
                *self == MODE_B_A::COMPARE
            }
            #[doc = "Gated Mode"]
            #[inline(always)]
            pub fn is_gated(&self) -> bool {
                *self == MODE_B_A::GATED
            }
            #[doc = "Capture/Compare Mode"]
            #[inline(always)]
            pub fn is_capcomp(&self) -> bool {
                *self == MODE_B_A::CAPCOMP
            }
            #[doc = "Dual Edge Capture Mode"]
            #[inline(always)]
            pub fn is_dual_edge(&self) -> bool {
                *self == MODE_B_A::DUAL_EDGE
            }
            #[doc = "Inactive Gated Mode"]
            #[inline(always)]
            pub fn is_igated(&self) -> bool {
                *self == MODE_B_A::IGATED
            }
        }
        #[doc = "Field `MODE_B` writer - Mode Select for Timer B"]
        pub type MODE_B_W<'a, REG> = crate::FieldWriter<'a, REG, 4, MODE_B_A>;
        impl<'a, REG> MODE_B_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "One-Shot Mode"]
            #[inline(always)]
            pub fn one_shot(self) -> &'a mut crate::W<REG> {
                self.variant(MODE_B_A::ONE_SHOT)
            }
            #[doc = "Continuous Mode"]
            #[inline(always)]
            pub fn continuous(self) -> &'a mut crate::W<REG> {
                self.variant(MODE_B_A::CONTINUOUS)
            }
            #[doc = "Counter Mode"]
            #[inline(always)]
            pub fn counter(self) -> &'a mut crate::W<REG> {
                self.variant(MODE_B_A::COUNTER)
            }
            #[doc = "PWM Mode"]
            #[inline(always)]
            pub fn pwm(self) -> &'a mut crate::W<REG> {
                self.variant(MODE_B_A::PWM)
            }
            #[doc = "Capture Mode"]
            #[inline(always)]
            pub fn capture(self) -> &'a mut crate::W<REG> {
                self.variant(MODE_B_A::CAPTURE)
            }
            #[doc = "Compare Mode"]
            #[inline(always)]
            pub fn compare(self) -> &'a mut crate::W<REG> {
                self.variant(MODE_B_A::COMPARE)
            }
            #[doc = "Gated Mode"]
            #[inline(always)]
            pub fn gated(self) -> &'a mut crate::W<REG> {
                self.variant(MODE_B_A::GATED)
            }
            #[doc = "Capture/Compare Mode"]
            #[inline(always)]
            pub fn capcomp(self) -> &'a mut crate::W<REG> {
                self.variant(MODE_B_A::CAPCOMP)
            }
            #[doc = "Dual Edge Capture Mode"]
            #[inline(always)]
            pub fn dual_edge(self) -> &'a mut crate::W<REG> {
                self.variant(MODE_B_A::DUAL_EDGE)
            }
            #[doc = "Inactive Gated Mode"]
            #[inline(always)]
            pub fn igated(self) -> &'a mut crate::W<REG> {
                self.variant(MODE_B_A::IGATED)
            }
        }
        #[doc = "Field `CLKDIV_B` reader - Clock Divider Select for Timer B"]
        pub type CLKDIV_B_R = crate::FieldReader<CLKDIV_B_A>;
        #[doc = "Clock Divider Select for Timer B\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CLKDIV_B_A {
            #[doc = "0: Prescaler Divide-By-1"]
            DIV_BY_1 = 0,
            #[doc = "1: Prescaler Divide-By-2"]
            DIV_BY_2 = 1,
            #[doc = "2: Prescaler Divide-By-4"]
            DIV_BY_4 = 2,
            #[doc = "3: Prescaler Divide-By-8"]
            DIV_BY_8 = 3,
            #[doc = "4: Prescaler Divide-By-16"]
            DIV_BY_16 = 4,
            #[doc = "5: Prescaler Divide-By-32"]
            DIV_BY_32 = 5,
            #[doc = "6: Prescaler Divide-By-64"]
            DIV_BY_64 = 6,
            #[doc = "7: Prescaler Divide-By-128"]
            DIV_BY_128 = 7,
            #[doc = "8: Prescaler Divide-By-256"]
            DIV_BY_256 = 8,
            #[doc = "9: Prescaler Divide-By-512"]
            DIV_BY_512 = 9,
            #[doc = "10: Prescaler Divide-By-1024"]
            DIV_BY_1024 = 10,
            #[doc = "11: Prescaler Divide-By-2048"]
            DIV_BY_2048 = 11,
            #[doc = "12: TBD"]
            DIV_BY_4096 = 12,
        }
        impl From<CLKDIV_B_A> for u8 {
            #[inline(always)]
            fn from(variant: CLKDIV_B_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CLKDIV_B_A {
            type Ux = u8;
        }
        impl CLKDIV_B_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> Option<CLKDIV_B_A> {
                match self.bits {
                    0 => Some(CLKDIV_B_A::DIV_BY_1),
                    1 => Some(CLKDIV_B_A::DIV_BY_2),
                    2 => Some(CLKDIV_B_A::DIV_BY_4),
                    3 => Some(CLKDIV_B_A::DIV_BY_8),
                    4 => Some(CLKDIV_B_A::DIV_BY_16),
                    5 => Some(CLKDIV_B_A::DIV_BY_32),
                    6 => Some(CLKDIV_B_A::DIV_BY_64),
                    7 => Some(CLKDIV_B_A::DIV_BY_128),
                    8 => Some(CLKDIV_B_A::DIV_BY_256),
                    9 => Some(CLKDIV_B_A::DIV_BY_512),
                    10 => Some(CLKDIV_B_A::DIV_BY_1024),
                    11 => Some(CLKDIV_B_A::DIV_BY_2048),
                    12 => Some(CLKDIV_B_A::DIV_BY_4096),
                    _ => None,
                }
            }
            #[doc = "Prescaler Divide-By-1"]
            #[inline(always)]
            pub fn is_div_by_1(&self) -> bool {
                *self == CLKDIV_B_A::DIV_BY_1
            }
            #[doc = "Prescaler Divide-By-2"]
            #[inline(always)]
            pub fn is_div_by_2(&self) -> bool {
                *self == CLKDIV_B_A::DIV_BY_2
            }
            #[doc = "Prescaler Divide-By-4"]
            #[inline(always)]
            pub fn is_div_by_4(&self) -> bool {
                *self == CLKDIV_B_A::DIV_BY_4
            }
            #[doc = "Prescaler Divide-By-8"]
            #[inline(always)]
            pub fn is_div_by_8(&self) -> bool {
                *self == CLKDIV_B_A::DIV_BY_8
            }
            #[doc = "Prescaler Divide-By-16"]
            #[inline(always)]
            pub fn is_div_by_16(&self) -> bool {
                *self == CLKDIV_B_A::DIV_BY_16
            }
            #[doc = "Prescaler Divide-By-32"]
            #[inline(always)]
            pub fn is_div_by_32(&self) -> bool {
                *self == CLKDIV_B_A::DIV_BY_32
            }
            #[doc = "Prescaler Divide-By-64"]
            #[inline(always)]
            pub fn is_div_by_64(&self) -> bool {
                *self == CLKDIV_B_A::DIV_BY_64
            }
            #[doc = "Prescaler Divide-By-128"]
            #[inline(always)]
            pub fn is_div_by_128(&self) -> bool {
                *self == CLKDIV_B_A::DIV_BY_128
            }
            #[doc = "Prescaler Divide-By-256"]
            #[inline(always)]
            pub fn is_div_by_256(&self) -> bool {
                *self == CLKDIV_B_A::DIV_BY_256
            }
            #[doc = "Prescaler Divide-By-512"]
            #[inline(always)]
            pub fn is_div_by_512(&self) -> bool {
                *self == CLKDIV_B_A::DIV_BY_512
            }
            #[doc = "Prescaler Divide-By-1024"]
            #[inline(always)]
            pub fn is_div_by_1024(&self) -> bool {
                *self == CLKDIV_B_A::DIV_BY_1024
            }
            #[doc = "Prescaler Divide-By-2048"]
            #[inline(always)]
            pub fn is_div_by_2048(&self) -> bool {
                *self == CLKDIV_B_A::DIV_BY_2048
            }
            #[doc = "TBD"]
            #[inline(always)]
            pub fn is_div_by_4096(&self) -> bool {
                *self == CLKDIV_B_A::DIV_BY_4096
            }
        }
        #[doc = "Field `CLKDIV_B` writer - Clock Divider Select for Timer B"]
        pub type CLKDIV_B_W<'a, REG> = crate::FieldWriter<'a, REG, 4, CLKDIV_B_A>;
        impl<'a, REG> CLKDIV_B_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "Prescaler Divide-By-1"]
            #[inline(always)]
            pub fn div_by_1(self) -> &'a mut crate::W<REG> {
                self.variant(CLKDIV_B_A::DIV_BY_1)
            }
            #[doc = "Prescaler Divide-By-2"]
            #[inline(always)]
            pub fn div_by_2(self) -> &'a mut crate::W<REG> {
                self.variant(CLKDIV_B_A::DIV_BY_2)
            }
            #[doc = "Prescaler Divide-By-4"]
            #[inline(always)]
            pub fn div_by_4(self) -> &'a mut crate::W<REG> {
                self.variant(CLKDIV_B_A::DIV_BY_4)
            }
            #[doc = "Prescaler Divide-By-8"]
            #[inline(always)]
            pub fn div_by_8(self) -> &'a mut crate::W<REG> {
                self.variant(CLKDIV_B_A::DIV_BY_8)
            }
            #[doc = "Prescaler Divide-By-16"]
            #[inline(always)]
            pub fn div_by_16(self) -> &'a mut crate::W<REG> {
                self.variant(CLKDIV_B_A::DIV_BY_16)
            }
            #[doc = "Prescaler Divide-By-32"]
            #[inline(always)]
            pub fn div_by_32(self) -> &'a mut crate::W<REG> {
                self.variant(CLKDIV_B_A::DIV_BY_32)
            }
            #[doc = "Prescaler Divide-By-64"]
            #[inline(always)]
            pub fn div_by_64(self) -> &'a mut crate::W<REG> {
                self.variant(CLKDIV_B_A::DIV_BY_64)
            }
            #[doc = "Prescaler Divide-By-128"]
            #[inline(always)]
            pub fn div_by_128(self) -> &'a mut crate::W<REG> {
                self.variant(CLKDIV_B_A::DIV_BY_128)
            }
            #[doc = "Prescaler Divide-By-256"]
            #[inline(always)]
            pub fn div_by_256(self) -> &'a mut crate::W<REG> {
                self.variant(CLKDIV_B_A::DIV_BY_256)
            }
            #[doc = "Prescaler Divide-By-512"]
            #[inline(always)]
            pub fn div_by_512(self) -> &'a mut crate::W<REG> {
                self.variant(CLKDIV_B_A::DIV_BY_512)
            }
            #[doc = "Prescaler Divide-By-1024"]
            #[inline(always)]
            pub fn div_by_1024(self) -> &'a mut crate::W<REG> {
                self.variant(CLKDIV_B_A::DIV_BY_1024)
            }
            #[doc = "Prescaler Divide-By-2048"]
            #[inline(always)]
            pub fn div_by_2048(self) -> &'a mut crate::W<REG> {
                self.variant(CLKDIV_B_A::DIV_BY_2048)
            }
            #[doc = "TBD"]
            #[inline(always)]
            pub fn div_by_4096(self) -> &'a mut crate::W<REG> {
                self.variant(CLKDIV_B_A::DIV_BY_4096)
            }
        }
        #[doc = "Field `POL_B` reader - Timer Polarity for Timer B"]
        pub type POL_B_R = crate::BitReader;
        #[doc = "Field `POL_B` writer - Timer Polarity for Timer B"]
        pub type POL_B_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWMSYNC_B` reader - PWM Synchronization Mode for Timer B"]
        pub type PWMSYNC_B_R = crate::BitReader;
        #[doc = "Field `PWMSYNC_B` writer - PWM Synchronization Mode for Timer B"]
        pub type PWMSYNC_B_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `NOLHPOL_B` reader - PWM Phase A (Non-Overlapping High) Polarity for Timer B"]
        pub type NOLHPOL_B_R = crate::BitReader;
        #[doc = "Field `NOLHPOL_B` writer - PWM Phase A (Non-Overlapping High) Polarity for Timer B"]
        pub type NOLHPOL_B_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `NOLLPOL_B` reader - PWM Phase A-Prime (Non-Overlapping Low) Polarity for Timer B"]
        pub type NOLLPOL_B_R = crate::BitReader;
        #[doc = "Field `NOLLPOL_B` writer - PWM Phase A-Prime (Non-Overlapping Low) Polarity for Timer B"]
        pub type NOLLPOL_B_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWMCKBD_B` reader - PWM Phase A-Prime Output Disable for Timer B"]
        pub type PWMCKBD_B_R = crate::BitReader;
        #[doc = "Field `PWMCKBD_B` writer - PWM Phase A-Prime Output Disable for Timer B"]
        pub type PWMCKBD_B_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RST_B` reader - Resets all flip flops in the CLK_TMR domain for Timer B. Self-clears."]
        pub type RST_B_R = crate::BitReader;
        #[doc = "Field `RST_B` writer - Resets all flip flops in the CLK_TMR domain for Timer B. Self-clears."]
        pub type RST_B_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CLKEN_B` reader - Write 1 to Enable CLK_TMR for Timer B"]
        pub type CLKEN_B_R = crate::BitReader;
        #[doc = "Field `CLKEN_B` writer - Write 1 to Enable CLK_TMR for Timer B"]
        pub type CLKEN_B_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `EN_B` reader - Enable for Timer B"]
        pub type EN_B_R = crate::BitReader;
        #[doc = "Field `EN_B` writer - Enable for Timer B"]
        pub type EN_B_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:3 - Mode Select for Timer A"]
            #[inline(always)]
            pub fn mode_a(&self) -> MODE_A_R {
                MODE_A_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bits 4:7 - Clock Divider Select for Timer A"]
            #[inline(always)]
            pub fn clkdiv_a(&self) -> CLKDIV_A_R {
                CLKDIV_A_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            #[doc = "Bit 8 - Timer Polarity for Timer A"]
            #[inline(always)]
            pub fn pol_a(&self) -> POL_A_R {
                POL_A_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - PWM Synchronization Mode for Timer A"]
            #[inline(always)]
            pub fn pwmsync_a(&self) -> PWMSYNC_A_R {
                PWMSYNC_A_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - PWM Phase A (Non-Overlapping High) Polarity for Timer A"]
            #[inline(always)]
            pub fn nolhpol_a(&self) -> NOLHPOL_A_R {
                NOLHPOL_A_R::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - PWM Phase A-Prime (Non-Overlapping Low) Polarity for Timer A"]
            #[inline(always)]
            pub fn nollpol_a(&self) -> NOLLPOL_A_R {
                NOLLPOL_A_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - PWM Phase A-Prime Output Disable for Timer A"]
            #[inline(always)]
            pub fn pwmckbd_a(&self) -> PWMCKBD_A_R {
                PWMCKBD_A_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Resets all flip flops in the CLK_TMR domain for Timer A. Self-clears."]
            #[inline(always)]
            pub fn rst_a(&self) -> RST_A_R {
                RST_A_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Write 1 to Enable CLK_TMR for Timer A"]
            #[inline(always)]
            pub fn clken_a(&self) -> CLKEN_A_R {
                CLKEN_A_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Enable for Timer A"]
            #[inline(always)]
            pub fn en_a(&self) -> EN_A_R {
                EN_A_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bits 16:19 - Mode Select for Timer B"]
            #[inline(always)]
            pub fn mode_b(&self) -> MODE_B_R {
                MODE_B_R::new(((self.bits >> 16) & 0x0f) as u8)
            }
            #[doc = "Bits 20:23 - Clock Divider Select for Timer B"]
            #[inline(always)]
            pub fn clkdiv_b(&self) -> CLKDIV_B_R {
                CLKDIV_B_R::new(((self.bits >> 20) & 0x0f) as u8)
            }
            #[doc = "Bit 24 - Timer Polarity for Timer B"]
            #[inline(always)]
            pub fn pol_b(&self) -> POL_B_R {
                POL_B_R::new(((self.bits >> 24) & 1) != 0)
            }
            #[doc = "Bit 25 - PWM Synchronization Mode for Timer B"]
            #[inline(always)]
            pub fn pwmsync_b(&self) -> PWMSYNC_B_R {
                PWMSYNC_B_R::new(((self.bits >> 25) & 1) != 0)
            }
            #[doc = "Bit 26 - PWM Phase A (Non-Overlapping High) Polarity for Timer B"]
            #[inline(always)]
            pub fn nolhpol_b(&self) -> NOLHPOL_B_R {
                NOLHPOL_B_R::new(((self.bits >> 26) & 1) != 0)
            }
            #[doc = "Bit 27 - PWM Phase A-Prime (Non-Overlapping Low) Polarity for Timer B"]
            #[inline(always)]
            pub fn nollpol_b(&self) -> NOLLPOL_B_R {
                NOLLPOL_B_R::new(((self.bits >> 27) & 1) != 0)
            }
            #[doc = "Bit 28 - PWM Phase A-Prime Output Disable for Timer B"]
            #[inline(always)]
            pub fn pwmckbd_b(&self) -> PWMCKBD_B_R {
                PWMCKBD_B_R::new(((self.bits >> 28) & 1) != 0)
            }
            #[doc = "Bit 29 - Resets all flip flops in the CLK_TMR domain for Timer B. Self-clears."]
            #[inline(always)]
            pub fn rst_b(&self) -> RST_B_R {
                RST_B_R::new(((self.bits >> 29) & 1) != 0)
            }
            #[doc = "Bit 30 - Write 1 to Enable CLK_TMR for Timer B"]
            #[inline(always)]
            pub fn clken_b(&self) -> CLKEN_B_R {
                CLKEN_B_R::new(((self.bits >> 30) & 1) != 0)
            }
            #[doc = "Bit 31 - Enable for Timer B"]
            #[inline(always)]
            pub fn en_b(&self) -> EN_B_R {
                EN_B_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - Mode Select for Timer A"]
            #[inline(always)]
            #[must_use]
            pub fn mode_a(&mut self) -> MODE_A_W<CTRL0_SPEC> {
                MODE_A_W::new(self, 0)
            }
            #[doc = "Bits 4:7 - Clock Divider Select for Timer A"]
            #[inline(always)]
            #[must_use]
            pub fn clkdiv_a(&mut self) -> CLKDIV_A_W<CTRL0_SPEC> {
                CLKDIV_A_W::new(self, 4)
            }
            #[doc = "Bit 8 - Timer Polarity for Timer A"]
            #[inline(always)]
            #[must_use]
            pub fn pol_a(&mut self) -> POL_A_W<CTRL0_SPEC> {
                POL_A_W::new(self, 8)
            }
            #[doc = "Bit 9 - PWM Synchronization Mode for Timer A"]
            #[inline(always)]
            #[must_use]
            pub fn pwmsync_a(&mut self) -> PWMSYNC_A_W<CTRL0_SPEC> {
                PWMSYNC_A_W::new(self, 9)
            }
            #[doc = "Bit 10 - PWM Phase A (Non-Overlapping High) Polarity for Timer A"]
            #[inline(always)]
            #[must_use]
            pub fn nolhpol_a(&mut self) -> NOLHPOL_A_W<CTRL0_SPEC> {
                NOLHPOL_A_W::new(self, 10)
            }
            #[doc = "Bit 11 - PWM Phase A-Prime (Non-Overlapping Low) Polarity for Timer A"]
            #[inline(always)]
            #[must_use]
            pub fn nollpol_a(&mut self) -> NOLLPOL_A_W<CTRL0_SPEC> {
                NOLLPOL_A_W::new(self, 11)
            }
            #[doc = "Bit 12 - PWM Phase A-Prime Output Disable for Timer A"]
            #[inline(always)]
            #[must_use]
            pub fn pwmckbd_a(&mut self) -> PWMCKBD_A_W<CTRL0_SPEC> {
                PWMCKBD_A_W::new(self, 12)
            }
            #[doc = "Bit 13 - Resets all flip flops in the CLK_TMR domain for Timer A. Self-clears."]
            #[inline(always)]
            #[must_use]
            pub fn rst_a(&mut self) -> RST_A_W<CTRL0_SPEC> {
                RST_A_W::new(self, 13)
            }
            #[doc = "Bit 14 - Write 1 to Enable CLK_TMR for Timer A"]
            #[inline(always)]
            #[must_use]
            pub fn clken_a(&mut self) -> CLKEN_A_W<CTRL0_SPEC> {
                CLKEN_A_W::new(self, 14)
            }
            #[doc = "Bit 15 - Enable for Timer A"]
            #[inline(always)]
            #[must_use]
            pub fn en_a(&mut self) -> EN_A_W<CTRL0_SPEC> {
                EN_A_W::new(self, 15)
            }
            #[doc = "Bits 16:19 - Mode Select for Timer B"]
            #[inline(always)]
            #[must_use]
            pub fn mode_b(&mut self) -> MODE_B_W<CTRL0_SPEC> {
                MODE_B_W::new(self, 16)
            }
            #[doc = "Bits 20:23 - Clock Divider Select for Timer B"]
            #[inline(always)]
            #[must_use]
            pub fn clkdiv_b(&mut self) -> CLKDIV_B_W<CTRL0_SPEC> {
                CLKDIV_B_W::new(self, 20)
            }
            #[doc = "Bit 24 - Timer Polarity for Timer B"]
            #[inline(always)]
            #[must_use]
            pub fn pol_b(&mut self) -> POL_B_W<CTRL0_SPEC> {
                POL_B_W::new(self, 24)
            }
            #[doc = "Bit 25 - PWM Synchronization Mode for Timer B"]
            #[inline(always)]
            #[must_use]
            pub fn pwmsync_b(&mut self) -> PWMSYNC_B_W<CTRL0_SPEC> {
                PWMSYNC_B_W::new(self, 25)
            }
            #[doc = "Bit 26 - PWM Phase A (Non-Overlapping High) Polarity for Timer B"]
            #[inline(always)]
            #[must_use]
            pub fn nolhpol_b(&mut self) -> NOLHPOL_B_W<CTRL0_SPEC> {
                NOLHPOL_B_W::new(self, 26)
            }
            #[doc = "Bit 27 - PWM Phase A-Prime (Non-Overlapping Low) Polarity for Timer B"]
            #[inline(always)]
            #[must_use]
            pub fn nollpol_b(&mut self) -> NOLLPOL_B_W<CTRL0_SPEC> {
                NOLLPOL_B_W::new(self, 27)
            }
            #[doc = "Bit 28 - PWM Phase A-Prime Output Disable for Timer B"]
            #[inline(always)]
            #[must_use]
            pub fn pwmckbd_b(&mut self) -> PWMCKBD_B_W<CTRL0_SPEC> {
                PWMCKBD_B_W::new(self, 28)
            }
            #[doc = "Bit 29 - Resets all flip flops in the CLK_TMR domain for Timer B. Self-clears."]
            #[inline(always)]
            #[must_use]
            pub fn rst_b(&mut self) -> RST_B_W<CTRL0_SPEC> {
                RST_B_W::new(self, 29)
            }
            #[doc = "Bit 30 - Write 1 to Enable CLK_TMR for Timer B"]
            #[inline(always)]
            #[must_use]
            pub fn clken_b(&mut self) -> CLKEN_B_W<CTRL0_SPEC> {
                CLKEN_B_W::new(self, 30)
            }
            #[doc = "Bit 31 - Enable for Timer B"]
            #[inline(always)]
            #[must_use]
            pub fn en_b(&mut self) -> EN_B_W<CTRL0_SPEC> {
                EN_B_W::new(self, 31)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Timer Control Register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ctrl0::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl0::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CTRL0_SPEC;
        impl crate::RegisterSpec for CTRL0_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ctrl0::R`](R) reader structure"]
        impl crate::Readable for CTRL0_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`ctrl0::W`](W) writer structure"]
        impl crate::Writable for CTRL0_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets CTRL0 to value 0"]
        impl crate::Resettable for CTRL0_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "NOLCMP (rw) register accessor: Timer Non-Overlapping Compare Register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`nolcmp::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`nolcmp::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@nolcmp`]
module"]
    pub type NOLCMP = crate::Reg<nolcmp::NOLCMP_SPEC>;
    #[doc = "Timer Non-Overlapping Compare Register."]
    pub mod nolcmp {
        #[doc = "Register `NOLCMP` reader"]
        pub type R = crate::R<NOLCMP_SPEC>;
        #[doc = "Register `NOLCMP` writer"]
        pub type W = crate::W<NOLCMP_SPEC>;
        #[doc = "Field `LO_A` reader - Non-Overlapping Low Compare value for Timer A controls the time between the falling edge of PWM Phase A and the next rising edge of PWM Phase A-Prime."]
        pub type LO_A_R = crate::FieldReader;
        #[doc = "Field `LO_A` writer - Non-Overlapping Low Compare value for Timer A controls the time between the falling edge of PWM Phase A and the next rising edge of PWM Phase A-Prime."]
        pub type LO_A_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        #[doc = "Field `HI_A` reader - Non-Overlapping High Compare value for Timer A controls the time between the falling edge of PWM Phase A-Prime and the next rising edge of PWM Phase A."]
        pub type HI_A_R = crate::FieldReader;
        #[doc = "Field `HI_A` writer - Non-Overlapping High Compare value for Timer A controls the time between the falling edge of PWM Phase A-Prime and the next rising edge of PWM Phase A."]
        pub type HI_A_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        #[doc = "Field `LO_B` reader - Non-Overlapping Low Compare value for Timer B controls the time between the falling edge of PWM Phase A and the next rising edge of PWM Phase A-Prime."]
        pub type LO_B_R = crate::FieldReader;
        #[doc = "Field `LO_B` writer - Non-Overlapping Low Compare value for Timer B controls the time between the falling edge of PWM Phase A and the next rising edge of PWM Phase A-Prime."]
        pub type LO_B_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        #[doc = "Field `HI_B` reader - Non-Overlapping High Compare value for Timer B controls the time between the falling edge of PWM Phase A-Prime and the next rising edge of PWM Phase A."]
        pub type HI_B_R = crate::FieldReader;
        #[doc = "Field `HI_B` writer - Non-Overlapping High Compare value for Timer B controls the time between the falling edge of PWM Phase A-Prime and the next rising edge of PWM Phase A."]
        pub type HI_B_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - Non-Overlapping Low Compare value for Timer A controls the time between the falling edge of PWM Phase A and the next rising edge of PWM Phase A-Prime."]
            #[inline(always)]
            pub fn lo_a(&self) -> LO_A_R {
                LO_A_R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:15 - Non-Overlapping High Compare value for Timer A controls the time between the falling edge of PWM Phase A-Prime and the next rising edge of PWM Phase A."]
            #[inline(always)]
            pub fn hi_a(&self) -> HI_A_R {
                HI_A_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            #[doc = "Bits 16:23 - Non-Overlapping Low Compare value for Timer B controls the time between the falling edge of PWM Phase A and the next rising edge of PWM Phase A-Prime."]
            #[inline(always)]
            pub fn lo_b(&self) -> LO_B_R {
                LO_B_R::new(((self.bits >> 16) & 0xff) as u8)
            }
            #[doc = "Bits 24:31 - Non-Overlapping High Compare value for Timer B controls the time between the falling edge of PWM Phase A-Prime and the next rising edge of PWM Phase A."]
            #[inline(always)]
            pub fn hi_b(&self) -> HI_B_R {
                HI_B_R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Non-Overlapping Low Compare value for Timer A controls the time between the falling edge of PWM Phase A and the next rising edge of PWM Phase A-Prime."]
            #[inline(always)]
            #[must_use]
            pub fn lo_a(&mut self) -> LO_A_W<NOLCMP_SPEC> {
                LO_A_W::new(self, 0)
            }
            #[doc = "Bits 8:15 - Non-Overlapping High Compare value for Timer A controls the time between the falling edge of PWM Phase A-Prime and the next rising edge of PWM Phase A."]
            #[inline(always)]
            #[must_use]
            pub fn hi_a(&mut self) -> HI_A_W<NOLCMP_SPEC> {
                HI_A_W::new(self, 8)
            }
            #[doc = "Bits 16:23 - Non-Overlapping Low Compare value for Timer B controls the time between the falling edge of PWM Phase A and the next rising edge of PWM Phase A-Prime."]
            #[inline(always)]
            #[must_use]
            pub fn lo_b(&mut self) -> LO_B_W<NOLCMP_SPEC> {
                LO_B_W::new(self, 16)
            }
            #[doc = "Bits 24:31 - Non-Overlapping High Compare value for Timer B controls the time between the falling edge of PWM Phase A-Prime and the next rising edge of PWM Phase A."]
            #[inline(always)]
            #[must_use]
            pub fn hi_b(&mut self) -> HI_B_W<NOLCMP_SPEC> {
                HI_B_W::new(self, 24)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Timer Non-Overlapping Compare Register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`nolcmp::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`nolcmp::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct NOLCMP_SPEC;
        impl crate::RegisterSpec for NOLCMP_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`nolcmp::R`](R) reader structure"]
        impl crate::Readable for NOLCMP_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`nolcmp::W`](W) writer structure"]
        impl crate::Writable for NOLCMP_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets NOLCMP to value 0"]
        impl crate::Resettable for NOLCMP_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "CTRL1 (rw) register accessor: Timer Configuration Register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ctrl1::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl1::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl1`]
module"]
    pub type CTRL1 = crate::Reg<ctrl1::CTRL1_SPEC>;
    #[doc = "Timer Configuration Register."]
    pub mod ctrl1 {
        #[doc = "Register `CTRL1` reader"]
        pub type R = crate::R<CTRL1_SPEC>;
        #[doc = "Register `CTRL1` writer"]
        pub type W = crate::W<CTRL1_SPEC>;
        #[doc = "Field `CLKSEL_A` reader - Timer Clock Select for Timer A"]
        pub type CLKSEL_A_R = crate::FieldReader;
        #[doc = "Field `CLKSEL_A` writer - Timer Clock Select for Timer A"]
        pub type CLKSEL_A_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `CLKEN_A` reader - Timer A Enable Status"]
        pub type CLKEN_A_R = crate::BitReader;
        #[doc = "Field `CLKEN_A` writer - Timer A Enable Status"]
        pub type CLKEN_A_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CLKRDY_A` reader - CLK_TMR Ready Flag for Timer A"]
        pub type CLKRDY_A_R = crate::BitReader;
        #[doc = "Field `CLKRDY_A` writer - CLK_TMR Ready Flag for Timer A"]
        pub type CLKRDY_A_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `EVENT_SEL_A` reader - Event Select for Timer A"]
        pub type EVENT_SEL_A_R = crate::FieldReader;
        #[doc = "Field `EVENT_SEL_A` writer - Event Select for Timer A"]
        pub type EVENT_SEL_A_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        #[doc = "Field `NEGTRIG_A` reader - Negative Edge Trigger for Event for Timer A"]
        pub type NEGTRIG_A_R = crate::BitReader;
        #[doc = "Field `NEGTRIG_A` writer - Negative Edge Trigger for Event for Timer A"]
        pub type NEGTRIG_A_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IE_A` reader - Interrupt Enable for Timer A"]
        pub type IE_A_R = crate::BitReader;
        #[doc = "Field `IE_A` writer - Interrupt Enable for Timer A"]
        pub type IE_A_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CAPEVENT_SEL_A` reader - Capture Event Select for Timer A"]
        pub type CAPEVENT_SEL_A_R = crate::FieldReader;
        #[doc = "Field `CAPEVENT_SEL_A` writer - Capture Event Select for Timer A"]
        pub type CAPEVENT_SEL_A_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `SW_CAPEVENT_A` reader - Software Capture Event for Timer A"]
        pub type SW_CAPEVENT_A_R = crate::BitReader;
        #[doc = "Field `SW_CAPEVENT_A` writer - Software Capture Event for Timer A"]
        pub type SW_CAPEVENT_A_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WE_A` reader - Wake-Up Enable for Timer A"]
        pub type WE_A_R = crate::BitReader;
        #[doc = "Field `WE_A` writer - Wake-Up Enable for Timer A"]
        pub type WE_A_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `OUTEN_A` reader - OUT_OE_O Enable for Modes 0, 1,and 5 for Timer A"]
        pub type OUTEN_A_R = crate::BitReader;
        #[doc = "Field `OUTEN_A` writer - OUT_OE_O Enable for Modes 0, 1,and 5 for Timer A"]
        pub type OUTEN_A_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `OUTBEN_A` reader - PWM_CKB_EN_O Enable for Modes other than Mode 3 for Timer A"]
        pub type OUTBEN_A_R = crate::BitReader;
        #[doc = "Field `OUTBEN_A` writer - PWM_CKB_EN_O Enable for Modes other than Mode 3 for Timer A"]
        pub type OUTBEN_A_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CLKSEL_B` reader - Timer Clock Select for Timer B"]
        pub type CLKSEL_B_R = crate::FieldReader;
        #[doc = "Field `CLKSEL_B` writer - Timer Clock Select for Timer B"]
        pub type CLKSEL_B_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `CLKEN_B` reader - Timer B Enable Status"]
        pub type CLKEN_B_R = crate::BitReader;
        #[doc = "Field `CLKEN_B` writer - Timer B Enable Status"]
        pub type CLKEN_B_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CLKRDY_B` reader - CLK_TMR Ready Flag for Timer B"]
        pub type CLKRDY_B_R = crate::BitReader;
        #[doc = "Field `CLKRDY_B` writer - CLK_TMR Ready Flag for Timer B"]
        pub type CLKRDY_B_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `EVENT_SEL_B` reader - Event Select for Timer B"]
        pub type EVENT_SEL_B_R = crate::FieldReader;
        #[doc = "Field `EVENT_SEL_B` writer - Event Select for Timer B"]
        pub type EVENT_SEL_B_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        #[doc = "Field `NEGTRIG_B` reader - Negative Edge Trigger for Event for Timer B"]
        pub type NEGTRIG_B_R = crate::BitReader;
        #[doc = "Field `NEGTRIG_B` writer - Negative Edge Trigger for Event for Timer B"]
        pub type NEGTRIG_B_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IE_B` reader - Interrupt Enable for Timer B"]
        pub type IE_B_R = crate::BitReader;
        #[doc = "Field `IE_B` writer - Interrupt Enable for Timer B"]
        pub type IE_B_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CAPEVENT_SEL_B` reader - Capture Event Select for Timer B"]
        pub type CAPEVENT_SEL_B_R = crate::FieldReader;
        #[doc = "Field `CAPEVENT_SEL_B` writer - Capture Event Select for Timer B"]
        pub type CAPEVENT_SEL_B_W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `SW_CAPEVENT_B` reader - Software Capture Event for Timer B"]
        pub type SW_CAPEVENT_B_R = crate::BitReader;
        #[doc = "Field `SW_CAPEVENT_B` writer - Software Capture Event for Timer B"]
        pub type SW_CAPEVENT_B_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WE_B` reader - Wake-Up Enable for Timer B"]
        pub type WE_B_R = crate::BitReader;
        #[doc = "Field `WE_B` writer - Wake-Up Enable for Timer B"]
        pub type WE_B_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CASCADE` reader - Cascade two 16-bit timers into one 32-bit timer. Only available when C_TMR16=0 adn C_DUALTMR16=1."]
        pub type CASCADE_R = crate::BitReader;
        #[doc = "Field `CASCADE` writer - Cascade two 16-bit timers into one 32-bit timer. Only available when C_TMR16=0 adn C_DUALTMR16=1."]
        pub type CASCADE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:1 - Timer Clock Select for Timer A"]
            #[inline(always)]
            pub fn clksel_a(&self) -> CLKSEL_A_R {
                CLKSEL_A_R::new((self.bits & 3) as u8)
            }
            #[doc = "Bit 2 - Timer A Enable Status"]
            #[inline(always)]
            pub fn clken_a(&self) -> CLKEN_A_R {
                CLKEN_A_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - CLK_TMR Ready Flag for Timer A"]
            #[inline(always)]
            pub fn clkrdy_a(&self) -> CLKRDY_A_R {
                CLKRDY_A_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bits 4:6 - Event Select for Timer A"]
            #[inline(always)]
            pub fn event_sel_a(&self) -> EVENT_SEL_A_R {
                EVENT_SEL_A_R::new(((self.bits >> 4) & 7) as u8)
            }
            #[doc = "Bit 7 - Negative Edge Trigger for Event for Timer A"]
            #[inline(always)]
            pub fn negtrig_a(&self) -> NEGTRIG_A_R {
                NEGTRIG_A_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Interrupt Enable for Timer A"]
            #[inline(always)]
            pub fn ie_a(&self) -> IE_A_R {
                IE_A_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bits 9:10 - Capture Event Select for Timer A"]
            #[inline(always)]
            pub fn capevent_sel_a(&self) -> CAPEVENT_SEL_A_R {
                CAPEVENT_SEL_A_R::new(((self.bits >> 9) & 3) as u8)
            }
            #[doc = "Bit 11 - Software Capture Event for Timer A"]
            #[inline(always)]
            pub fn sw_capevent_a(&self) -> SW_CAPEVENT_A_R {
                SW_CAPEVENT_A_R::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - Wake-Up Enable for Timer A"]
            #[inline(always)]
            pub fn we_a(&self) -> WE_A_R {
                WE_A_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - OUT_OE_O Enable for Modes 0, 1,and 5 for Timer A"]
            #[inline(always)]
            pub fn outen_a(&self) -> OUTEN_A_R {
                OUTEN_A_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - PWM_CKB_EN_O Enable for Modes other than Mode 3 for Timer A"]
            #[inline(always)]
            pub fn outben_a(&self) -> OUTBEN_A_R {
                OUTBEN_A_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bits 16:17 - Timer Clock Select for Timer B"]
            #[inline(always)]
            pub fn clksel_b(&self) -> CLKSEL_B_R {
                CLKSEL_B_R::new(((self.bits >> 16) & 3) as u8)
            }
            #[doc = "Bit 18 - Timer B Enable Status"]
            #[inline(always)]
            pub fn clken_b(&self) -> CLKEN_B_R {
                CLKEN_B_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - CLK_TMR Ready Flag for Timer B"]
            #[inline(always)]
            pub fn clkrdy_b(&self) -> CLKRDY_B_R {
                CLKRDY_B_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bits 20:22 - Event Select for Timer B"]
            #[inline(always)]
            pub fn event_sel_b(&self) -> EVENT_SEL_B_R {
                EVENT_SEL_B_R::new(((self.bits >> 20) & 7) as u8)
            }
            #[doc = "Bit 23 - Negative Edge Trigger for Event for Timer B"]
            #[inline(always)]
            pub fn negtrig_b(&self) -> NEGTRIG_B_R {
                NEGTRIG_B_R::new(((self.bits >> 23) & 1) != 0)
            }
            #[doc = "Bit 24 - Interrupt Enable for Timer B"]
            #[inline(always)]
            pub fn ie_b(&self) -> IE_B_R {
                IE_B_R::new(((self.bits >> 24) & 1) != 0)
            }
            #[doc = "Bits 25:26 - Capture Event Select for Timer B"]
            #[inline(always)]
            pub fn capevent_sel_b(&self) -> CAPEVENT_SEL_B_R {
                CAPEVENT_SEL_B_R::new(((self.bits >> 25) & 3) as u8)
            }
            #[doc = "Bit 27 - Software Capture Event for Timer B"]
            #[inline(always)]
            pub fn sw_capevent_b(&self) -> SW_CAPEVENT_B_R {
                SW_CAPEVENT_B_R::new(((self.bits >> 27) & 1) != 0)
            }
            #[doc = "Bit 28 - Wake-Up Enable for Timer B"]
            #[inline(always)]
            pub fn we_b(&self) -> WE_B_R {
                WE_B_R::new(((self.bits >> 28) & 1) != 0)
            }
            #[doc = "Bit 31 - Cascade two 16-bit timers into one 32-bit timer. Only available when C_TMR16=0 adn C_DUALTMR16=1."]
            #[inline(always)]
            pub fn cascade(&self) -> CASCADE_R {
                CASCADE_R::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - Timer Clock Select for Timer A"]
            #[inline(always)]
            #[must_use]
            pub fn clksel_a(&mut self) -> CLKSEL_A_W<CTRL1_SPEC> {
                CLKSEL_A_W::new(self, 0)
            }
            #[doc = "Bit 2 - Timer A Enable Status"]
            #[inline(always)]
            #[must_use]
            pub fn clken_a(&mut self) -> CLKEN_A_W<CTRL1_SPEC> {
                CLKEN_A_W::new(self, 2)
            }
            #[doc = "Bit 3 - CLK_TMR Ready Flag for Timer A"]
            #[inline(always)]
            #[must_use]
            pub fn clkrdy_a(&mut self) -> CLKRDY_A_W<CTRL1_SPEC> {
                CLKRDY_A_W::new(self, 3)
            }
            #[doc = "Bits 4:6 - Event Select for Timer A"]
            #[inline(always)]
            #[must_use]
            pub fn event_sel_a(&mut self) -> EVENT_SEL_A_W<CTRL1_SPEC> {
                EVENT_SEL_A_W::new(self, 4)
            }
            #[doc = "Bit 7 - Negative Edge Trigger for Event for Timer A"]
            #[inline(always)]
            #[must_use]
            pub fn negtrig_a(&mut self) -> NEGTRIG_A_W<CTRL1_SPEC> {
                NEGTRIG_A_W::new(self, 7)
            }
            #[doc = "Bit 8 - Interrupt Enable for Timer A"]
            #[inline(always)]
            #[must_use]
            pub fn ie_a(&mut self) -> IE_A_W<CTRL1_SPEC> {
                IE_A_W::new(self, 8)
            }
            #[doc = "Bits 9:10 - Capture Event Select for Timer A"]
            #[inline(always)]
            #[must_use]
            pub fn capevent_sel_a(&mut self) -> CAPEVENT_SEL_A_W<CTRL1_SPEC> {
                CAPEVENT_SEL_A_W::new(self, 9)
            }
            #[doc = "Bit 11 - Software Capture Event for Timer A"]
            #[inline(always)]
            #[must_use]
            pub fn sw_capevent_a(&mut self) -> SW_CAPEVENT_A_W<CTRL1_SPEC> {
                SW_CAPEVENT_A_W::new(self, 11)
            }
            #[doc = "Bit 12 - Wake-Up Enable for Timer A"]
            #[inline(always)]
            #[must_use]
            pub fn we_a(&mut self) -> WE_A_W<CTRL1_SPEC> {
                WE_A_W::new(self, 12)
            }
            #[doc = "Bit 13 - OUT_OE_O Enable for Modes 0, 1,and 5 for Timer A"]
            #[inline(always)]
            #[must_use]
            pub fn outen_a(&mut self) -> OUTEN_A_W<CTRL1_SPEC> {
                OUTEN_A_W::new(self, 13)
            }
            #[doc = "Bit 14 - PWM_CKB_EN_O Enable for Modes other than Mode 3 for Timer A"]
            #[inline(always)]
            #[must_use]
            pub fn outben_a(&mut self) -> OUTBEN_A_W<CTRL1_SPEC> {
                OUTBEN_A_W::new(self, 14)
            }
            #[doc = "Bits 16:17 - Timer Clock Select for Timer B"]
            #[inline(always)]
            #[must_use]
            pub fn clksel_b(&mut self) -> CLKSEL_B_W<CTRL1_SPEC> {
                CLKSEL_B_W::new(self, 16)
            }
            #[doc = "Bit 18 - Timer B Enable Status"]
            #[inline(always)]
            #[must_use]
            pub fn clken_b(&mut self) -> CLKEN_B_W<CTRL1_SPEC> {
                CLKEN_B_W::new(self, 18)
            }
            #[doc = "Bit 19 - CLK_TMR Ready Flag for Timer B"]
            #[inline(always)]
            #[must_use]
            pub fn clkrdy_b(&mut self) -> CLKRDY_B_W<CTRL1_SPEC> {
                CLKRDY_B_W::new(self, 19)
            }
            #[doc = "Bits 20:22 - Event Select for Timer B"]
            #[inline(always)]
            #[must_use]
            pub fn event_sel_b(&mut self) -> EVENT_SEL_B_W<CTRL1_SPEC> {
                EVENT_SEL_B_W::new(self, 20)
            }
            #[doc = "Bit 23 - Negative Edge Trigger for Event for Timer B"]
            #[inline(always)]
            #[must_use]
            pub fn negtrig_b(&mut self) -> NEGTRIG_B_W<CTRL1_SPEC> {
                NEGTRIG_B_W::new(self, 23)
            }
            #[doc = "Bit 24 - Interrupt Enable for Timer B"]
            #[inline(always)]
            #[must_use]
            pub fn ie_b(&mut self) -> IE_B_W<CTRL1_SPEC> {
                IE_B_W::new(self, 24)
            }
            #[doc = "Bits 25:26 - Capture Event Select for Timer B"]
            #[inline(always)]
            #[must_use]
            pub fn capevent_sel_b(&mut self) -> CAPEVENT_SEL_B_W<CTRL1_SPEC> {
                CAPEVENT_SEL_B_W::new(self, 25)
            }
            #[doc = "Bit 27 - Software Capture Event for Timer B"]
            #[inline(always)]
            #[must_use]
            pub fn sw_capevent_b(&mut self) -> SW_CAPEVENT_B_W<CTRL1_SPEC> {
                SW_CAPEVENT_B_W::new(self, 27)
            }
            #[doc = "Bit 28 - Wake-Up Enable for Timer B"]
            #[inline(always)]
            #[must_use]
            pub fn we_b(&mut self) -> WE_B_W<CTRL1_SPEC> {
                WE_B_W::new(self, 28)
            }
            #[doc = "Bit 31 - Cascade two 16-bit timers into one 32-bit timer. Only available when C_TMR16=0 adn C_DUALTMR16=1."]
            #[inline(always)]
            #[must_use]
            pub fn cascade(&mut self) -> CASCADE_W<CTRL1_SPEC> {
                CASCADE_W::new(self, 31)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Timer Configuration Register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ctrl1::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl1::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CTRL1_SPEC;
        impl crate::RegisterSpec for CTRL1_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ctrl1::R`](R) reader structure"]
        impl crate::Readable for CTRL1_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`ctrl1::W`](W) writer structure"]
        impl crate::Writable for CTRL1_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets CTRL1 to value 0"]
        impl crate::Resettable for CTRL1_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "WKFL (rw) register accessor: Timer Wakeup Status Register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`wkfl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`wkfl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@wkfl`]
module"]
    pub type WKFL = crate::Reg<wkfl::WKFL_SPEC>;
    #[doc = "Timer Wakeup Status Register."]
    pub mod wkfl {
        #[doc = "Register `WKFL` reader"]
        pub type R = crate::R<WKFL_SPEC>;
        #[doc = "Register `WKFL` writer"]
        pub type W = crate::W<WKFL_SPEC>;
        #[doc = "Field `A` reader - Wake-Up Flag for Timer A"]
        pub type A_R = crate::BitReader;
        #[doc = "Field `A` writer - Wake-Up Flag for Timer A"]
        pub type A_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `B` reader - Wake-Up Flag for Timer B"]
        pub type B_R = crate::BitReader;
        #[doc = "Field `B` writer - Wake-Up Flag for Timer B"]
        pub type B_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Wake-Up Flag for Timer A"]
            #[inline(always)]
            pub fn a(&self) -> A_R {
                A_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 16 - Wake-Up Flag for Timer B"]
            #[inline(always)]
            pub fn b(&self) -> B_R {
                B_R::new(((self.bits >> 16) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Wake-Up Flag for Timer A"]
            #[inline(always)]
            #[must_use]
            pub fn a(&mut self) -> A_W<WKFL_SPEC> {
                A_W::new(self, 0)
            }
            #[doc = "Bit 16 - Wake-Up Flag for Timer B"]
            #[inline(always)]
            #[must_use]
            pub fn b(&mut self) -> B_W<WKFL_SPEC> {
                B_W::new(self, 16)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Timer Wakeup Status Register.\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`wkfl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`wkfl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct WKFL_SPEC;
        impl crate::RegisterSpec for WKFL_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`wkfl::R`](R) reader structure"]
        impl crate::Readable for WKFL_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`wkfl::W`](W) writer structure"]
        impl crate::Writable for WKFL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets WKFL to value 0"]
        impl crate::Resettable for WKFL_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[doc = "UART Low Power Registers"]
pub struct UART0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART0 {}
impl UART0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const uart0::RegisterBlock = 0x4004_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const uart0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for UART0 {
    type Target = uart0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART0").finish()
    }
}
#[doc = "UART Low Power Registers"]
pub mod uart0 {
    #[doc = r"Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        ctrl: CTRL,
        status: STATUS,
        int_en: INT_EN,
        int_fl: INT_FL,
        clkdiv: CLKDIV,
        osr: OSR,
        txpeek: TXPEEK,
        pnr: PNR,
        fifo: FIFO,
        _reserved9: [u8; 0x0c],
        dma: DMA,
        wken: WKEN,
        wkfl: WKFL,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Control register"]
        #[inline(always)]
        pub const fn ctrl(&self) -> &CTRL {
            &self.ctrl
        }
        #[doc = "0x04 - Status register"]
        #[inline(always)]
        pub const fn status(&self) -> &STATUS {
            &self.status
        }
        #[doc = "0x08 - Interrupt Enable control register"]
        #[inline(always)]
        pub const fn int_en(&self) -> &INT_EN {
            &self.int_en
        }
        #[doc = "0x0c - Interrupt status flags Control register"]
        #[inline(always)]
        pub const fn int_fl(&self) -> &INT_FL {
            &self.int_fl
        }
        #[doc = "0x10 - Clock Divider register"]
        #[inline(always)]
        pub const fn clkdiv(&self) -> &CLKDIV {
            &self.clkdiv
        }
        #[doc = "0x14 - Over Sampling Rate register"]
        #[inline(always)]
        pub const fn osr(&self) -> &OSR {
            &self.osr
        }
        #[doc = "0x18 - TX FIFO Output Peek register"]
        #[inline(always)]
        pub const fn txpeek(&self) -> &TXPEEK {
            &self.txpeek
        }
        #[doc = "0x1c - Pin register"]
        #[inline(always)]
        pub const fn pnr(&self) -> &PNR {
            &self.pnr
        }
        #[doc = "0x20 - FIFO Read/Write register"]
        #[inline(always)]
        pub const fn fifo(&self) -> &FIFO {
            &self.fifo
        }
        #[doc = "0x30 - DMA Configuration register"]
        #[inline(always)]
        pub const fn dma(&self) -> &DMA {
            &self.dma
        }
        #[doc = "0x34 - Wake up enable Control register"]
        #[inline(always)]
        pub const fn wken(&self) -> &WKEN {
            &self.wken
        }
        #[doc = "0x38 - Wake up Flags register"]
        #[inline(always)]
        pub const fn wkfl(&self) -> &WKFL {
            &self.wkfl
        }
    }
    #[doc = "CTRL (rw) register accessor: Control register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ctrl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl`]
module"]
    pub type CTRL = crate::Reg<ctrl::CTRL_SPEC>;
    #[doc = "Control register"]
    pub mod ctrl {
        #[doc = "Register `CTRL` reader"]
        pub type R = crate::R<CTRL_SPEC>;
        #[doc = "Register `CTRL` writer"]
        pub type W = crate::W<CTRL_SPEC>;
        #[doc = "Field `RX_THD_VAL` reader - This field specifies the depth of receive FIFO for interrupt generation (value 0 and > 16 are ignored)"]
        pub type RX_THD_VAL_R = crate::FieldReader;
        #[doc = "Field `RX_THD_VAL` writer - This field specifies the depth of receive FIFO for interrupt generation (value 0 and > 16 are ignored)"]
        pub type RX_THD_VAL_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `PAR_EN` reader - Parity Enable"]
        pub type PAR_EN_R = crate::BitReader;
        #[doc = "Field `PAR_EN` writer - Parity Enable"]
        pub type PAR_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PAR_EO` reader - when PAREN=1 selects odd or even parity odd is 1 even is 0"]
        pub type PAR_EO_R = crate::BitReader;
        #[doc = "Field `PAR_EO` writer - when PAREN=1 selects odd or even parity odd is 1 even is 0"]
        pub type PAR_EO_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PAR_MD` reader - Selects parity based on 1s or 0s count (when PAREN=1)"]
        pub type PAR_MD_R = crate::BitReader;
        #[doc = "Field `PAR_MD` writer - Selects parity based on 1s or 0s count (when PAREN=1)"]
        pub type PAR_MD_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CTS_DIS` reader - CTS Sampling Disable"]
        pub type CTS_DIS_R = crate::BitReader;
        #[doc = "Field `CTS_DIS` writer - CTS Sampling Disable"]
        pub type CTS_DIS_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TX_FLUSH` reader - Flushes the TX FIFO buffer. This bit is automatically cleared by hardware when flush is completed."]
        pub type TX_FLUSH_R = crate::BitReader;
        #[doc = "Field `TX_FLUSH` writer - Flushes the TX FIFO buffer. This bit is automatically cleared by hardware when flush is completed."]
        pub type TX_FLUSH_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RX_FLUSH` reader - Flushes the RX FIFO buffer. This bit is automatically cleared by hardware when flush is completed."]
        pub type RX_FLUSH_R = crate::BitReader;
        #[doc = "Field `RX_FLUSH` writer - Flushes the RX FIFO buffer. This bit is automatically cleared by hardware when flush is completed."]
        pub type RX_FLUSH_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CHAR_SIZE` reader - Selects UART character size"]
        pub type CHAR_SIZE_R = crate::FieldReader<CHAR_SIZE_A>;
        #[doc = "Selects UART character size\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum CHAR_SIZE_A {
            #[doc = "0: 5 bits"]
            _5BITS = 0,
            #[doc = "1: 6 bits"]
            _6BITS = 1,
            #[doc = "2: 7 bits"]
            _7BITS = 2,
            #[doc = "3: 8 bits"]
            _8BITS = 3,
        }
        impl From<CHAR_SIZE_A> for u8 {
            #[inline(always)]
            fn from(variant: CHAR_SIZE_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for CHAR_SIZE_A {
            type Ux = u8;
        }
        impl CHAR_SIZE_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> CHAR_SIZE_A {
                match self.bits {
                    0 => CHAR_SIZE_A::_5BITS,
                    1 => CHAR_SIZE_A::_6BITS,
                    2 => CHAR_SIZE_A::_7BITS,
                    3 => CHAR_SIZE_A::_8BITS,
                    _ => unreachable!(),
                }
            }
            #[doc = "5 bits"]
            #[inline(always)]
            pub fn is_5bits(&self) -> bool {
                *self == CHAR_SIZE_A::_5BITS
            }
            #[doc = "6 bits"]
            #[inline(always)]
            pub fn is_6bits(&self) -> bool {
                *self == CHAR_SIZE_A::_6BITS
            }
            #[doc = "7 bits"]
            #[inline(always)]
            pub fn is_7bits(&self) -> bool {
                *self == CHAR_SIZE_A::_7BITS
            }
            #[doc = "8 bits"]
            #[inline(always)]
            pub fn is_8bits(&self) -> bool {
                *self == CHAR_SIZE_A::_8BITS
            }
        }
        #[doc = "Field `CHAR_SIZE` writer - Selects UART character size"]
        pub type CHAR_SIZE_W<'a, REG> = crate::FieldWriterSafe<'a, REG, 2, CHAR_SIZE_A>;
        impl<'a, REG> CHAR_SIZE_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "5 bits"]
            #[inline(always)]
            pub fn _5bits(self) -> &'a mut crate::W<REG> {
                self.variant(CHAR_SIZE_A::_5BITS)
            }
            #[doc = "6 bits"]
            #[inline(always)]
            pub fn _6bits(self) -> &'a mut crate::W<REG> {
                self.variant(CHAR_SIZE_A::_6BITS)
            }
            #[doc = "7 bits"]
            #[inline(always)]
            pub fn _7bits(self) -> &'a mut crate::W<REG> {
                self.variant(CHAR_SIZE_A::_7BITS)
            }
            #[doc = "8 bits"]
            #[inline(always)]
            pub fn _8bits(self) -> &'a mut crate::W<REG> {
                self.variant(CHAR_SIZE_A::_8BITS)
            }
        }
        #[doc = "Field `STOPBITS` reader - Selects the number of stop bits that will be generated"]
        pub type STOPBITS_R = crate::BitReader;
        #[doc = "Field `STOPBITS` writer - Selects the number of stop bits that will be generated"]
        pub type STOPBITS_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `HFC_EN` reader - Enables/disables hardware flow control"]
        pub type HFC_EN_R = crate::BitReader;
        #[doc = "Field `HFC_EN` writer - Enables/disables hardware flow control"]
        pub type HFC_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RTSDC` reader - Hardware Flow Control RTS Mode"]
        pub type RTSDC_R = crate::BitReader;
        #[doc = "Field `RTSDC` writer - Hardware Flow Control RTS Mode"]
        pub type RTSDC_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `BCLKEN` reader - Baud clock enable"]
        pub type BCLKEN_R = crate::BitReader;
        #[doc = "Field `BCLKEN` writer - Baud clock enable"]
        pub type BCLKEN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `BCLKSRC` reader - To select the UART clock source for the UART engine (except APB registers). Secondary clock (used for baud rate generator) can be asynchronous from APB clock."]
        pub type BCLKSRC_R = crate::FieldReader<BCLKSRC_A>;
        #[doc = "To select the UART clock source for the UART engine (except APB registers). Secondary clock (used for baud rate generator) can be asynchronous from APB clock.\n\nValue on reset: 0"]
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(u8)]
        pub enum BCLKSRC_A {
            #[doc = "0: apb clock"]
            PERIPHERAL_CLOCK = 0,
            #[doc = "1: Clock 1"]
            EXTERNAL_CLOCK = 1,
            #[doc = "2: Clock 2"]
            CLK2 = 2,
            #[doc = "3: Clock 3"]
            CLK3 = 3,
        }
        impl From<BCLKSRC_A> for u8 {
            #[inline(always)]
            fn from(variant: BCLKSRC_A) -> Self {
                variant as _
            }
        }
        impl crate::FieldSpec for BCLKSRC_A {
            type Ux = u8;
        }
        impl BCLKSRC_R {
            #[doc = "Get enumerated values variant"]
            #[inline(always)]
            pub const fn variant(&self) -> BCLKSRC_A {
                match self.bits {
                    0 => BCLKSRC_A::PERIPHERAL_CLOCK,
                    1 => BCLKSRC_A::EXTERNAL_CLOCK,
                    2 => BCLKSRC_A::CLK2,
                    3 => BCLKSRC_A::CLK3,
                    _ => unreachable!(),
                }
            }
            #[doc = "apb clock"]
            #[inline(always)]
            pub fn is_peripheral_clock(&self) -> bool {
                *self == BCLKSRC_A::PERIPHERAL_CLOCK
            }
            #[doc = "Clock 1"]
            #[inline(always)]
            pub fn is_external_clock(&self) -> bool {
                *self == BCLKSRC_A::EXTERNAL_CLOCK
            }
            #[doc = "Clock 2"]
            #[inline(always)]
            pub fn is_clk2(&self) -> bool {
                *self == BCLKSRC_A::CLK2
            }
            #[doc = "Clock 3"]
            #[inline(always)]
            pub fn is_clk3(&self) -> bool {
                *self == BCLKSRC_A::CLK3
            }
        }
        #[doc = "Field `BCLKSRC` writer - To select the UART clock source for the UART engine (except APB registers). Secondary clock (used for baud rate generator) can be asynchronous from APB clock."]
        pub type BCLKSRC_W<'a, REG> = crate::FieldWriterSafe<'a, REG, 2, BCLKSRC_A>;
        impl<'a, REG> BCLKSRC_W<'a, REG>
        where
            REG: crate::Writable + crate::RegisterSpec,
            REG::Ux: From<u8>,
        {
            #[doc = "apb clock"]
            #[inline(always)]
            pub fn peripheral_clock(self) -> &'a mut crate::W<REG> {
                self.variant(BCLKSRC_A::PERIPHERAL_CLOCK)
            }
            #[doc = "Clock 1"]
            #[inline(always)]
            pub fn external_clock(self) -> &'a mut crate::W<REG> {
                self.variant(BCLKSRC_A::EXTERNAL_CLOCK)
            }
            #[doc = "Clock 2"]
            #[inline(always)]
            pub fn clk2(self) -> &'a mut crate::W<REG> {
                self.variant(BCLKSRC_A::CLK2)
            }
            #[doc = "Clock 3"]
            #[inline(always)]
            pub fn clk3(self) -> &'a mut crate::W<REG> {
                self.variant(BCLKSRC_A::CLK3)
            }
        }
        #[doc = "Field `DPFE_EN` reader - Data/Parity bit frame error detection enable"]
        pub type DPFE_EN_R = crate::BitReader;
        #[doc = "Field `DPFE_EN` writer - Data/Parity bit frame error detection enable"]
        pub type DPFE_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `BCLKRDY` reader - Baud clock Ready read only bit"]
        pub type BCLKRDY_R = crate::BitReader;
        #[doc = "Field `BCLKRDY` writer - Baud clock Ready read only bit"]
        pub type BCLKRDY_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UCAGM` reader - UART Clock Auto Gating mode"]
        pub type UCAGM_R = crate::BitReader;
        #[doc = "Field `UCAGM` writer - UART Clock Auto Gating mode"]
        pub type UCAGM_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FDM` reader - Fractional Division Mode"]
        pub type FDM_R = crate::BitReader;
        #[doc = "Field `FDM` writer - Fractional Division Mode"]
        pub type FDM_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `DESM` reader - RX Dual Edge Sampling Mode"]
        pub type DESM_R = crate::BitReader;
        #[doc = "Field `DESM` writer - RX Dual Edge Sampling Mode"]
        pub type DESM_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:3 - This field specifies the depth of receive FIFO for interrupt generation (value 0 and > 16 are ignored)"]
            #[inline(always)]
            pub fn rx_thd_val(&self) -> RX_THD_VAL_R {
                RX_THD_VAL_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bit 4 - Parity Enable"]
            #[inline(always)]
            pub fn par_en(&self) -> PAR_EN_R {
                PAR_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - when PAREN=1 selects odd or even parity odd is 1 even is 0"]
            #[inline(always)]
            pub fn par_eo(&self) -> PAR_EO_R {
                PAR_EO_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Selects parity based on 1s or 0s count (when PAREN=1)"]
            #[inline(always)]
            pub fn par_md(&self) -> PAR_MD_R {
                PAR_MD_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - CTS Sampling Disable"]
            #[inline(always)]
            pub fn cts_dis(&self) -> CTS_DIS_R {
                CTS_DIS_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - Flushes the TX FIFO buffer. This bit is automatically cleared by hardware when flush is completed."]
            #[inline(always)]
            pub fn tx_flush(&self) -> TX_FLUSH_R {
                TX_FLUSH_R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - Flushes the RX FIFO buffer. This bit is automatically cleared by hardware when flush is completed."]
            #[inline(always)]
            pub fn rx_flush(&self) -> RX_FLUSH_R {
                RX_FLUSH_R::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bits 10:11 - Selects UART character size"]
            #[inline(always)]
            pub fn char_size(&self) -> CHAR_SIZE_R {
                CHAR_SIZE_R::new(((self.bits >> 10) & 3) as u8)
            }
            #[doc = "Bit 12 - Selects the number of stop bits that will be generated"]
            #[inline(always)]
            pub fn stopbits(&self) -> STOPBITS_R {
                STOPBITS_R::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - Enables/disables hardware flow control"]
            #[inline(always)]
            pub fn hfc_en(&self) -> HFC_EN_R {
                HFC_EN_R::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - Hardware Flow Control RTS Mode"]
            #[inline(always)]
            pub fn rtsdc(&self) -> RTSDC_R {
                RTSDC_R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - Baud clock enable"]
            #[inline(always)]
            pub fn bclken(&self) -> BCLKEN_R {
                BCLKEN_R::new(((self.bits >> 15) & 1) != 0)
            }
            #[doc = "Bits 16:17 - To select the UART clock source for the UART engine (except APB registers). Secondary clock (used for baud rate generator) can be asynchronous from APB clock."]
            #[inline(always)]
            pub fn bclksrc(&self) -> BCLKSRC_R {
                BCLKSRC_R::new(((self.bits >> 16) & 3) as u8)
            }
            #[doc = "Bit 18 - Data/Parity bit frame error detection enable"]
            #[inline(always)]
            pub fn dpfe_en(&self) -> DPFE_EN_R {
                DPFE_EN_R::new(((self.bits >> 18) & 1) != 0)
            }
            #[doc = "Bit 19 - Baud clock Ready read only bit"]
            #[inline(always)]
            pub fn bclkrdy(&self) -> BCLKRDY_R {
                BCLKRDY_R::new(((self.bits >> 19) & 1) != 0)
            }
            #[doc = "Bit 20 - UART Clock Auto Gating mode"]
            #[inline(always)]
            pub fn ucagm(&self) -> UCAGM_R {
                UCAGM_R::new(((self.bits >> 20) & 1) != 0)
            }
            #[doc = "Bit 21 - Fractional Division Mode"]
            #[inline(always)]
            pub fn fdm(&self) -> FDM_R {
                FDM_R::new(((self.bits >> 21) & 1) != 0)
            }
            #[doc = "Bit 22 - RX Dual Edge Sampling Mode"]
            #[inline(always)]
            pub fn desm(&self) -> DESM_R {
                DESM_R::new(((self.bits >> 22) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - This field specifies the depth of receive FIFO for interrupt generation (value 0 and > 16 are ignored)"]
            #[inline(always)]
            #[must_use]
            pub fn rx_thd_val(&mut self) -> RX_THD_VAL_W<CTRL_SPEC> {
                RX_THD_VAL_W::new(self, 0)
            }
            #[doc = "Bit 4 - Parity Enable"]
            #[inline(always)]
            #[must_use]
            pub fn par_en(&mut self) -> PAR_EN_W<CTRL_SPEC> {
                PAR_EN_W::new(self, 4)
            }
            #[doc = "Bit 5 - when PAREN=1 selects odd or even parity odd is 1 even is 0"]
            #[inline(always)]
            #[must_use]
            pub fn par_eo(&mut self) -> PAR_EO_W<CTRL_SPEC> {
                PAR_EO_W::new(self, 5)
            }
            #[doc = "Bit 6 - Selects parity based on 1s or 0s count (when PAREN=1)"]
            #[inline(always)]
            #[must_use]
            pub fn par_md(&mut self) -> PAR_MD_W<CTRL_SPEC> {
                PAR_MD_W::new(self, 6)
            }
            #[doc = "Bit 7 - CTS Sampling Disable"]
            #[inline(always)]
            #[must_use]
            pub fn cts_dis(&mut self) -> CTS_DIS_W<CTRL_SPEC> {
                CTS_DIS_W::new(self, 7)
            }
            #[doc = "Bit 8 - Flushes the TX FIFO buffer. This bit is automatically cleared by hardware when flush is completed."]
            #[inline(always)]
            #[must_use]
            pub fn tx_flush(&mut self) -> TX_FLUSH_W<CTRL_SPEC> {
                TX_FLUSH_W::new(self, 8)
            }
            #[doc = "Bit 9 - Flushes the RX FIFO buffer. This bit is automatically cleared by hardware when flush is completed."]
            #[inline(always)]
            #[must_use]
            pub fn rx_flush(&mut self) -> RX_FLUSH_W<CTRL_SPEC> {
                RX_FLUSH_W::new(self, 9)
            }
            #[doc = "Bits 10:11 - Selects UART character size"]
            #[inline(always)]
            #[must_use]
            pub fn char_size(&mut self) -> CHAR_SIZE_W<CTRL_SPEC> {
                CHAR_SIZE_W::new(self, 10)
            }
            #[doc = "Bit 12 - Selects the number of stop bits that will be generated"]
            #[inline(always)]
            #[must_use]
            pub fn stopbits(&mut self) -> STOPBITS_W<CTRL_SPEC> {
                STOPBITS_W::new(self, 12)
            }
            #[doc = "Bit 13 - Enables/disables hardware flow control"]
            #[inline(always)]
            #[must_use]
            pub fn hfc_en(&mut self) -> HFC_EN_W<CTRL_SPEC> {
                HFC_EN_W::new(self, 13)
            }
            #[doc = "Bit 14 - Hardware Flow Control RTS Mode"]
            #[inline(always)]
            #[must_use]
            pub fn rtsdc(&mut self) -> RTSDC_W<CTRL_SPEC> {
                RTSDC_W::new(self, 14)
            }
            #[doc = "Bit 15 - Baud clock enable"]
            #[inline(always)]
            #[must_use]
            pub fn bclken(&mut self) -> BCLKEN_W<CTRL_SPEC> {
                BCLKEN_W::new(self, 15)
            }
            #[doc = "Bits 16:17 - To select the UART clock source for the UART engine (except APB registers). Secondary clock (used for baud rate generator) can be asynchronous from APB clock."]
            #[inline(always)]
            #[must_use]
            pub fn bclksrc(&mut self) -> BCLKSRC_W<CTRL_SPEC> {
                BCLKSRC_W::new(self, 16)
            }
            #[doc = "Bit 18 - Data/Parity bit frame error detection enable"]
            #[inline(always)]
            #[must_use]
            pub fn dpfe_en(&mut self) -> DPFE_EN_W<CTRL_SPEC> {
                DPFE_EN_W::new(self, 18)
            }
            #[doc = "Bit 19 - Baud clock Ready read only bit"]
            #[inline(always)]
            #[must_use]
            pub fn bclkrdy(&mut self) -> BCLKRDY_W<CTRL_SPEC> {
                BCLKRDY_W::new(self, 19)
            }
            #[doc = "Bit 20 - UART Clock Auto Gating mode"]
            #[inline(always)]
            #[must_use]
            pub fn ucagm(&mut self) -> UCAGM_W<CTRL_SPEC> {
                UCAGM_W::new(self, 20)
            }
            #[doc = "Bit 21 - Fractional Division Mode"]
            #[inline(always)]
            #[must_use]
            pub fn fdm(&mut self) -> FDM_W<CTRL_SPEC> {
                FDM_W::new(self, 21)
            }
            #[doc = "Bit 22 - RX Dual Edge Sampling Mode"]
            #[inline(always)]
            #[must_use]
            pub fn desm(&mut self) -> DESM_W<CTRL_SPEC> {
                DESM_W::new(self, 22)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Control register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`ctrl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`ctrl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CTRL_SPEC;
        impl crate::RegisterSpec for CTRL_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ctrl::R`](R) reader structure"]
        impl crate::Readable for CTRL_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`ctrl::W`](W) writer structure"]
        impl crate::Writable for CTRL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets CTRL to value 0"]
        impl crate::Resettable for CTRL_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "STATUS (r) register accessor: Status register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`status::R`].  See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@status`]
module"]
    pub type STATUS = crate::Reg<status::STATUS_SPEC>;
    #[doc = "Status register"]
    pub mod status {
        #[doc = "Register `STATUS` reader"]
        pub type R = crate::R<STATUS_SPEC>;
        #[doc = "Field `TX_BUSY` reader - Read-only flag indicating the UART transmit status"]
        pub type TX_BUSY_R = crate::BitReader;
        #[doc = "Field `RX_BUSY` reader - Read-only flag indicating the UART receiver status"]
        pub type RX_BUSY_R = crate::BitReader;
        #[doc = "Field `RX_EM` reader - Read-only flag indicating the RX FIFO state"]
        pub type RX_EM_R = crate::BitReader;
        #[doc = "Field `RX_FULL` reader - Read-only flag indicating the RX FIFO state"]
        pub type RX_FULL_R = crate::BitReader;
        #[doc = "Field `TX_EM` reader - Read-only flag indicating the TX FIFO state"]
        pub type TX_EM_R = crate::BitReader;
        #[doc = "Field `TX_FULL` reader - Read-only flag indicating the TX FIFO state"]
        pub type TX_FULL_R = crate::BitReader;
        #[doc = "Field `RX_LVL` reader - Indicates the number of bytes currently in the RX FIFO (0-RX FIFO_ELTS)"]
        pub type RX_LVL_R = crate::FieldReader;
        #[doc = "Field `TX_LVL` reader - Indicates the number of bytes currently in the TX FIFO (0-TX FIFO_ELTS)"]
        pub type TX_LVL_R = crate::FieldReader;
        impl R {
            #[doc = "Bit 0 - Read-only flag indicating the UART transmit status"]
            #[inline(always)]
            pub fn tx_busy(&self) -> TX_BUSY_R {
                TX_BUSY_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Read-only flag indicating the UART receiver status"]
            #[inline(always)]
            pub fn rx_busy(&self) -> RX_BUSY_R {
                RX_BUSY_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 4 - Read-only flag indicating the RX FIFO state"]
            #[inline(always)]
            pub fn rx_em(&self) -> RX_EM_R {
                RX_EM_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Read-only flag indicating the RX FIFO state"]
            #[inline(always)]
            pub fn rx_full(&self) -> RX_FULL_R {
                RX_FULL_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Read-only flag indicating the TX FIFO state"]
            #[inline(always)]
            pub fn tx_em(&self) -> TX_EM_R {
                TX_EM_R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - Read-only flag indicating the TX FIFO state"]
            #[inline(always)]
            pub fn tx_full(&self) -> TX_FULL_R {
                TX_FULL_R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bits 8:11 - Indicates the number of bytes currently in the RX FIFO (0-RX FIFO_ELTS)"]
            #[inline(always)]
            pub fn rx_lvl(&self) -> RX_LVL_R {
                RX_LVL_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            #[doc = "Bits 12:15 - Indicates the number of bytes currently in the TX FIFO (0-TX FIFO_ELTS)"]
            #[inline(always)]
            pub fn tx_lvl(&self) -> TX_LVL_R {
                TX_LVL_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        #[doc = "Status register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`status::R`](R).  See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct STATUS_SPEC;
        impl crate::RegisterSpec for STATUS_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`status::R`](R) reader structure"]
        impl crate::Readable for STATUS_SPEC {}
        #[doc = "`reset()` method sets STATUS to value 0"]
        impl crate::Resettable for STATUS_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "INT_EN (rw) register accessor: Interrupt Enable control register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`int_en::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_en::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_en`]
module"]
    pub type INT_EN = crate::Reg<int_en::INT_EN_SPEC>;
    #[doc = "Interrupt Enable control register"]
    pub mod int_en {
        #[doc = "Register `INT_EN` reader"]
        pub type R = crate::R<INT_EN_SPEC>;
        #[doc = "Register `INT_EN` writer"]
        pub type W = crate::W<INT_EN_SPEC>;
        #[doc = "Field `RX_FERR` reader - Enable Interrupt For RX Frame Error"]
        pub type RX_FERR_R = crate::BitReader;
        #[doc = "Field `RX_FERR` writer - Enable Interrupt For RX Frame Error"]
        pub type RX_FERR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RX_PAR` reader - Enable Interrupt For RX Parity Error"]
        pub type RX_PAR_R = crate::BitReader;
        #[doc = "Field `RX_PAR` writer - Enable Interrupt For RX Parity Error"]
        pub type RX_PAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CTS_EV` reader - Enable Interrupt For CTS signal change Error"]
        pub type CTS_EV_R = crate::BitReader;
        #[doc = "Field `CTS_EV` writer - Enable Interrupt For CTS signal change Error"]
        pub type CTS_EV_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RX_OV` reader - Enable Interrupt For RX FIFO Overrun Error"]
        pub type RX_OV_R = crate::BitReader;
        #[doc = "Field `RX_OV` writer - Enable Interrupt For RX FIFO Overrun Error"]
        pub type RX_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RX_THD` reader - Enable Interrupt For RX FIFO reaches the number of bytes configured by RXTHD"]
        pub type RX_THD_R = crate::BitReader;
        #[doc = "Field `RX_THD` writer - Enable Interrupt For RX FIFO reaches the number of bytes configured by RXTHD"]
        pub type RX_THD_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TX_OB` reader - Enable Interrupt For TX FIFO has one byte remaining"]
        pub type TX_OB_R = crate::BitReader;
        #[doc = "Field `TX_OB` writer - Enable Interrupt For TX FIFO has one byte remaining"]
        pub type TX_OB_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TX_HE` reader - Enable Interrupt For TX FIFO has half empty"]
        pub type TX_HE_R = crate::BitReader;
        #[doc = "Field `TX_HE` writer - Enable Interrupt For TX FIFO has half empty"]
        pub type TX_HE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Enable Interrupt For RX Frame Error"]
            #[inline(always)]
            pub fn rx_ferr(&self) -> RX_FERR_R {
                RX_FERR_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Enable Interrupt For RX Parity Error"]
            #[inline(always)]
            pub fn rx_par(&self) -> RX_PAR_R {
                RX_PAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Enable Interrupt For CTS signal change Error"]
            #[inline(always)]
            pub fn cts_ev(&self) -> CTS_EV_R {
                CTS_EV_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Enable Interrupt For RX FIFO Overrun Error"]
            #[inline(always)]
            pub fn rx_ov(&self) -> RX_OV_R {
                RX_OV_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Enable Interrupt For RX FIFO reaches the number of bytes configured by RXTHD"]
            #[inline(always)]
            pub fn rx_thd(&self) -> RX_THD_R {
                RX_THD_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Enable Interrupt For TX FIFO has one byte remaining"]
            #[inline(always)]
            pub fn tx_ob(&self) -> TX_OB_R {
                TX_OB_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Enable Interrupt For TX FIFO has half empty"]
            #[inline(always)]
            pub fn tx_he(&self) -> TX_HE_R {
                TX_HE_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Enable Interrupt For RX Frame Error"]
            #[inline(always)]
            #[must_use]
            pub fn rx_ferr(&mut self) -> RX_FERR_W<INT_EN_SPEC> {
                RX_FERR_W::new(self, 0)
            }
            #[doc = "Bit 1 - Enable Interrupt For RX Parity Error"]
            #[inline(always)]
            #[must_use]
            pub fn rx_par(&mut self) -> RX_PAR_W<INT_EN_SPEC> {
                RX_PAR_W::new(self, 1)
            }
            #[doc = "Bit 2 - Enable Interrupt For CTS signal change Error"]
            #[inline(always)]
            #[must_use]
            pub fn cts_ev(&mut self) -> CTS_EV_W<INT_EN_SPEC> {
                CTS_EV_W::new(self, 2)
            }
            #[doc = "Bit 3 - Enable Interrupt For RX FIFO Overrun Error"]
            #[inline(always)]
            #[must_use]
            pub fn rx_ov(&mut self) -> RX_OV_W<INT_EN_SPEC> {
                RX_OV_W::new(self, 3)
            }
            #[doc = "Bit 4 - Enable Interrupt For RX FIFO reaches the number of bytes configured by RXTHD"]
            #[inline(always)]
            #[must_use]
            pub fn rx_thd(&mut self) -> RX_THD_W<INT_EN_SPEC> {
                RX_THD_W::new(self, 4)
            }
            #[doc = "Bit 5 - Enable Interrupt For TX FIFO has one byte remaining"]
            #[inline(always)]
            #[must_use]
            pub fn tx_ob(&mut self) -> TX_OB_W<INT_EN_SPEC> {
                TX_OB_W::new(self, 5)
            }
            #[doc = "Bit 6 - Enable Interrupt For TX FIFO has half empty"]
            #[inline(always)]
            #[must_use]
            pub fn tx_he(&mut self) -> TX_HE_W<INT_EN_SPEC> {
                TX_HE_W::new(self, 6)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Interrupt Enable control register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`int_en::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_en::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct INT_EN_SPEC;
        impl crate::RegisterSpec for INT_EN_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`int_en::R`](R) reader structure"]
        impl crate::Readable for INT_EN_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`int_en::W`](W) writer structure"]
        impl crate::Writable for INT_EN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets INT_EN to value 0"]
        impl crate::Resettable for INT_EN_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "INT_FL (rw) register accessor: Interrupt status flags Control register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`int_fl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_fl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_fl`]
module"]
    pub type INT_FL = crate::Reg<int_fl::INT_FL_SPEC>;
    #[doc = "Interrupt status flags Control register"]
    pub mod int_fl {
        #[doc = "Register `INT_FL` reader"]
        pub type R = crate::R<INT_FL_SPEC>;
        #[doc = "Register `INT_FL` writer"]
        pub type W = crate::W<INT_FL_SPEC>;
        #[doc = "Field `RX_FERR` reader - Flag for RX Frame Error Interrupt."]
        pub type RX_FERR_R = crate::BitReader;
        #[doc = "Field `RX_FERR` writer - Flag for RX Frame Error Interrupt."]
        pub type RX_FERR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RX_PAR` reader - Flag for RX Parity Error interrupt"]
        pub type RX_PAR_R = crate::BitReader;
        #[doc = "Field `RX_PAR` writer - Flag for RX Parity Error interrupt"]
        pub type RX_PAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CTS_EV` reader - Flag for CTS signal change interrupt (hardware flow control disabled)"]
        pub type CTS_EV_R = crate::BitReader;
        #[doc = "Field `CTS_EV` writer - Flag for CTS signal change interrupt (hardware flow control disabled)"]
        pub type CTS_EV_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RX_OV` reader - Flag for RX FIFO Overrun interrupt"]
        pub type RX_OV_R = crate::BitReader;
        #[doc = "Field `RX_OV` writer - Flag for RX FIFO Overrun interrupt"]
        pub type RX_OV_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RX_THD` reader - Flag for interrupt when RX FIFO reaches the number of bytes configured by the RXTHD field"]
        pub type RX_THD_R = crate::BitReader;
        #[doc = "Field `RX_THD` writer - Flag for interrupt when RX FIFO reaches the number of bytes configured by the RXTHD field"]
        pub type RX_THD_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TX_OB` reader - Flag for interrupt when TX FIFO has one byte remaining"]
        pub type TX_OB_R = crate::BitReader;
        #[doc = "Field `TX_OB` writer - Flag for interrupt when TX FIFO has one byte remaining"]
        pub type TX_OB_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TX_HE` reader - Flag for interrupt when TX FIFO is half empty"]
        pub type TX_HE_R = crate::BitReader;
        #[doc = "Field `TX_HE` writer - Flag for interrupt when TX FIFO is half empty"]
        pub type TX_HE_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Flag for RX Frame Error Interrupt."]
            #[inline(always)]
            pub fn rx_ferr(&self) -> RX_FERR_R {
                RX_FERR_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Flag for RX Parity Error interrupt"]
            #[inline(always)]
            pub fn rx_par(&self) -> RX_PAR_R {
                RX_PAR_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Flag for CTS signal change interrupt (hardware flow control disabled)"]
            #[inline(always)]
            pub fn cts_ev(&self) -> CTS_EV_R {
                CTS_EV_R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - Flag for RX FIFO Overrun interrupt"]
            #[inline(always)]
            pub fn rx_ov(&self) -> RX_OV_R {
                RX_OV_R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - Flag for interrupt when RX FIFO reaches the number of bytes configured by the RXTHD field"]
            #[inline(always)]
            pub fn rx_thd(&self) -> RX_THD_R {
                RX_THD_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Flag for interrupt when TX FIFO has one byte remaining"]
            #[inline(always)]
            pub fn tx_ob(&self) -> TX_OB_R {
                TX_OB_R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - Flag for interrupt when TX FIFO is half empty"]
            #[inline(always)]
            pub fn tx_he(&self) -> TX_HE_R {
                TX_HE_R::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Flag for RX Frame Error Interrupt."]
            #[inline(always)]
            #[must_use]
            pub fn rx_ferr(&mut self) -> RX_FERR_W<INT_FL_SPEC> {
                RX_FERR_W::new(self, 0)
            }
            #[doc = "Bit 1 - Flag for RX Parity Error interrupt"]
            #[inline(always)]
            #[must_use]
            pub fn rx_par(&mut self) -> RX_PAR_W<INT_FL_SPEC> {
                RX_PAR_W::new(self, 1)
            }
            #[doc = "Bit 2 - Flag for CTS signal change interrupt (hardware flow control disabled)"]
            #[inline(always)]
            #[must_use]
            pub fn cts_ev(&mut self) -> CTS_EV_W<INT_FL_SPEC> {
                CTS_EV_W::new(self, 2)
            }
            #[doc = "Bit 3 - Flag for RX FIFO Overrun interrupt"]
            #[inline(always)]
            #[must_use]
            pub fn rx_ov(&mut self) -> RX_OV_W<INT_FL_SPEC> {
                RX_OV_W::new(self, 3)
            }
            #[doc = "Bit 4 - Flag for interrupt when RX FIFO reaches the number of bytes configured by the RXTHD field"]
            #[inline(always)]
            #[must_use]
            pub fn rx_thd(&mut self) -> RX_THD_W<INT_FL_SPEC> {
                RX_THD_W::new(self, 4)
            }
            #[doc = "Bit 5 - Flag for interrupt when TX FIFO has one byte remaining"]
            #[inline(always)]
            #[must_use]
            pub fn tx_ob(&mut self) -> TX_OB_W<INT_FL_SPEC> {
                TX_OB_W::new(self, 5)
            }
            #[doc = "Bit 6 - Flag for interrupt when TX FIFO is half empty"]
            #[inline(always)]
            #[must_use]
            pub fn tx_he(&mut self) -> TX_HE_W<INT_FL_SPEC> {
                TX_HE_W::new(self, 6)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Interrupt status flags Control register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`int_fl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`int_fl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct INT_FL_SPEC;
        impl crate::RegisterSpec for INT_FL_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`int_fl::R`](R) reader structure"]
        impl crate::Readable for INT_FL_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`int_fl::W`](W) writer structure"]
        impl crate::Writable for INT_FL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets INT_FL to value 0"]
        impl crate::Resettable for INT_FL_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "CLKDIV (rw) register accessor: Clock Divider register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`clkdiv::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`clkdiv::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clkdiv`]
module"]
    pub type CLKDIV = crate::Reg<clkdiv::CLKDIV_SPEC>;
    #[doc = "Clock Divider register"]
    pub mod clkdiv {
        #[doc = "Register `CLKDIV` reader"]
        pub type R = crate::R<CLKDIV_SPEC>;
        #[doc = "Register `CLKDIV` writer"]
        pub type W = crate::W<CLKDIV_SPEC>;
        #[doc = "Field `CLKDIV` reader - Baud rate divisor value"]
        pub type CLKDIV_R = crate::FieldReader<u32>;
        #[doc = "Field `CLKDIV` writer - Baud rate divisor value"]
        pub type CLKDIV_W<'a, REG> = crate::FieldWriter<'a, REG, 20, u32>;
        impl R {
            #[doc = "Bits 0:19 - Baud rate divisor value"]
            #[inline(always)]
            pub fn clkdiv(&self) -> CLKDIV_R {
                CLKDIV_R::new(self.bits & 0x000f_ffff)
            }
        }
        impl W {
            #[doc = "Bits 0:19 - Baud rate divisor value"]
            #[inline(always)]
            #[must_use]
            pub fn clkdiv(&mut self) -> CLKDIV_W<CLKDIV_SPEC> {
                CLKDIV_W::new(self, 0)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Clock Divider register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`clkdiv::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`clkdiv::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CLKDIV_SPEC;
        impl crate::RegisterSpec for CLKDIV_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`clkdiv::R`](R) reader structure"]
        impl crate::Readable for CLKDIV_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`clkdiv::W`](W) writer structure"]
        impl crate::Writable for CLKDIV_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets CLKDIV to value 0"]
        impl crate::Resettable for CLKDIV_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "OSR (rw) register accessor: Over Sampling Rate register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`osr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`osr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@osr`]
module"]
    pub type OSR = crate::Reg<osr::OSR_SPEC>;
    #[doc = "Over Sampling Rate register"]
    pub mod osr {
        #[doc = "Register `OSR` reader"]
        pub type R = crate::R<OSR_SPEC>;
        #[doc = "Register `OSR` writer"]
        pub type W = crate::W<OSR_SPEC>;
        #[doc = "Field `OSR` reader - OSR"]
        pub type OSR_R = crate::FieldReader;
        #[doc = "Field `OSR` writer - OSR"]
        pub type OSR_W<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        impl R {
            #[doc = "Bits 0:2 - OSR"]
            #[inline(always)]
            pub fn osr(&self) -> OSR_R {
                OSR_R::new((self.bits & 7) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - OSR"]
            #[inline(always)]
            #[must_use]
            pub fn osr(&mut self) -> OSR_W<OSR_SPEC> {
                OSR_W::new(self, 0)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Over Sampling Rate register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`osr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`osr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct OSR_SPEC;
        impl crate::RegisterSpec for OSR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`osr::R`](R) reader structure"]
        impl crate::Readable for OSR_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`osr::W`](W) writer structure"]
        impl crate::Writable for OSR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets OSR to value 0"]
        impl crate::Resettable for OSR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "TXPEEK (rw) register accessor: TX FIFO Output Peek register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`txpeek::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txpeek::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@txpeek`]
module"]
    pub type TXPEEK = crate::Reg<txpeek::TXPEEK_SPEC>;
    #[doc = "TX FIFO Output Peek register"]
    pub mod txpeek {
        #[doc = "Register `TXPEEK` reader"]
        pub type R = crate::R<TXPEEK_SPEC>;
        #[doc = "Register `TXPEEK` writer"]
        pub type W = crate::W<TXPEEK_SPEC>;
        #[doc = "Field `DATA` reader - Read TX FIFO next data. Reading from this field does not affect the contents of TX FIFO. Note that the parity bit is available from this field."]
        pub type DATA_R = crate::FieldReader;
        #[doc = "Field `DATA` writer - Read TX FIFO next data. Reading from this field does not affect the contents of TX FIFO. Note that the parity bit is available from this field."]
        pub type DATA_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - Read TX FIFO next data. Reading from this field does not affect the contents of TX FIFO. Note that the parity bit is available from this field."]
            #[inline(always)]
            pub fn data(&self) -> DATA_R {
                DATA_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Read TX FIFO next data. Reading from this field does not affect the contents of TX FIFO. Note that the parity bit is available from this field."]
            #[inline(always)]
            #[must_use]
            pub fn data(&mut self) -> DATA_W<TXPEEK_SPEC> {
                DATA_W::new(self, 0)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "TX FIFO Output Peek register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`txpeek::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`txpeek::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct TXPEEK_SPEC;
        impl crate::RegisterSpec for TXPEEK_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`txpeek::R`](R) reader structure"]
        impl crate::Readable for TXPEEK_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`txpeek::W`](W) writer structure"]
        impl crate::Writable for TXPEEK_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets TXPEEK to value 0"]
        impl crate::Resettable for TXPEEK_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "PNR (rw) register accessor: Pin register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`pnr::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pnr::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pnr`]
module"]
    pub type PNR = crate::Reg<pnr::PNR_SPEC>;
    #[doc = "Pin register"]
    pub mod pnr {
        #[doc = "Register `PNR` reader"]
        pub type R = crate::R<PNR_SPEC>;
        #[doc = "Register `PNR` writer"]
        pub type W = crate::W<PNR_SPEC>;
        #[doc = "Field `CTS` reader - Current sampled value of CTS IO"]
        pub type CTS_R = crate::BitReader;
        #[doc = "Field `RTS` reader - This bit controls the value to apply on the RTS IO. If set to 1, the RTS IO is set to high level. If set to 0, the RTS IO is set to low level."]
        pub type RTS_R = crate::BitReader;
        #[doc = "Field `RTS` writer - This bit controls the value to apply on the RTS IO. If set to 1, the RTS IO is set to high level. If set to 0, the RTS IO is set to low level."]
        pub type RTS_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Current sampled value of CTS IO"]
            #[inline(always)]
            pub fn cts(&self) -> CTS_R {
                CTS_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - This bit controls the value to apply on the RTS IO. If set to 1, the RTS IO is set to high level. If set to 0, the RTS IO is set to low level."]
            #[inline(always)]
            pub fn rts(&self) -> RTS_R {
                RTS_R::new(((self.bits >> 1) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 1 - This bit controls the value to apply on the RTS IO. If set to 1, the RTS IO is set to high level. If set to 0, the RTS IO is set to low level."]
            #[inline(always)]
            #[must_use]
            pub fn rts(&mut self) -> RTS_W<PNR_SPEC> {
                RTS_W::new(self, 1)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Pin register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`pnr::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`pnr::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PNR_SPEC;
        impl crate::RegisterSpec for PNR_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pnr::R`](R) reader structure"]
        impl crate::Readable for PNR_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`pnr::W`](W) writer structure"]
        impl crate::Writable for PNR_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets PNR to value 0"]
        impl crate::Resettable for PNR_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "FIFO (rw) register accessor: FIFO Read/Write register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`fifo::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifo::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo`]
module"]
    pub type FIFO = crate::Reg<fifo::FIFO_SPEC>;
    #[doc = "FIFO Read/Write register"]
    pub mod fifo {
        #[doc = "Register `FIFO` reader"]
        pub type R = crate::R<FIFO_SPEC>;
        #[doc = "Register `FIFO` writer"]
        pub type W = crate::W<FIFO_SPEC>;
        #[doc = "Field `DATA` reader - Load/unload location for TX and RX FIFO buffers."]
        pub type DATA_R = crate::FieldReader;
        #[doc = "Field `DATA` writer - Load/unload location for TX and RX FIFO buffers."]
        pub type DATA_W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        #[doc = "Field `RX_PAR` reader - Parity error flag for next byte to be read from FIFO."]
        pub type RX_PAR_R = crate::BitReader;
        #[doc = "Field `RX_PAR` writer - Parity error flag for next byte to be read from FIFO."]
        pub type RX_PAR_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:7 - Load/unload location for TX and RX FIFO buffers."]
            #[inline(always)]
            pub fn data(&self) -> DATA_R {
                DATA_R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bit 8 - Parity error flag for next byte to be read from FIFO."]
            #[inline(always)]
            pub fn rx_par(&self) -> RX_PAR_R {
                RX_PAR_R::new(((self.bits >> 8) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - Load/unload location for TX and RX FIFO buffers."]
            #[inline(always)]
            #[must_use]
            pub fn data(&mut self) -> DATA_W<FIFO_SPEC> {
                DATA_W::new(self, 0)
            }
            #[doc = "Bit 8 - Parity error flag for next byte to be read from FIFO."]
            #[inline(always)]
            #[must_use]
            pub fn rx_par(&mut self) -> RX_PAR_W<FIFO_SPEC> {
                RX_PAR_W::new(self, 8)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "FIFO Read/Write register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`fifo::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`fifo::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FIFO_SPEC;
        impl crate::RegisterSpec for FIFO_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`fifo::R`](R) reader structure"]
        impl crate::Readable for FIFO_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`fifo::W`](W) writer structure"]
        impl crate::Writable for FIFO_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets FIFO to value 0"]
        impl crate::Resettable for FIFO_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "DMA (rw) register accessor: DMA Configuration register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dma::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dma`]
module"]
    pub type DMA = crate::Reg<dma::DMA_SPEC>;
    #[doc = "DMA Configuration register"]
    pub mod dma {
        #[doc = "Register `DMA` reader"]
        pub type R = crate::R<DMA_SPEC>;
        #[doc = "Register `DMA` writer"]
        pub type W = crate::W<DMA_SPEC>;
        #[doc = "Field `TX_THD_VAL` reader - TX FIFO Level DMA Trigger If the TX FIFO level is less than this value, then the TX FIFO DMA interface will send a signal to system DMA to notify that TX FIFO is ready to receive data from memory."]
        pub type TX_THD_VAL_R = crate::FieldReader;
        #[doc = "Field `TX_THD_VAL` writer - TX FIFO Level DMA Trigger If the TX FIFO level is less than this value, then the TX FIFO DMA interface will send a signal to system DMA to notify that TX FIFO is ready to receive data from memory."]
        pub type TX_THD_VAL_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `TX_EN` reader - TX DMA channel enable"]
        pub type TX_EN_R = crate::BitReader;
        #[doc = "Field `TX_EN` writer - TX DMA channel enable"]
        pub type TX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RX_THD_VAL` reader - Rx FIFO Level DMA Trigger If the RX FIFO level is greater than this value, then the RX FIFO DMA interface will send a signal to the system DMA to notify that RX FIFO has characters to transfer to memory."]
        pub type RX_THD_VAL_R = crate::FieldReader;
        #[doc = "Field `RX_THD_VAL` writer - Rx FIFO Level DMA Trigger If the RX FIFO level is greater than this value, then the RX FIFO DMA interface will send a signal to the system DMA to notify that RX FIFO has characters to transfer to memory."]
        pub type RX_THD_VAL_W<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `RX_EN` reader - RX DMA channel enable"]
        pub type RX_EN_R = crate::BitReader;
        #[doc = "Field `RX_EN` writer - RX DMA channel enable"]
        pub type RX_EN_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:3 - TX FIFO Level DMA Trigger If the TX FIFO level is less than this value, then the TX FIFO DMA interface will send a signal to system DMA to notify that TX FIFO is ready to receive data from memory."]
            #[inline(always)]
            pub fn tx_thd_val(&self) -> TX_THD_VAL_R {
                TX_THD_VAL_R::new((self.bits & 0x0f) as u8)
            }
            #[doc = "Bit 4 - TX DMA channel enable"]
            #[inline(always)]
            pub fn tx_en(&self) -> TX_EN_R {
                TX_EN_R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bits 5:8 - Rx FIFO Level DMA Trigger If the RX FIFO level is greater than this value, then the RX FIFO DMA interface will send a signal to the system DMA to notify that RX FIFO has characters to transfer to memory."]
            #[inline(always)]
            pub fn rx_thd_val(&self) -> RX_THD_VAL_R {
                RX_THD_VAL_R::new(((self.bits >> 5) & 0x0f) as u8)
            }
            #[doc = "Bit 9 - RX DMA channel enable"]
            #[inline(always)]
            pub fn rx_en(&self) -> RX_EN_R {
                RX_EN_R::new(((self.bits >> 9) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - TX FIFO Level DMA Trigger If the TX FIFO level is less than this value, then the TX FIFO DMA interface will send a signal to system DMA to notify that TX FIFO is ready to receive data from memory."]
            #[inline(always)]
            #[must_use]
            pub fn tx_thd_val(&mut self) -> TX_THD_VAL_W<DMA_SPEC> {
                TX_THD_VAL_W::new(self, 0)
            }
            #[doc = "Bit 4 - TX DMA channel enable"]
            #[inline(always)]
            #[must_use]
            pub fn tx_en(&mut self) -> TX_EN_W<DMA_SPEC> {
                TX_EN_W::new(self, 4)
            }
            #[doc = "Bits 5:8 - Rx FIFO Level DMA Trigger If the RX FIFO level is greater than this value, then the RX FIFO DMA interface will send a signal to the system DMA to notify that RX FIFO has characters to transfer to memory."]
            #[inline(always)]
            #[must_use]
            pub fn rx_thd_val(&mut self) -> RX_THD_VAL_W<DMA_SPEC> {
                RX_THD_VAL_W::new(self, 5)
            }
            #[doc = "Bit 9 - RX DMA channel enable"]
            #[inline(always)]
            #[must_use]
            pub fn rx_en(&mut self) -> RX_EN_W<DMA_SPEC> {
                RX_EN_W::new(self, 9)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "DMA Configuration register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`dma::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`dma::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DMA_SPEC;
        impl crate::RegisterSpec for DMA_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dma::R`](R) reader structure"]
        impl crate::Readable for DMA_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`dma::W`](W) writer structure"]
        impl crate::Writable for DMA_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets DMA to value 0"]
        impl crate::Resettable for DMA_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "WKEN (rw) register accessor: Wake up enable Control register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`wken::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`wken::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@wken`]
module"]
    pub type WKEN = crate::Reg<wken::WKEN_SPEC>;
    #[doc = "Wake up enable Control register"]
    pub mod wken {
        #[doc = "Register `WKEN` reader"]
        pub type R = crate::R<WKEN_SPEC>;
        #[doc = "Register `WKEN` writer"]
        pub type W = crate::W<WKEN_SPEC>;
        #[doc = "Field `RX_NE` reader - Wake-Up Enable for RX FIFO Not Empty"]
        pub type RX_NE_R = crate::BitReader;
        #[doc = "Field `RX_NE` writer - Wake-Up Enable for RX FIFO Not Empty"]
        pub type RX_NE_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RX_FULL` reader - Wake-Up Enable for RX FIFO Full"]
        pub type RX_FULL_R = crate::BitReader;
        #[doc = "Field `RX_FULL` writer - Wake-Up Enable for RX FIFO Full"]
        pub type RX_FULL_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RX_THD` reader - Wake-Up Enable for RX FIFO Threshold Met"]
        pub type RX_THD_R = crate::BitReader;
        #[doc = "Field `RX_THD` writer - Wake-Up Enable for RX FIFO Threshold Met"]
        pub type RX_THD_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Wake-Up Enable for RX FIFO Not Empty"]
            #[inline(always)]
            pub fn rx_ne(&self) -> RX_NE_R {
                RX_NE_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Wake-Up Enable for RX FIFO Full"]
            #[inline(always)]
            pub fn rx_full(&self) -> RX_FULL_R {
                RX_FULL_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Wake-Up Enable for RX FIFO Threshold Met"]
            #[inline(always)]
            pub fn rx_thd(&self) -> RX_THD_R {
                RX_THD_R::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Wake-Up Enable for RX FIFO Not Empty"]
            #[inline(always)]
            #[must_use]
            pub fn rx_ne(&mut self) -> RX_NE_W<WKEN_SPEC> {
                RX_NE_W::new(self, 0)
            }
            #[doc = "Bit 1 - Wake-Up Enable for RX FIFO Full"]
            #[inline(always)]
            #[must_use]
            pub fn rx_full(&mut self) -> RX_FULL_W<WKEN_SPEC> {
                RX_FULL_W::new(self, 1)
            }
            #[doc = "Bit 2 - Wake-Up Enable for RX FIFO Threshold Met"]
            #[inline(always)]
            #[must_use]
            pub fn rx_thd(&mut self) -> RX_THD_W<WKEN_SPEC> {
                RX_THD_W::new(self, 2)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Wake up enable Control register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`wken::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`wken::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct WKEN_SPEC;
        impl crate::RegisterSpec for WKEN_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`wken::R`](R) reader structure"]
        impl crate::Readable for WKEN_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`wken::W`](W) writer structure"]
        impl crate::Writable for WKEN_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets WKEN to value 0"]
        impl crate::Resettable for WKEN_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
    #[doc = "WKFL (rw) register accessor: Wake up Flags register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`wkfl::R`].  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`wkfl::W`]. You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@wkfl`]
module"]
    pub type WKFL = crate::Reg<wkfl::WKFL_SPEC>;
    #[doc = "Wake up Flags register"]
    pub mod wkfl {
        #[doc = "Register `WKFL` reader"]
        pub type R = crate::R<WKFL_SPEC>;
        #[doc = "Register `WKFL` writer"]
        pub type W = crate::W<WKFL_SPEC>;
        #[doc = "Field `RX_NE` reader - Wake-Up Flag for RX FIFO Not Empty"]
        pub type RX_NE_R = crate::BitReader;
        #[doc = "Field `RX_NE` writer - Wake-Up Flag for RX FIFO Not Empty"]
        pub type RX_NE_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RX_FULL` reader - Wake-Up Flag for RX FIFO Full"]
        pub type RX_FULL_R = crate::BitReader;
        #[doc = "Field `RX_FULL` writer - Wake-Up Flag for RX FIFO Full"]
        pub type RX_FULL_W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RX_THD` reader - Wake-Up Flag for RX FIFO Threshold Met"]
        pub type RX_THD_R = crate::BitReader;
        #[doc = "Field `RX_THD` writer - Wake-Up Flag for RX FIFO Threshold Met"]
        pub type RX_THD_W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Wake-Up Flag for RX FIFO Not Empty"]
            #[inline(always)]
            pub fn rx_ne(&self) -> RX_NE_R {
                RX_NE_R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Wake-Up Flag for RX FIFO Full"]
            #[inline(always)]
            pub fn rx_full(&self) -> RX_FULL_R {
                RX_FULL_R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - Wake-Up Flag for RX FIFO Threshold Met"]
            #[inline(always)]
            pub fn rx_thd(&self) -> RX_THD_R {
                RX_THD_R::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Wake-Up Flag for RX FIFO Not Empty"]
            #[inline(always)]
            #[must_use]
            pub fn rx_ne(&mut self) -> RX_NE_W<WKFL_SPEC> {
                RX_NE_W::new(self, 0)
            }
            #[doc = "Bit 1 - Wake-Up Flag for RX FIFO Full"]
            #[inline(always)]
            #[must_use]
            pub fn rx_full(&mut self) -> RX_FULL_W<WKFL_SPEC> {
                RX_FULL_W::new(self, 1)
            }
            #[doc = "Bit 2 - Wake-Up Flag for RX FIFO Threshold Met"]
            #[inline(always)]
            #[must_use]
            pub fn rx_thd(&mut self) -> RX_THD_W<WKFL_SPEC> {
                RX_THD_W::new(self, 2)
            }
            #[doc = r" Writes raw bits to the register."]
            #[doc = r""]
            #[doc = r" # Safety"]
            #[doc = r""]
            #[doc = r" Passing incorrect value can cause undefined behaviour. See reference manual"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
        #[doc = "Wake up Flags register\n\nYou can [`read`](crate::generic::Reg::read) this register and get [`wkfl::R`](R).  You can [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`write_with_zero`](crate::generic::Reg::write_with_zero) this register using [`wkfl::W`](W). You can also [`modify`](crate::generic::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct WKFL_SPEC;
        impl crate::RegisterSpec for WKFL_SPEC {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`wkfl::R`](R) reader structure"]
        impl crate::Readable for WKFL_SPEC {}
        #[doc = "`write(|w| ..)` method takes [`wkfl::W`](W) writer structure"]
        impl crate::Writable for WKFL_SPEC {
            const ZERO_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
            const ONE_TO_MODIFY_FIELDS_BITMAP: u32 = 0;
        }
        #[doc = "`reset()` method sets WKFL to value 0"]
        impl crate::Resettable for WKFL_SPEC {
            const RESET_VALUE: u32 = 0;
        }
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "TMR0"]
    pub TMR0: TMR0,
    #[doc = "UART0"]
    pub UART0: UART0,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            TMR0: TMR0 {
                _marker: PhantomData,
            },
            UART0: UART0 {
                _marker: PhantomData,
            },
        }
    }
}
